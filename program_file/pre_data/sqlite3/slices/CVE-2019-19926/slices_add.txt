1 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 3 file: select.c
if ( rc )  location: 2757 cross_layer: 3 file: select.c
testcase ( rc != SQLITE_OK ); location: 2773 cross_layer: 3 file: select.c
return rc ; location: 2866 cross_layer: 3 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 4 file: select.c
return rc ; location: 5852 cross_layer: 4 file: select.c
------------------------------
2 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , p , & destQueue ); location: 2424 cross_layer: 3 file: select.c
assert ( p -> pPrior == 0 ); location: 2425 cross_layer: 3 file: select.c
p -> pPrior = pSetup; location: 2426 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrTop ); location: 2430 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 2431 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( pParse -> db , p -> pOrderBy ); location: 2434 cross_layer: 3 file: select.c
p -> pOrderBy = pOrderBy; location: 2435 cross_layer: 3 file: select.c
p -> pLimit = pLimit; location: 2436 cross_layer: 3 file: select.c
generateWithRecursiveQuery ( pParse , p , & dest ); location: 2580 cross_layer: 4 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 4 file: select.c
return multiSelectOrderBy ( pParse , p , pDest ) ; location: 2587 cross_layer: 4 file: select.c
static int multiSelectOrderBy(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 3117 cross_layer: 5 file: select.c
assert ( p -> pOrderBy != 0 ); location: 3153 cross_layer: 5 file: select.c
db = pParse -> db; location: 3155 cross_layer: 5 file: select.c
v = pParse -> pVdbe; location: 3156 cross_layer: 5 file: select.c
assert ( v != 0 ); location: 3157 cross_layer: 5 file: select.c
labelEnd = sqlite3VdbeMakeLabel ( pParse ); location: 3158 cross_layer: 5 file: select.c
labelCmpr = sqlite3VdbeMakeLabel ( pParse ); location: 3159 cross_layer: 5 file: select.c
op = p -> op; location: 3164 cross_layer: 5 file: select.c
pPrior = p -> pPrior; location: 3165 cross_layer: 5 file: select.c
assert ( pPrior -> pOrderBy == 0 ); location: 3166 cross_layer: 5 file: select.c
pOrderBy = p -> pOrderBy; location: 3167 cross_layer: 5 file: select.c
assert ( pOrderBy ); location: 3168 cross_layer: 5 file: select.c
nOrderBy = pOrderBy -> nExpr; location: 3169 cross_layer: 5 file: select.c
if ( op != TK_ALL )  location: 3175 cross_layer: 5 file: select.c
for(i=1; db->mallocFailed==0 && i<=p->pEList->nExpr; i++) location: 3176 cross_layer: 5 file: select.c
for(j=0, pItem=pOrderBy->a; j<nOrderBy; j++, pItem++) location: 3178 cross_layer: 5 file: select.c
assert ( pItem -> u . x . iOrderByCol > 0 ); location: 3179 cross_layer: 5 file: select.c
if ( pItem -> u . x . iOrderByCol == i )  location: 3180 cross_layer: 5 file: select.c
if ( j == nOrderBy )  location: 3182 cross_layer: 5 file: select.c
Expr * pNew = sqlite3Expr ( db , TK_INTEGER , 0 ) ; location: 3183 cross_layer: 5 file: select.c
if ( pNew == 0 )  location: 3184 cross_layer: 5 file: select.c
pNew -> flags |= EP_IntValue; location: 3185 cross_layer: 5 file: select.c
pNew -> u . iValue = i; location: 3186 cross_layer: 5 file: select.c
p -> pOrderBy = pOrderBy = sqlite3ExprListAppend ( pParse , pOrderBy , pNew ); location: 3187 cross_layer: 5 file: select.c
if ( pOrderBy )  location: 3188 cross_layer: 5 file: select.c
pOrderBy -> a [ nOrderBy ++ ] . u . x . iOrderByCol = ( u16 ) i; location: 3188 cross_layer: 5 file: select.c
aPermute = sqlite3DbMallocRawNN ( db , sizeof ( int ) * ( nOrderBy + 1 ) ); location: 3200 cross_layer: 5 file: select.c
if ( aPermute )  location: 3201 cross_layer: 5 file: select.c
aPermute [ 0 ] = nOrderBy; location: 3203 cross_layer: 5 file: select.c
for(i=1, pItem=pOrderBy->a; i<=nOrderBy; i++, pItem++) location: 3204 cross_layer: 5 file: select.c
assert ( pItem -> u . x . iOrderByCol > 0 ); location: 3205 cross_layer: 5 file: select.c
assert ( pItem -> u . x . iOrderByCol <= p -> pEList -> nExpr ); location: 3206 cross_layer: 5 file: select.c
aPermute [ i ] = pItem -> u . x . iOrderByCol - 1; location: 3207 cross_layer: 5 file: select.c
pKeyMerge = multiSelectOrderByKeyInfo ( pParse , p , 1 ); location: 3209 cross_layer: 5 file: select.c
p -> pOrderBy = pOrderBy; location: 3216 cross_layer: 5 file: select.c
pPrior -> pOrderBy = sqlite3ExprListDup ( pParse -> db , pOrderBy , 0 ); location: 3217 cross_layer: 5 file: select.c
if ( op == TK_ALL )  location: 3223 cross_layer: 5 file: select.c
int nExpr = p -> pEList -> nExpr ; location: 3226 cross_layer: 5 file: select.c
assert ( nOrderBy >= nExpr || db -> mallocFailed ); location: 3227 cross_layer: 5 file: select.c
regPrev = pParse -> nMem + 1; location: 3228 cross_layer: 5 file: select.c
pParse -> nMem += nExpr + 1; location: 3229 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regPrev ); location: 3230 cross_layer: 5 file: select.c
pKeyDup = sqlite3KeyInfoAlloc ( db , nExpr , 1 ); location: 3231 cross_layer: 5 file: select.c
if ( pKeyDup )  location: 3232 cross_layer: 5 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pKeyDup ) ); location: 3233 cross_layer: 5 file: select.c
for(i=0; i<nExpr; i++) location: 3234 cross_layer: 5 file: select.c
pKeyDup -> aColl [ i ] = multiSelectCollSeq ( pParse , p , i ); location: 3235 cross_layer: 5 file: select.c
pKeyDup -> aSortFlags [ i ] = 0; location: 3236 cross_layer: 5 file: select.c
p -> pPrior = 0; location: 3243 cross_layer: 5 file: select.c
pPrior -> pNext = 0; location: 3244 cross_layer: 5 file: select.c
sqlite3ResolveOrderGroupBy ( pParse , p , p -> pOrderBy , "ORDER" ); location: 3245 cross_layer: 5 file: select.c
if ( pPrior -> pPrior == 0 )  location: 3246 cross_layer: 5 file: select.c
sqlite3ResolveOrderGroupBy ( pParse , pPrior , pPrior -> pOrderBy , "ORDER" ); location: 3247 cross_layer: 5 file: select.c
computeLimitRegisters ( pParse , p , labelEnd ); location: 3251 cross_layer: 5 file: select.c
if ( p -> iLimit && op == TK_ALL )  location: 3252 cross_layer: 5 file: select.c
regLimitA = ++ pParse -> nMem; location: 3253 cross_layer: 5 file: select.c
regLimitB = ++ pParse -> nMem; location: 3254 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , p -> iOffset ? p -> iOffset + 1 : p -> iLimit , regLimitA ); location: 3255 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regLimitA , regLimitB ); location: 3257 cross_layer: 5 file: select.c
sqlite3ExprDelete ( db , p -> pLimit ); location: 3261 cross_layer: 5 file: select.c
p -> pLimit = 0; location: 3262 cross_layer: 5 file: select.c
regAddrA = ++ pParse -> nMem; location: 3264 cross_layer: 5 file: select.c
regAddrB = ++ pParse -> nMem; location: 3265 cross_layer: 5 file: select.c
regOutA = ++ pParse -> nMem; location: 3266 cross_layer: 5 file: select.c
regOutB = ++ pParse -> nMem; location: 3267 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & destA , SRT_Coroutine , regAddrA ); location: 3268 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & destB , SRT_Coroutine , regAddrB ); location: 3269 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MERGE (%s)" , selectOpName ( p -> op ) ) ); location: 3271 cross_layer: 5 file: select.c
addrSelectA = sqlite3VdbeCurrentAddr ( v ) + 1; location: 3276 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeAddOp3 ( v , OP_InitCoroutine , regAddrA , 0 , addrSelectA ); location: 3277 cross_layer: 5 file: select.c
VdbeComment ( ( v , "left SELECT" ) ); location: 3278 cross_layer: 5 file: select.c
pPrior -> iLimit = regLimitA; location: 3279 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "LEFT" ) ); location: 3280 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pPrior , & destA ); location: 3281 cross_layer: 5 file: select.c
sqlite3VdbeEndCoroutine ( v , regAddrA ); location: 3282 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 3283 cross_layer: 5 file: select.c
addrSelectB = sqlite3VdbeCurrentAddr ( v ) + 1; location: 3288 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeAddOp3 ( v , OP_InitCoroutine , regAddrB , 0 , addrSelectB ); location: 3289 cross_layer: 5 file: select.c
VdbeComment ( ( v , "right SELECT" ) ); location: 3290 cross_layer: 5 file: select.c
savedLimit = p -> iLimit; location: 3291 cross_layer: 5 file: select.c
savedOffset = p -> iOffset; location: 3292 cross_layer: 5 file: select.c
p -> iLimit = regLimitB; location: 3293 cross_layer: 5 file: select.c
p -> iOffset = 0; location: 3294 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "RIGHT" ) ); location: 3295 cross_layer: 5 file: select.c
sqlite3Select ( pParse , p , & destB ); location: 3296 cross_layer: 5 file: select.c
p -> iLimit = savedLimit; location: 3297 cross_layer: 5 file: select.c
p -> iOffset = savedOffset; location: 3298 cross_layer: 5 file: select.c
sqlite3VdbeEndCoroutine ( v , regAddrB ); location: 3299 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "Output routine for A" ) ); location: 3304 cross_layer: 5 file: select.c
addrOutA = generateOutputSubroutine ( pParse , p , & destA , pDest , regOutA , regPrev , pKeyDup , labelEnd ); location: 3305 cross_layer: 5 file: select.c
if ( op == TK_ALL || op == TK_UNION )  location: 3312 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "Output routine for B" ) ); location: 3313 cross_layer: 5 file: select.c
addrOutB = generateOutputSubroutine ( pParse , p , & destB , pDest , regOutB , regPrev , pKeyDup , labelEnd ); location: 3314 cross_layer: 5 file: select.c
sqlite3KeyInfoUnref ( pKeyDup ); location: 3318 cross_layer: 5 file: select.c
if ( op == TK_EXCEPT || op == TK_INTERSECT )  location: 3323 cross_layer: 5 file: select.c
addrEofA_noB = addrEofA = labelEnd; location: 3324 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "eof-A subroutine" ) ); location: 3326 cross_layer: 5 file: select.c
addrEofA = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutB , addrOutB ); location: 3327 cross_layer: 5 file: select.c
addrEofA_noB = sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , labelEnd ); location: 3328 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3329 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , addrEofA ); location: 3330 cross_layer: 5 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 3331 cross_layer: 5 file: select.c
if ( op == TK_INTERSECT )  location: 3337 cross_layer: 5 file: select.c
addrEofB = addrEofA; location: 3338 cross_layer: 5 file: select.c
if ( p -> nSelectRow > pPrior -> nSelectRow )  location: 3339 cross_layer: 5 file: select.c
p -> nSelectRow = pPrior -> nSelectRow; location: 3339 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "eof-B subroutine" ) ); location: 3341 cross_layer: 5 file: select.c
addrEofB = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutA , addrOutA ); location: 3342 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , labelEnd ); location: 3343 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3343 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , addrEofB ); location: 3344 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "A-lt-B subroutine" ) ); location: 3349 cross_layer: 5 file: select.c
addrAltB = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutA , addrOutA ); location: 3350 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA ); location: 3351 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3351 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3352 cross_layer: 5 file: select.c
if ( op == TK_ALL )  location: 3356 cross_layer: 5 file: select.c
addrAeqB = addrAltB; location: 3357 cross_layer: 5 file: select.c
if ( op == TK_INTERSECT )  location: 3358 cross_layer: 5 file: select.c
addrAeqB = addrAltB; location: 3359 cross_layer: 5 file: select.c
addrAltB ++; location: 3360 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "A-eq-B subroutine" ) ); location: 3362 cross_layer: 5 file: select.c
addrAeqB = sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA ); location: 3363 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3364 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3365 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "A-gt-B subroutine" ) ); location: 3370 cross_layer: 5 file: select.c
addrAgtB = sqlite3VdbeCurrentAddr ( v ); location: 3371 cross_layer: 5 file: select.c
if ( op == TK_ALL || op == TK_UNION )  location: 3372 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutB , addrOutB ); location: 3373 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , addrEofB ); location: 3375 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3375 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3376 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 3380 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA_noB ); location: 3381 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3381 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , addrEofB ); location: 3382 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3382 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , labelCmpr ); location: 3386 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Permutation , 0 , 0 , 0 , ( char * ) aPermute , P4_INTARRAY ); location: 3387 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , destA . iSdst , destB . iSdst , nOrderBy , ( char * ) pKeyMerge , P4_KEYINFO ); location: 3388 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_PERMUTE ); location: 3390 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addrAltB , addrAeqB , addrAgtB ); location: 3391 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3391 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , labelEnd ); location: 3395 cross_layer: 5 file: select.c
if ( p -> pPrior )  location: 3399 cross_layer: 5 file: select.c
sqlite3SelectDelete ( db , p -> pPrior ); location: 3400 cross_layer: 5 file: select.c
p -> pPrior = pPrior; location: 3402 cross_layer: 5 file: select.c
pPrior -> pNext = p; location: 3403 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 3407 cross_layer: 5 file: select.c
return pParse -> nErr != 0 ; location: 3408 cross_layer: 5 file: select.c
if ( pPrior -> pPrior == 0 )  location: 2591 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "COMPOUND QUERY" ) ); location: 2592 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "LEFT-MOST SUBQUERY" ) ); location: 2593 cross_layer: 4 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 4 file: select.c
assert ( ! pPrior -> pLimit ); location: 2603 cross_layer: 4 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 4 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 4 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 4 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 4 file: select.c
int sqlite3Select(
Parse *pParse,         /* The parser context */
Select *p,             /* The SELECT statement being coded. */
SelectDest *pDest      /* What to do with the query results */
) location: 5676 cross_layer: 5 file: select.c
db = pParse -> db; location: 5695 cross_layer: 5 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 5696 cross_layer: 5 file: select.c
if ( p == 0 || db -> mallocFailed || pParse -> nErr )  location: 5697 cross_layer: 5 file: select.c
if ( sqlite3AuthCheck ( pParse , SQLITE_SELECT , 0 , 0 , 0 ) )  location: 5700 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "begin processing:\n" , pParse -> addrExplain ) ); location: 5703 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5705 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistFifo ); location: 5709 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Fifo ); location: 5710 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistQueue ); location: 5711 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Queue ); location: 5712 cross_layer: 5 file: select.c
if ( IgnorableOrderby ( pDest ) )  location: 5713 cross_layer: 5 file: select.c
assert ( pDest -> eDest == SRT_Exists || pDest -> eDest == SRT_Union || pDest -> eDest == SRT_Except || pDest -> eDest == SRT_Discard || pDest -> eDest == SRT_Queue || pDest -> eDest == SRT_DistFifo || pDest -> eDest == SRT_DistQueue || pDest -> eDest == SRT_Fifo ); location: 5714 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , p -> pOrderBy ); location: 5720 cross_layer: 5 file: select.c
p -> pOrderBy = 0; location: 5721 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 5722 cross_layer: 5 file: select.c
sqlite3SelectPrep ( pParse , p , 0 ); location: 5724 cross_layer: 5 file: select.c
if ( pParse -> nErr || db -> mallocFailed )  location: 5725 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 5728 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after name resolution:\n" ) ); location: 5731 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5732 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_Output )  location: 5736 cross_layer: 5 file: select.c
generateColumnNames ( pParse , p ); location: 5737 cross_layer: 5 file: select.c
if ( sqlite3WindowRewrite ( pParse , p ) )  location: 5741 cross_layer: 5 file: select.c
if ( p -> pWin && ( sqlite3SelectTrace & 0x108 ) != 0 )  location: 5745 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after window rewrite:\n" ) ); location: 5746 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5747 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5751 cross_layer: 5 file: select.c
isAgg = ( p -> selFlags & SF_Aggregate ) != 0; location: 5752 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5754 cross_layer: 5 file: select.c
for(i=0; !p->pPrior && i<pTabList->nSrc; i++) location: 5760 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5761 cross_layer: 5 file: select.c
Select * pSub = pItem -> pSelect ; location: 5762 cross_layer: 5 file: select.c
Table * pTab = pItem -> pTab ; location: 5763 cross_layer: 5 file: select.c
if ( ( pItem -> fg . jointype & JT_LEFT ) != 0 && sqlite3ExprImpliesNonNullRow ( p -> pWhere , pItem -> iCursor ) && OptimizationEnabled ( db , SQLITE_SimplifyJoin ) )  location: 5768 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "LEFT-JOIN simplifies to JOIN on term %d\n" , i ) ); location: 5772 cross_layer: 5 file: select.c
pItem -> fg . jointype &= ~ ( JT_LEFT | JT_OUTER ); location: 5774 cross_layer: 5 file: select.c
unsetJoinExpr ( p -> pWhere , pItem -> iCursor ); location: 5775 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5779 cross_layer: 5 file: select.c
if ( pTab -> nCol != pSub -> pEList -> nExpr )  location: 5783 cross_layer: 5 file: select.c
sqlite3ErrorMsg ( pParse , "expected %d columns for '%s' but got %d" , pTab -> nCol , pTab -> zName , pSub -> pEList -> nExpr ); location: 5784 cross_layer: 5 file: select.c
if ( ( pSub -> selFlags & SF_Aggregate ) != 0 )  location: 5796 cross_layer: 5 file: select.c
assert ( pSub -> pGroupBy == 0 ); location: 5797 cross_layer: 5 file: select.c
if ( pSub -> pOrderBy != 0 && i == 0 && ( p -> selFlags & SF_ComplexResult ) != 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5817 cross_layer: 5 file: select.c
if ( flattenSubquery ( pParse , p , i , isAgg ) )  location: 5826 cross_layer: 5 file: select.c
if ( pParse -> nErr )  location: 5827 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5831 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5832 cross_layer: 5 file: select.c
if ( ! IgnorableOrderby ( pDest ) )  location: 5833 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5834 cross_layer: 5 file: select.c
if ( p -> pPrior )  location: 5843 cross_layer: 5 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end compound-select processing\n" ) ); location: 5846 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 5847 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5848 cross_layer: 5 file: select.c
if ( p -> pNext == 0 )  location: 5851 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 5851 cross_layer: 5 file: select.c
return rc ; location: 5852 cross_layer: 5 file: select.c
if ( pTabList -> nSrc > 1 && OptimizationEnabled ( db , SQLITE_PropagateConst ) && propagateConstants ( pParse , p ) )  location: 5861 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After constant propagation:\n" ) ); location: 5867 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5868 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Constant propagation not helpful\n" ) ); location: 5872 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_QueryFlattener | SQLITE_CountOfView ) && countOfViewOptimization ( pParse , p ) )  location: 5876 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5879 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 5880 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5881 cross_layer: 5 file: select.c
for(i=0; i<pTabList->nSrc; i++) location: 5889 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5890 cross_layer: 5 file: select.c
if ( pItem -> colUsed == 0 && pItem -> zName != 0 )  location: 5913 cross_layer: 5 file: select.c
sqlite3AuthCheck ( pParse , SQLITE_READ , pItem -> zName , "" , pItem -> zDatabase ); location: 5914 cross_layer: 5 file: select.c
pSub = pItem -> pSelect; location: 5920 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5921 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub != 0 ); location: 5935 cross_layer: 5 file: select.c
pParse -> nHeight += sqlite3SelectExprHeight ( p ); location: 5944 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_PushDown ) && pushDownWhereTerms ( pParse , pSub , p -> pWhere , pItem -> iCursor , ( pItem -> fg . jointype & JT_OUTER ) != 0 ) )  location: 5949 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After WHERE-clause push-down into subquery %d:\n" , pSub -> selId ) ); location: 5955 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5957 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Push-down not possible\n" ) ); location: 5961 cross_layer: 5 file: select.c
zSavedAuthContext = pParse -> zAuthContext; location: 5964 cross_layer: 5 file: select.c
pParse -> zAuthContext = pItem -> zName; location: 5965 cross_layer: 5 file: select.c
if ( i == 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5976 cross_layer: 5 file: select.c
int addrTop = sqlite3VdbeCurrentAddr ( v ) + 1 ; location: 5983 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 5985 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_InitCoroutine , pItem -> regReturn , 0 , addrTop ); location: 5986 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , pItem -> pTab -> zName ) ); location: 5987 cross_layer: 5 file: select.c
pItem -> addrFillSub = addrTop; location: 5988 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_Coroutine , pItem -> regReturn ); location: 5989 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "CO-ROUTINE %u" , pSub -> selId ) ); location: 5990 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 5 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 5 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 5 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 5 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 5 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 5 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 5 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 5 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 5 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 5 file: select.c
if ( pPrior )  location: 6023 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 5 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 5 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 5 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 5 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 5 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 5 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 5 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 6047 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6048 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy; location: 6049 cross_layer: 5 file: select.c
pHaving = p -> pHaving; location: 6050 cross_layer: 5 file: select.c
sDistinct . isTnct = ( p -> selFlags & SF_Distinct ) != 0; location: 6051 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6056 cross_layer: 5 file: select.c
if ( ( p -> selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct && sqlite3ExprListCompare ( sSort . pOrderBy , pEList , - 1 ) == 0 && p -> pWin == 0 )  location: 6075 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 6079 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 5 file: select.c
assert ( sDistinct . isTnct ); location: 6084 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6102 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 5 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 5 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 5 file: select.c
sSort . addrSortIndex = - 1; location: 6113 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_EphemTab )  location: 6118 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 5 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 5 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 5 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 5 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 5 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 5 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 5 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 5 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 5 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 5 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_NOOP; location: 6145 cross_layer: 5 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 5 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 5 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 5 file: select.c
if ( pWin )  location: 6154 cross_layer: 5 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 5 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 5 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 5 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 5 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 5 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 5 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 5 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 5 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 5 file: select.c
if ( pWin )  location: 6190 cross_layer: 5 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 5 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 5 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 5 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 5 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 5 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 5 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 5 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 5 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 5 file: select.c
p -> nSelectRow = 66; location: 6249 cross_layer: 5 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 5 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 5 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 5 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 5 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 5 file: select.c
p -> nSelectRow = 0; location: 6276 cross_layer: 5 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 5 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 5 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 5 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 5 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 5 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 5 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 5 file: select.c
if ( pHaving )  location: 6296 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 5 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 5 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 5 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 5 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 5 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 5 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 5 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 5 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 5 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 5 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 5 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 5 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 5 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6331 cross_layer: 5 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 5 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 5 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 5 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 5 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 5 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 5 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 5 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 5 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 5 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 5 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 5 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 5 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 5 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 5 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 5 file: select.c
j = nGroupBy; location: 6422 cross_layer: 5 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 5 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 5 file: select.c
nCol ++; location: 6425 cross_layer: 5 file: select.c
j ++; location: 6426 cross_layer: 5 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 5 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 5 file: select.c
j = nGroupBy; location: 6431 cross_layer: 5 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 5 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 5 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 5 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 5 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 5 file: select.c
j ++; location: 6438 cross_layer: 5 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 5 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 5 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 5 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 5 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 5 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 5 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 5 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 5 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 5 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 5 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 5 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 5 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 5 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 5 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 5 file: select.c
if ( ( pTab = isSimpleCount ( p , & sAggInfo ) ) != 0 )  location: 6573 cross_layer: 5 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 5 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 5 file: select.c
int iRoot = pTab -> tnum ; location: 6592 cross_layer: 5 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 5 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 5 file: select.c
if ( ! HasRowid ( pTab ) )  location: 6606 cross_layer: 5 file: select.c
pBest = sqlite3PrimaryKeyIndex ( pTab ); location: 6606 cross_layer: 5 file: select.c
for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext) location: 6607 cross_layer: 5 file: select.c
if ( pIdx -> bUnordered == 0 && pIdx -> szIdxRow < pTab -> szTabRow && pIdx -> pPartIdxWhere == 0 && ( ! pBest || pIdx -> szIdxRow < pBest -> szIdxRow ) )  location: 6608 cross_layer: 5 file: select.c
pBest = pIdx; location: 6613 cross_layer: 5 file: select.c
if ( pBest )  location: 6616 cross_layer: 5 file: select.c
iRoot = pBest -> tnum; location: 6617 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 5 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 5 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 5 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 5 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 5 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 5 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 5 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 5 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 5 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 5 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 5 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 5 file: select.c
if ( regAcc )  location: 6676 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 5 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 5 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 5 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 5 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 5 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6727 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 5 file: select.c
return rc ; location: 6731 cross_layer: 5 file: select.c
p -> pLimit = 0; location: 2608 cross_layer: 4 file: select.c
if ( rc )  location: 2609 cross_layer: 4 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 4 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 4 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 4 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2616 cross_layer: 4 file: select.c
VdbeComment ( ( v , "Jump ahead if LIMIT reached" ) ); location: 2617 cross_layer: 4 file: select.c
if ( p -> iOffset )  location: 2618 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , p -> iLimit , p -> iOffset + 1 , p -> iOffset ); location: 2619 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "UNION ALL" ) ); location: 2623 cross_layer: 4 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 4 file: select.c
int sqlite3Select(
Parse *pParse,         /* The parser context */
Select *p,             /* The SELECT statement being coded. */
SelectDest *pDest      /* What to do with the query results */
) location: 5676 cross_layer: 5 file: select.c
db = pParse -> db; location: 5695 cross_layer: 5 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 5696 cross_layer: 5 file: select.c
if ( p == 0 || db -> mallocFailed || pParse -> nErr )  location: 5697 cross_layer: 5 file: select.c
if ( sqlite3AuthCheck ( pParse , SQLITE_SELECT , 0 , 0 , 0 ) )  location: 5700 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "begin processing:\n" , pParse -> addrExplain ) ); location: 5703 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5705 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistFifo ); location: 5709 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Fifo ); location: 5710 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistQueue ); location: 5711 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Queue ); location: 5712 cross_layer: 5 file: select.c
if ( IgnorableOrderby ( pDest ) )  location: 5713 cross_layer: 5 file: select.c
assert ( pDest -> eDest == SRT_Exists || pDest -> eDest == SRT_Union || pDest -> eDest == SRT_Except || pDest -> eDest == SRT_Discard || pDest -> eDest == SRT_Queue || pDest -> eDest == SRT_DistFifo || pDest -> eDest == SRT_DistQueue || pDest -> eDest == SRT_Fifo ); location: 5714 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , p -> pOrderBy ); location: 5720 cross_layer: 5 file: select.c
p -> pOrderBy = 0; location: 5721 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 5722 cross_layer: 5 file: select.c
sqlite3SelectPrep ( pParse , p , 0 ); location: 5724 cross_layer: 5 file: select.c
if ( pParse -> nErr || db -> mallocFailed )  location: 5725 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 5728 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after name resolution:\n" ) ); location: 5731 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5732 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_Output )  location: 5736 cross_layer: 5 file: select.c
generateColumnNames ( pParse , p ); location: 5737 cross_layer: 5 file: select.c
if ( sqlite3WindowRewrite ( pParse , p ) )  location: 5741 cross_layer: 5 file: select.c
if ( p -> pWin && ( sqlite3SelectTrace & 0x108 ) != 0 )  location: 5745 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after window rewrite:\n" ) ); location: 5746 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5747 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5751 cross_layer: 5 file: select.c
isAgg = ( p -> selFlags & SF_Aggregate ) != 0; location: 5752 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5754 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5761 cross_layer: 5 file: select.c
Select * pSub = pItem -> pSelect ; location: 5762 cross_layer: 5 file: select.c
Table * pTab = pItem -> pTab ; location: 5763 cross_layer: 5 file: select.c
if ( ( pItem -> fg . jointype & JT_LEFT ) != 0 && sqlite3ExprImpliesNonNullRow ( p -> pWhere , pItem -> iCursor ) && OptimizationEnabled ( db , SQLITE_SimplifyJoin ) )  location: 5768 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "LEFT-JOIN simplifies to JOIN on term %d\n" , i ) ); location: 5772 cross_layer: 5 file: select.c
pItem -> fg . jointype &= ~ ( JT_LEFT | JT_OUTER ); location: 5774 cross_layer: 5 file: select.c
unsetJoinExpr ( p -> pWhere , pItem -> iCursor ); location: 5775 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5779 cross_layer: 5 file: select.c
if ( pTab -> nCol != pSub -> pEList -> nExpr )  location: 5783 cross_layer: 5 file: select.c
sqlite3ErrorMsg ( pParse , "expected %d columns for '%s' but got %d" , pTab -> nCol , pTab -> zName , pSub -> pEList -> nExpr ); location: 5784 cross_layer: 5 file: select.c
if ( ( pSub -> selFlags & SF_Aggregate ) != 0 )  location: 5796 cross_layer: 5 file: select.c
assert ( pSub -> pGroupBy == 0 ); location: 5797 cross_layer: 5 file: select.c
if ( pSub -> pOrderBy != 0 && i == 0 && ( p -> selFlags & SF_ComplexResult ) != 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5817 cross_layer: 5 file: select.c
if ( flattenSubquery ( pParse , p , i , isAgg ) )  location: 5826 cross_layer: 5 file: select.c
if ( pParse -> nErr )  location: 5827 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5831 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5832 cross_layer: 5 file: select.c
if ( ! IgnorableOrderby ( pDest ) )  location: 5833 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5834 cross_layer: 5 file: select.c
if ( p -> pPrior )  location: 5843 cross_layer: 5 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end compound-select processing\n" ) ); location: 5846 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 5847 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5848 cross_layer: 5 file: select.c
if ( p -> pNext == 0 )  location: 5851 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 5851 cross_layer: 5 file: select.c
return rc ; location: 5852 cross_layer: 5 file: select.c
if ( pTabList -> nSrc > 1 && OptimizationEnabled ( db , SQLITE_PropagateConst ) && propagateConstants ( pParse , p ) )  location: 5861 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After constant propagation:\n" ) ); location: 5867 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5868 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Constant propagation not helpful\n" ) ); location: 5872 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_QueryFlattener | SQLITE_CountOfView ) && countOfViewOptimization ( pParse , p ) )  location: 5876 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5879 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 5880 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5881 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5890 cross_layer: 5 file: select.c
if ( pItem -> colUsed == 0 && pItem -> zName != 0 )  location: 5913 cross_layer: 5 file: select.c
sqlite3AuthCheck ( pParse , SQLITE_READ , pItem -> zName , "" , pItem -> zDatabase ); location: 5914 cross_layer: 5 file: select.c
pSub = pItem -> pSelect; location: 5920 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5921 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub != 0 ); location: 5935 cross_layer: 5 file: select.c
pParse -> nHeight += sqlite3SelectExprHeight ( p ); location: 5944 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_PushDown ) && pushDownWhereTerms ( pParse , pSub , p -> pWhere , pItem -> iCursor , ( pItem -> fg . jointype & JT_OUTER ) != 0 ) )  location: 5949 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After WHERE-clause push-down into subquery %d:\n" , pSub -> selId ) ); location: 5955 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5957 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Push-down not possible\n" ) ); location: 5961 cross_layer: 5 file: select.c
zSavedAuthContext = pParse -> zAuthContext; location: 5964 cross_layer: 5 file: select.c
pParse -> zAuthContext = pItem -> zName; location: 5965 cross_layer: 5 file: select.c
if ( i == 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5976 cross_layer: 5 file: select.c
int addrTop = sqlite3VdbeCurrentAddr ( v ) + 1 ; location: 5983 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 5985 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_InitCoroutine , pItem -> regReturn , 0 , addrTop ); location: 5986 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , pItem -> pTab -> zName ) ); location: 5987 cross_layer: 5 file: select.c
pItem -> addrFillSub = addrTop; location: 5988 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_Coroutine , pItem -> regReturn ); location: 5989 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "CO-ROUTINE %u" , pSub -> selId ) ); location: 5990 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 5 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 5 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 5 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 5 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 5 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 5 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 5 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 5 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 5 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 5 file: select.c
if ( pPrior )  location: 6023 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 5 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 5 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 5 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 5 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 5 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 5 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 5 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 6047 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6048 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy; location: 6049 cross_layer: 5 file: select.c
pHaving = p -> pHaving; location: 6050 cross_layer: 5 file: select.c
sDistinct . isTnct = ( p -> selFlags & SF_Distinct ) != 0; location: 6051 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6056 cross_layer: 5 file: select.c
if ( ( p -> selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct && sqlite3ExprListCompare ( sSort . pOrderBy , pEList , - 1 ) == 0 && p -> pWin == 0 )  location: 6075 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 6079 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 5 file: select.c
assert ( sDistinct . isTnct ); location: 6084 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6102 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 5 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 5 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 5 file: select.c
sSort . addrSortIndex = - 1; location: 6113 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_EphemTab )  location: 6118 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 5 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 5 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 5 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 5 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 5 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 5 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 5 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 5 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 5 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 5 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_NOOP; location: 6145 cross_layer: 5 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 5 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 5 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 5 file: select.c
if ( pWin )  location: 6154 cross_layer: 5 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 5 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 5 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 5 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 5 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 5 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 5 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 5 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 5 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 5 file: select.c
if ( pWin )  location: 6190 cross_layer: 5 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 5 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 5 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 5 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 5 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 5 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 5 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 5 file: select.c
p -> nSelectRow = 66; location: 6249 cross_layer: 5 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 5 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 5 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 5 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 5 file: select.c
p -> nSelectRow = 0; location: 6276 cross_layer: 5 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 5 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 5 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 5 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 5 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 5 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 5 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 5 file: select.c
if ( pHaving )  location: 6296 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 5 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 5 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 5 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 5 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 5 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 5 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 5 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 5 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 5 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 5 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 5 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 5 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6331 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 5 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 5 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 5 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 5 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 5 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 5 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 5 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 5 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 5 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 5 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 5 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 5 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 5 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 5 file: select.c
j = nGroupBy; location: 6422 cross_layer: 5 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 5 file: select.c
nCol ++; location: 6425 cross_layer: 5 file: select.c
j ++; location: 6426 cross_layer: 5 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 5 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 5 file: select.c
j = nGroupBy; location: 6431 cross_layer: 5 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 5 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 5 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 5 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 5 file: select.c
j ++; location: 6438 cross_layer: 5 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 5 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 5 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 5 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 5 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 5 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 5 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 5 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 5 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 5 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 5 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 5 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 5 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 5 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 5 file: select.c
if ( ( pTab = isSimpleCount ( p , & sAggInfo ) ) != 0 )  location: 6573 cross_layer: 5 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 5 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 5 file: select.c
int iRoot = pTab -> tnum ; location: 6592 cross_layer: 5 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 5 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 5 file: select.c
if ( ! HasRowid ( pTab ) )  location: 6606 cross_layer: 5 file: select.c
pBest = sqlite3PrimaryKeyIndex ( pTab ); location: 6606 cross_layer: 5 file: select.c
if ( pIdx -> bUnordered == 0 && pIdx -> szIdxRow < pTab -> szTabRow && pIdx -> pPartIdxWhere == 0 && ( ! pBest || pIdx -> szIdxRow < pBest -> szIdxRow ) )  location: 6608 cross_layer: 5 file: select.c
pBest = pIdx; location: 6613 cross_layer: 5 file: select.c
if ( pBest )  location: 6616 cross_layer: 5 file: select.c
iRoot = pBest -> tnum; location: 6617 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 5 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 5 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 5 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 5 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 5 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 5 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 5 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 5 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 5 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 5 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 5 file: select.c
if ( regAcc )  location: 6676 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 5 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 5 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 5 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 5 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 5 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6727 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 5 file: select.c
return rc ; location: 6731 cross_layer: 5 file: select.c
testcase ( rc != SQLITE_OK ); location: 2625 cross_layer: 4 file: select.c
pDelete = p -> pPrior; location: 2626 cross_layer: 4 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 4 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 4 file: select.c
if ( addr )  location: 2635 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addr ); location: 2636 cross_layer: 4 file: select.c
testcase ( p -> op == TK_EXCEPT ); location: 2649 cross_layer: 4 file: select.c
testcase ( p -> op == TK_UNION ); location: 2650 cross_layer: 4 file: select.c
assert ( p -> pLimit == 0 ); location: 2656 cross_layer: 4 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 4 file: select.c
assert ( p -> pOrderBy == 0 ); location: 2663 cross_layer: 4 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 4 file: select.c
assert ( p -> addrOpenEphm [ 0 ] == - 1 ); location: 2665 cross_layer: 4 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 4 file: select.c
findRightmost ( p ) -> selFlags |= SF_UsesEphemeral; location: 2667 cross_layer: 4 file: select.c
static Select *findRightmost(Select *p) location: 194 cross_layer: 5 file: select.c
while ( p -> pNext )  location: 195 cross_layer: 5 file: select.c
p = p -> pNext; location: 195 cross_layer: 5 file: select.c
return p ; location: 196 cross_layer: 5 file: select.c
assert ( p -> pEList ); location: 2668 cross_layer: 4 file: select.c
assert ( ! pPrior -> pOrderBy ); location: 2673 cross_layer: 4 file: select.c
sqlite3SelectDestInit ( & uniondest , priorOp , unionTab ); location: 2674 cross_layer: 4 file: select.c
void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm) location: 115 cross_layer: 5 file: select.c
pDest -> eDest = ( u8 ) eDest; location: 116 cross_layer: 5 file: select.c
pDest -> iSDParm = iParm; location: 117 cross_layer: 5 file: select.c
pDest -> zAffSdst = 0; location: 118 cross_layer: 5 file: select.c
pDest -> iSdst = 0; location: 119 cross_layer: 5 file: select.c
pDest -> nSdst = 0; location: 120 cross_layer: 5 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 4 file: select.c
int sqlite3Select(
Parse *pParse,         /* The parser context */
Select *p,             /* The SELECT statement being coded. */
SelectDest *pDest      /* What to do with the query results */
) location: 5676 cross_layer: 5 file: select.c
db = pParse -> db; location: 5695 cross_layer: 5 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 5696 cross_layer: 5 file: select.c
if ( p == 0 || db -> mallocFailed || pParse -> nErr )  location: 5697 cross_layer: 5 file: select.c
if ( sqlite3AuthCheck ( pParse , SQLITE_SELECT , 0 , 0 , 0 ) )  location: 5700 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "begin processing:\n" , pParse -> addrExplain ) ); location: 5703 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5705 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistFifo ); location: 5709 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Fifo ); location: 5710 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistQueue ); location: 5711 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Queue ); location: 5712 cross_layer: 5 file: select.c
if ( IgnorableOrderby ( pDest ) )  location: 5713 cross_layer: 5 file: select.c
assert ( pDest -> eDest == SRT_Exists || pDest -> eDest == SRT_Union || pDest -> eDest == SRT_Except || pDest -> eDest == SRT_Discard || pDest -> eDest == SRT_Queue || pDest -> eDest == SRT_DistFifo || pDest -> eDest == SRT_DistQueue || pDest -> eDest == SRT_Fifo ); location: 5714 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , p -> pOrderBy ); location: 5720 cross_layer: 5 file: select.c
p -> pOrderBy = 0; location: 5721 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 5722 cross_layer: 5 file: select.c
sqlite3SelectPrep ( pParse , p , 0 ); location: 5724 cross_layer: 5 file: select.c
if ( pParse -> nErr || db -> mallocFailed )  location: 5725 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 5728 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after name resolution:\n" ) ); location: 5731 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5732 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_Output )  location: 5736 cross_layer: 5 file: select.c
generateColumnNames ( pParse , p ); location: 5737 cross_layer: 5 file: select.c
if ( sqlite3WindowRewrite ( pParse , p ) )  location: 5741 cross_layer: 5 file: select.c
if ( p -> pWin && ( sqlite3SelectTrace & 0x108 ) != 0 )  location: 5745 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after window rewrite:\n" ) ); location: 5746 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5747 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5751 cross_layer: 5 file: select.c
isAgg = ( p -> selFlags & SF_Aggregate ) != 0; location: 5752 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5754 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5761 cross_layer: 5 file: select.c
Select * pSub = pItem -> pSelect ; location: 5762 cross_layer: 5 file: select.c
Table * pTab = pItem -> pTab ; location: 5763 cross_layer: 5 file: select.c
if ( ( pItem -> fg . jointype & JT_LEFT ) != 0 && sqlite3ExprImpliesNonNullRow ( p -> pWhere , pItem -> iCursor ) && OptimizationEnabled ( db , SQLITE_SimplifyJoin ) )  location: 5768 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "LEFT-JOIN simplifies to JOIN on term %d\n" , i ) ); location: 5772 cross_layer: 5 file: select.c
pItem -> fg . jointype &= ~ ( JT_LEFT | JT_OUTER ); location: 5774 cross_layer: 5 file: select.c
unsetJoinExpr ( p -> pWhere , pItem -> iCursor ); location: 5775 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5779 cross_layer: 5 file: select.c
if ( pTab -> nCol != pSub -> pEList -> nExpr )  location: 5783 cross_layer: 5 file: select.c
sqlite3ErrorMsg ( pParse , "expected %d columns for '%s' but got %d" , pTab -> nCol , pTab -> zName , pSub -> pEList -> nExpr ); location: 5784 cross_layer: 5 file: select.c
if ( ( pSub -> selFlags & SF_Aggregate ) != 0 )  location: 5796 cross_layer: 5 file: select.c
assert ( pSub -> pGroupBy == 0 ); location: 5797 cross_layer: 5 file: select.c
if ( pSub -> pOrderBy != 0 && i == 0 && ( p -> selFlags & SF_ComplexResult ) != 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5817 cross_layer: 5 file: select.c
if ( flattenSubquery ( pParse , p , i , isAgg ) )  location: 5826 cross_layer: 5 file: select.c
if ( pParse -> nErr )  location: 5827 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5831 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5832 cross_layer: 5 file: select.c
if ( ! IgnorableOrderby ( pDest ) )  location: 5833 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5834 cross_layer: 5 file: select.c
if ( p -> pPrior )  location: 5843 cross_layer: 5 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end compound-select processing\n" ) ); location: 5846 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 5847 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5848 cross_layer: 5 file: select.c
if ( p -> pNext == 0 )  location: 5851 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 5851 cross_layer: 5 file: select.c
return rc ; location: 5852 cross_layer: 5 file: select.c
if ( pTabList -> nSrc > 1 && OptimizationEnabled ( db , SQLITE_PropagateConst ) && propagateConstants ( pParse , p ) )  location: 5861 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After constant propagation:\n" ) ); location: 5867 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5868 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Constant propagation not helpful\n" ) ); location: 5872 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_QueryFlattener | SQLITE_CountOfView ) && countOfViewOptimization ( pParse , p ) )  location: 5876 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5879 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 5880 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5881 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5890 cross_layer: 5 file: select.c
if ( pItem -> colUsed == 0 && pItem -> zName != 0 )  location: 5913 cross_layer: 5 file: select.c
sqlite3AuthCheck ( pParse , SQLITE_READ , pItem -> zName , "" , pItem -> zDatabase ); location: 5914 cross_layer: 5 file: select.c
pSub = pItem -> pSelect; location: 5920 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5921 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub != 0 ); location: 5935 cross_layer: 5 file: select.c
pParse -> nHeight += sqlite3SelectExprHeight ( p ); location: 5944 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_PushDown ) && pushDownWhereTerms ( pParse , pSub , p -> pWhere , pItem -> iCursor , ( pItem -> fg . jointype & JT_OUTER ) != 0 ) )  location: 5949 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After WHERE-clause push-down into subquery %d:\n" , pSub -> selId ) ); location: 5955 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5957 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Push-down not possible\n" ) ); location: 5961 cross_layer: 5 file: select.c
zSavedAuthContext = pParse -> zAuthContext; location: 5964 cross_layer: 5 file: select.c
pParse -> zAuthContext = pItem -> zName; location: 5965 cross_layer: 5 file: select.c
if ( i == 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5976 cross_layer: 5 file: select.c
int addrTop = sqlite3VdbeCurrentAddr ( v ) + 1 ; location: 5983 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 5985 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_InitCoroutine , pItem -> regReturn , 0 , addrTop ); location: 5986 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , pItem -> pTab -> zName ) ); location: 5987 cross_layer: 5 file: select.c
pItem -> addrFillSub = addrTop; location: 5988 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_Coroutine , pItem -> regReturn ); location: 5989 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "CO-ROUTINE %u" , pSub -> selId ) ); location: 5990 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 5 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 5 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 5 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 5 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 5 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 5 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 5 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 5 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 5 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 5 file: select.c
if ( pPrior )  location: 6023 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 5 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 5 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 5 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 5 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 5 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 5 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 5 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 6047 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6048 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy; location: 6049 cross_layer: 5 file: select.c
pHaving = p -> pHaving; location: 6050 cross_layer: 5 file: select.c
sDistinct . isTnct = ( p -> selFlags & SF_Distinct ) != 0; location: 6051 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6056 cross_layer: 5 file: select.c
if ( ( p -> selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct && sqlite3ExprListCompare ( sSort . pOrderBy , pEList , - 1 ) == 0 && p -> pWin == 0 )  location: 6075 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 6079 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 5 file: select.c
assert ( sDistinct . isTnct ); location: 6084 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6102 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 5 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 5 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 5 file: select.c
sSort . addrSortIndex = - 1; location: 6113 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_EphemTab )  location: 6118 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 5 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 5 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 5 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 5 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 5 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 5 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 5 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 5 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 5 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 5 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_NOOP; location: 6145 cross_layer: 5 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 5 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 5 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 5 file: select.c
if ( pWin )  location: 6154 cross_layer: 5 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 5 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 5 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 5 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 5 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 5 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 5 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 5 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 5 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 5 file: select.c
if ( pWin )  location: 6190 cross_layer: 5 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 5 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 5 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 5 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 5 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 5 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 5 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 5 file: select.c
p -> nSelectRow = 66; location: 6249 cross_layer: 5 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 5 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 5 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 5 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 5 file: select.c
p -> nSelectRow = 0; location: 6276 cross_layer: 5 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 5 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 5 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 5 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 5 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 5 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 5 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 5 file: select.c
if ( pHaving )  location: 6296 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 5 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 5 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 5 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 5 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 5 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 5 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 5 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 5 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 5 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 5 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 5 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 5 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6331 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 5 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 5 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 5 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 5 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 5 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 5 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 5 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 5 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 5 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 5 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 5 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 5 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 5 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 5 file: select.c
j = nGroupBy; location: 6422 cross_layer: 5 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 5 file: select.c
nCol ++; location: 6425 cross_layer: 5 file: select.c
j ++; location: 6426 cross_layer: 5 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 5 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 5 file: select.c
j = nGroupBy; location: 6431 cross_layer: 5 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 5 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 5 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 5 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 5 file: select.c
j ++; location: 6438 cross_layer: 5 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 5 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 5 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 5 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 5 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 5 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 5 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 5 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 5 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 5 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 5 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 5 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 5 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 5 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 5 file: select.c
if ( ( pTab = isSimpleCount ( p , & sAggInfo ) ) != 0 )  location: 6573 cross_layer: 5 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 5 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 5 file: select.c
int iRoot = pTab -> tnum ; location: 6592 cross_layer: 5 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 5 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 5 file: select.c
if ( ! HasRowid ( pTab ) )  location: 6606 cross_layer: 5 file: select.c
pBest = sqlite3PrimaryKeyIndex ( pTab ); location: 6606 cross_layer: 5 file: select.c
if ( pIdx -> bUnordered == 0 && pIdx -> szIdxRow < pTab -> szTabRow && pIdx -> pPartIdxWhere == 0 && ( ! pBest || pIdx -> szIdxRow < pBest -> szIdxRow ) )  location: 6608 cross_layer: 5 file: select.c
pBest = pIdx; location: 6613 cross_layer: 5 file: select.c
if ( pBest )  location: 6616 cross_layer: 5 file: select.c
iRoot = pBest -> tnum; location: 6617 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 5 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 5 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 5 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 5 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 5 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 5 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 5 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 5 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 5 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 5 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 5 file: select.c
if ( regAcc )  location: 6676 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 5 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 5 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 5 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 5 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 5 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6727 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 5 file: select.c
return rc ; location: 6731 cross_layer: 5 file: select.c
if ( rc )  location: 2676 cross_layer: 4 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 4 file: select.c
assert ( p -> op == TK_UNION ); location: 2685 cross_layer: 4 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 4 file: select.c
pLimit = p -> pLimit; location: 2689 cross_layer: 4 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "%s USING TEMP B-TREE" , selectOpName ( p -> op ) ) ); location: 2692 cross_layer: 4 file: select.c
static const char *selectOpName(int id) location: 1366 cross_layer: 5 file: select.c
switch ( id )  location: 1368 cross_layer: 5 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 4 file: select.c
int sqlite3Select(
Parse *pParse,         /* The parser context */
Select *p,             /* The SELECT statement being coded. */
SelectDest *pDest      /* What to do with the query results */
) location: 5676 cross_layer: 5 file: select.c
db = pParse -> db; location: 5695 cross_layer: 5 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 5696 cross_layer: 5 file: select.c
if ( p == 0 || db -> mallocFailed || pParse -> nErr )  location: 5697 cross_layer: 5 file: select.c
if ( sqlite3AuthCheck ( pParse , SQLITE_SELECT , 0 , 0 , 0 ) )  location: 5700 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "begin processing:\n" , pParse -> addrExplain ) ); location: 5703 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5705 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistFifo ); location: 5709 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Fifo ); location: 5710 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistQueue ); location: 5711 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Queue ); location: 5712 cross_layer: 5 file: select.c
if ( IgnorableOrderby ( pDest ) )  location: 5713 cross_layer: 5 file: select.c
assert ( pDest -> eDest == SRT_Exists || pDest -> eDest == SRT_Union || pDest -> eDest == SRT_Except || pDest -> eDest == SRT_Discard || pDest -> eDest == SRT_Queue || pDest -> eDest == SRT_DistFifo || pDest -> eDest == SRT_DistQueue || pDest -> eDest == SRT_Fifo ); location: 5714 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , p -> pOrderBy ); location: 5720 cross_layer: 5 file: select.c
p -> pOrderBy = 0; location: 5721 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 5722 cross_layer: 5 file: select.c
sqlite3SelectPrep ( pParse , p , 0 ); location: 5724 cross_layer: 5 file: select.c
if ( pParse -> nErr || db -> mallocFailed )  location: 5725 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 5728 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after name resolution:\n" ) ); location: 5731 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5732 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_Output )  location: 5736 cross_layer: 5 file: select.c
generateColumnNames ( pParse , p ); location: 5737 cross_layer: 5 file: select.c
if ( sqlite3WindowRewrite ( pParse , p ) )  location: 5741 cross_layer: 5 file: select.c
if ( p -> pWin && ( sqlite3SelectTrace & 0x108 ) != 0 )  location: 5745 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after window rewrite:\n" ) ); location: 5746 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5747 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5751 cross_layer: 5 file: select.c
isAgg = ( p -> selFlags & SF_Aggregate ) != 0; location: 5752 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5754 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5761 cross_layer: 5 file: select.c
Select * pSub = pItem -> pSelect ; location: 5762 cross_layer: 5 file: select.c
Table * pTab = pItem -> pTab ; location: 5763 cross_layer: 5 file: select.c
if ( ( pItem -> fg . jointype & JT_LEFT ) != 0 && sqlite3ExprImpliesNonNullRow ( p -> pWhere , pItem -> iCursor ) && OptimizationEnabled ( db , SQLITE_SimplifyJoin ) )  location: 5768 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "LEFT-JOIN simplifies to JOIN on term %d\n" , i ) ); location: 5772 cross_layer: 5 file: select.c
pItem -> fg . jointype &= ~ ( JT_LEFT | JT_OUTER ); location: 5774 cross_layer: 5 file: select.c
unsetJoinExpr ( p -> pWhere , pItem -> iCursor ); location: 5775 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5779 cross_layer: 5 file: select.c
if ( pTab -> nCol != pSub -> pEList -> nExpr )  location: 5783 cross_layer: 5 file: select.c
sqlite3ErrorMsg ( pParse , "expected %d columns for '%s' but got %d" , pTab -> nCol , pTab -> zName , pSub -> pEList -> nExpr ); location: 5784 cross_layer: 5 file: select.c
if ( ( pSub -> selFlags & SF_Aggregate ) != 0 )  location: 5796 cross_layer: 5 file: select.c
assert ( pSub -> pGroupBy == 0 ); location: 5797 cross_layer: 5 file: select.c
if ( pSub -> pOrderBy != 0 && i == 0 && ( p -> selFlags & SF_ComplexResult ) != 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5817 cross_layer: 5 file: select.c
if ( flattenSubquery ( pParse , p , i , isAgg ) )  location: 5826 cross_layer: 5 file: select.c
if ( pParse -> nErr )  location: 5827 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5831 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5832 cross_layer: 5 file: select.c
if ( ! IgnorableOrderby ( pDest ) )  location: 5833 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5834 cross_layer: 5 file: select.c
if ( p -> pPrior )  location: 5843 cross_layer: 5 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end compound-select processing\n" ) ); location: 5846 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 5847 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5848 cross_layer: 5 file: select.c
if ( p -> pNext == 0 )  location: 5851 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 5851 cross_layer: 5 file: select.c
return rc ; location: 5852 cross_layer: 5 file: select.c
if ( pTabList -> nSrc > 1 && OptimizationEnabled ( db , SQLITE_PropagateConst ) && propagateConstants ( pParse , p ) )  location: 5861 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After constant propagation:\n" ) ); location: 5867 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5868 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Constant propagation not helpful\n" ) ); location: 5872 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_QueryFlattener | SQLITE_CountOfView ) && countOfViewOptimization ( pParse , p ) )  location: 5876 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5879 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 5880 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5881 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5890 cross_layer: 5 file: select.c
if ( pItem -> colUsed == 0 && pItem -> zName != 0 )  location: 5913 cross_layer: 5 file: select.c
sqlite3AuthCheck ( pParse , SQLITE_READ , pItem -> zName , "" , pItem -> zDatabase ); location: 5914 cross_layer: 5 file: select.c
pSub = pItem -> pSelect; location: 5920 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5921 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub != 0 ); location: 5935 cross_layer: 5 file: select.c
pParse -> nHeight += sqlite3SelectExprHeight ( p ); location: 5944 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_PushDown ) && pushDownWhereTerms ( pParse , pSub , p -> pWhere , pItem -> iCursor , ( pItem -> fg . jointype & JT_OUTER ) != 0 ) )  location: 5949 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After WHERE-clause push-down into subquery %d:\n" , pSub -> selId ) ); location: 5955 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5957 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Push-down not possible\n" ) ); location: 5961 cross_layer: 5 file: select.c
zSavedAuthContext = pParse -> zAuthContext; location: 5964 cross_layer: 5 file: select.c
pParse -> zAuthContext = pItem -> zName; location: 5965 cross_layer: 5 file: select.c
if ( i == 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5976 cross_layer: 5 file: select.c
int addrTop = sqlite3VdbeCurrentAddr ( v ) + 1 ; location: 5983 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 5985 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_InitCoroutine , pItem -> regReturn , 0 , addrTop ); location: 5986 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , pItem -> pTab -> zName ) ); location: 5987 cross_layer: 5 file: select.c
pItem -> addrFillSub = addrTop; location: 5988 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_Coroutine , pItem -> regReturn ); location: 5989 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "CO-ROUTINE %u" , pSub -> selId ) ); location: 5990 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 5 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 5 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 5 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 5 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 5 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 5 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 5 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 5 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 5 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 5 file: select.c
if ( pPrior )  location: 6023 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 5 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 5 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 5 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 5 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 5 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 5 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 5 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 6047 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6048 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy; location: 6049 cross_layer: 5 file: select.c
pHaving = p -> pHaving; location: 6050 cross_layer: 5 file: select.c
sDistinct . isTnct = ( p -> selFlags & SF_Distinct ) != 0; location: 6051 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6056 cross_layer: 5 file: select.c
if ( ( p -> selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct && sqlite3ExprListCompare ( sSort . pOrderBy , pEList , - 1 ) == 0 && p -> pWin == 0 )  location: 6075 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 6079 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 5 file: select.c
assert ( sDistinct . isTnct ); location: 6084 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6102 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 5 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 5 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 5 file: select.c
sSort . addrSortIndex = - 1; location: 6113 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_EphemTab )  location: 6118 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 5 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 5 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 5 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 5 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 5 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 5 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 5 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 5 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 5 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 5 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_NOOP; location: 6145 cross_layer: 5 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 5 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 5 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 5 file: select.c
if ( pWin )  location: 6154 cross_layer: 5 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 5 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 5 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 5 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 5 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 5 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 5 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 5 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 5 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 5 file: select.c
if ( pWin )  location: 6190 cross_layer: 5 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 5 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 5 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 5 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 5 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 5 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 5 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 5 file: select.c
p -> nSelectRow = 66; location: 6249 cross_layer: 5 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 5 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 5 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 5 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 5 file: select.c
p -> nSelectRow = 0; location: 6276 cross_layer: 5 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 5 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 5 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 5 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 5 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 5 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 5 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 5 file: select.c
if ( pHaving )  location: 6296 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 5 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 5 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 5 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 5 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 5 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 5 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 5 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 5 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 5 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 5 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 5 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 5 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6331 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 5 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 5 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 5 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 5 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 5 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 5 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 5 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 5 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 5 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 5 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 5 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 5 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 5 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 5 file: select.c
j = nGroupBy; location: 6422 cross_layer: 5 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 5 file: select.c
nCol ++; location: 6425 cross_layer: 5 file: select.c
j ++; location: 6426 cross_layer: 5 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 5 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 5 file: select.c
j = nGroupBy; location: 6431 cross_layer: 5 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 5 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 5 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 5 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 5 file: select.c
j ++; location: 6438 cross_layer: 5 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 5 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 5 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 5 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 5 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 5 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 5 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 5 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 5 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 5 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 5 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 5 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 5 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 5 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 5 file: select.c
if ( ( pTab = isSimpleCount ( p , & sAggInfo ) ) != 0 )  location: 6573 cross_layer: 5 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 5 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 5 file: select.c
int iRoot = pTab -> tnum ; location: 6592 cross_layer: 5 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 5 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 5 file: select.c
if ( ! HasRowid ( pTab ) )  location: 6606 cross_layer: 5 file: select.c
pBest = sqlite3PrimaryKeyIndex ( pTab ); location: 6606 cross_layer: 5 file: select.c
if ( pIdx -> bUnordered == 0 && pIdx -> szIdxRow < pTab -> szTabRow && pIdx -> pPartIdxWhere == 0 && ( ! pBest || pIdx -> szIdxRow < pBest -> szIdxRow ) )  location: 6608 cross_layer: 5 file: select.c
pBest = pIdx; location: 6613 cross_layer: 5 file: select.c
if ( pBest )  location: 6616 cross_layer: 5 file: select.c
iRoot = pBest -> tnum; location: 6617 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 5 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 5 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 5 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 5 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 5 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 5 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 5 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 5 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 5 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 5 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 5 file: select.c
if ( regAcc )  location: 6676 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 5 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 5 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 5 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 5 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 5 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6727 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 5 file: select.c
return rc ; location: 6731 cross_layer: 5 file: select.c
testcase ( rc != SQLITE_OK ); location: 2695 cross_layer: 4 file: select.c
sqlite3ExprListDelete ( db , p -> pOrderBy ); location: 2698 cross_layer: 4 file: select.c
pDelete = p -> pPrior; location: 2699 cross_layer: 4 file: select.c
p -> pPrior = pPrior; location: 2700 cross_layer: 4 file: select.c
p -> pOrderBy = 0; location: 2701 cross_layer: 4 file: select.c
if ( p -> op == TK_UNION )  location: 2702 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2703 cross_layer: 4 file: select.c
sqlite3ExprDelete ( db , p -> pLimit ); location: 2705 cross_layer: 4 file: select.c
p -> pLimit = pLimit; location: 2706 cross_layer: 4 file: select.c
p -> iLimit = 0; location: 2707 cross_layer: 4 file: select.c
p -> iOffset = 0; location: 2708 cross_layer: 4 file: select.c
assert ( unionTab == dest . iSDParm || dest . eDest != priorOp ); location: 2713 cross_layer: 4 file: select.c
assert ( p -> pEList ); location: 2716 cross_layer: 4 file: select.c
iBreak = sqlite3VdbeMakeLabel ( pParse ); location: 2717 cross_layer: 4 file: select.c
iCont = sqlite3VdbeMakeLabel ( pParse ); location: 2718 cross_layer: 4 file: select.c
computeLimitRegisters ( pParse , p , iBreak ); location: 2719 cross_layer: 4 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 5 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 5 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 5 file: select.c
if ( pLimit )  location: 2168 cross_layer: 5 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 5 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 5 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 5 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 5 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 5 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 5 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 5 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 5 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 5 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 5 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 5 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 5 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Rewind , unionTab , iBreak ); location: 2720 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2720 cross_layer: 4 file: select.c
iStart = sqlite3VdbeCurrentAddr ( v ); location: 2721 cross_layer: 4 file: select.c
selectInnerLoop ( pParse , p , unionTab , 0 , 0 , & dest , iCont , iBreak ); location: 2722 cross_layer: 4 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 5 file: select.c
assert ( v ); location: 887 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 5 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 5 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 5 file: select.c
pSort = 0; location: 890 cross_layer: 5 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 5 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 5 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 5 file: select.c
if ( pSort )  location: 901 cross_layer: 5 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 5 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 5 file: select.c
nPrefixReg ++; location: 903 cross_layer: 5 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 5 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 5 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 5 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 5 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 5 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 5 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 5 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 5 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 5 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 5 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 5 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 5 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 5 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 5 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 5 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 5 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 5 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 5 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 5 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 5 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 5 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 5 file: select.c
nResultCol --; location: 976 cross_layer: 5 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 5 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 5 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 5 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 5 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 5 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 5 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 5 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 5 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 5 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 5 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 5 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 5 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 5 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 5 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 5 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 5 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 5 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 5 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 5 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 5 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 5 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 5 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 5 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 5 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 5 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 5 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 5 file: select.c
switch ( eDest )  location: 1072 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 5 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 5 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 5 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 5 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 5 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 5 file: select.c
if ( pSort )  location: 1122 cross_layer: 5 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 5 file: select.c
if ( pSort )  location: 1142 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 5 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 5 file: select.c
if ( pSort )  location: 1173 cross_layer: 5 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 5 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 5 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 5 file: select.c
if ( pSort )  location: 1190 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 5 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 5 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 5 file: select.c
assert ( pSO ); location: 1215 cross_layer: 5 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 5 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 5 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 5 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 5 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 5 file: select.c
if ( addrTest )  location: 1241 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 5 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 5 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 2724 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , unionTab , iStart ); location: 2725 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2725 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 2726 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Close , unionTab , 0 ); location: 2727 cross_layer: 4 file: select.c
assert ( p -> op == TK_INTERSECT ); location: 2731 cross_layer: 4 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 4 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 4 file: select.c
assert ( p -> pOrderBy == 0 ); location: 2745 cross_layer: 4 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , tab1 , 0 ); location: 2747 cross_layer: 4 file: select.c
assert ( p -> addrOpenEphm [ 0 ] == - 1 ); location: 2748 cross_layer: 4 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2749 cross_layer: 4 file: select.c
findRightmost ( p ) -> selFlags |= SF_UsesEphemeral; location: 2750 cross_layer: 4 file: select.c
static Select *findRightmost(Select *p) location: 194 cross_layer: 5 file: select.c
while ( p -> pNext )  location: 195 cross_layer: 5 file: select.c
p = p -> pNext; location: 195 cross_layer: 5 file: select.c
return p ; location: 196 cross_layer: 5 file: select.c
assert ( p -> pEList ); location: 2751 cross_layer: 4 file: select.c
sqlite3SelectDestInit ( & intersectdest , SRT_Union , tab1 ); location: 2755 cross_layer: 4 file: select.c
void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm) location: 115 cross_layer: 5 file: select.c
pDest -> eDest = ( u8 ) eDest; location: 116 cross_layer: 5 file: select.c
pDest -> iSDParm = iParm; location: 117 cross_layer: 5 file: select.c
pDest -> zAffSdst = 0; location: 118 cross_layer: 5 file: select.c
pDest -> iSdst = 0; location: 119 cross_layer: 5 file: select.c
pDest -> nSdst = 0; location: 120 cross_layer: 5 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 4 file: select.c
int sqlite3Select(
Parse *pParse,         /* The parser context */
Select *p,             /* The SELECT statement being coded. */
SelectDest *pDest      /* What to do with the query results */
) location: 5676 cross_layer: 5 file: select.c
db = pParse -> db; location: 5695 cross_layer: 5 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 5696 cross_layer: 5 file: select.c
if ( p == 0 || db -> mallocFailed || pParse -> nErr )  location: 5697 cross_layer: 5 file: select.c
if ( sqlite3AuthCheck ( pParse , SQLITE_SELECT , 0 , 0 , 0 ) )  location: 5700 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "begin processing:\n" , pParse -> addrExplain ) ); location: 5703 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5705 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistFifo ); location: 5709 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Fifo ); location: 5710 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistQueue ); location: 5711 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Queue ); location: 5712 cross_layer: 5 file: select.c
if ( IgnorableOrderby ( pDest ) )  location: 5713 cross_layer: 5 file: select.c
assert ( pDest -> eDest == SRT_Exists || pDest -> eDest == SRT_Union || pDest -> eDest == SRT_Except || pDest -> eDest == SRT_Discard || pDest -> eDest == SRT_Queue || pDest -> eDest == SRT_DistFifo || pDest -> eDest == SRT_DistQueue || pDest -> eDest == SRT_Fifo ); location: 5714 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , p -> pOrderBy ); location: 5720 cross_layer: 5 file: select.c
p -> pOrderBy = 0; location: 5721 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 5722 cross_layer: 5 file: select.c
sqlite3SelectPrep ( pParse , p , 0 ); location: 5724 cross_layer: 5 file: select.c
if ( pParse -> nErr || db -> mallocFailed )  location: 5725 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 5728 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after name resolution:\n" ) ); location: 5731 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5732 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_Output )  location: 5736 cross_layer: 5 file: select.c
generateColumnNames ( pParse , p ); location: 5737 cross_layer: 5 file: select.c
if ( sqlite3WindowRewrite ( pParse , p ) )  location: 5741 cross_layer: 5 file: select.c
if ( p -> pWin && ( sqlite3SelectTrace & 0x108 ) != 0 )  location: 5745 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after window rewrite:\n" ) ); location: 5746 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5747 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5751 cross_layer: 5 file: select.c
isAgg = ( p -> selFlags & SF_Aggregate ) != 0; location: 5752 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5754 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5761 cross_layer: 5 file: select.c
Select * pSub = pItem -> pSelect ; location: 5762 cross_layer: 5 file: select.c
Table * pTab = pItem -> pTab ; location: 5763 cross_layer: 5 file: select.c
if ( ( pItem -> fg . jointype & JT_LEFT ) != 0 && sqlite3ExprImpliesNonNullRow ( p -> pWhere , pItem -> iCursor ) && OptimizationEnabled ( db , SQLITE_SimplifyJoin ) )  location: 5768 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "LEFT-JOIN simplifies to JOIN on term %d\n" , i ) ); location: 5772 cross_layer: 5 file: select.c
pItem -> fg . jointype &= ~ ( JT_LEFT | JT_OUTER ); location: 5774 cross_layer: 5 file: select.c
unsetJoinExpr ( p -> pWhere , pItem -> iCursor ); location: 5775 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5779 cross_layer: 5 file: select.c
if ( pTab -> nCol != pSub -> pEList -> nExpr )  location: 5783 cross_layer: 5 file: select.c
sqlite3ErrorMsg ( pParse , "expected %d columns for '%s' but got %d" , pTab -> nCol , pTab -> zName , pSub -> pEList -> nExpr ); location: 5784 cross_layer: 5 file: select.c
if ( ( pSub -> selFlags & SF_Aggregate ) != 0 )  location: 5796 cross_layer: 5 file: select.c
assert ( pSub -> pGroupBy == 0 ); location: 5797 cross_layer: 5 file: select.c
if ( pSub -> pOrderBy != 0 && i == 0 && ( p -> selFlags & SF_ComplexResult ) != 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5817 cross_layer: 5 file: select.c
if ( flattenSubquery ( pParse , p , i , isAgg ) )  location: 5826 cross_layer: 5 file: select.c
if ( pParse -> nErr )  location: 5827 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5831 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5832 cross_layer: 5 file: select.c
if ( ! IgnorableOrderby ( pDest ) )  location: 5833 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5834 cross_layer: 5 file: select.c
if ( p -> pPrior )  location: 5843 cross_layer: 5 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end compound-select processing\n" ) ); location: 5846 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 5847 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5848 cross_layer: 5 file: select.c
if ( p -> pNext == 0 )  location: 5851 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 5851 cross_layer: 5 file: select.c
return rc ; location: 5852 cross_layer: 5 file: select.c
if ( pTabList -> nSrc > 1 && OptimizationEnabled ( db , SQLITE_PropagateConst ) && propagateConstants ( pParse , p ) )  location: 5861 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After constant propagation:\n" ) ); location: 5867 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5868 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Constant propagation not helpful\n" ) ); location: 5872 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_QueryFlattener | SQLITE_CountOfView ) && countOfViewOptimization ( pParse , p ) )  location: 5876 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5879 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 5880 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5881 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5890 cross_layer: 5 file: select.c
if ( pItem -> colUsed == 0 && pItem -> zName != 0 )  location: 5913 cross_layer: 5 file: select.c
sqlite3AuthCheck ( pParse , SQLITE_READ , pItem -> zName , "" , pItem -> zDatabase ); location: 5914 cross_layer: 5 file: select.c
pSub = pItem -> pSelect; location: 5920 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5921 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub != 0 ); location: 5935 cross_layer: 5 file: select.c
pParse -> nHeight += sqlite3SelectExprHeight ( p ); location: 5944 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_PushDown ) && pushDownWhereTerms ( pParse , pSub , p -> pWhere , pItem -> iCursor , ( pItem -> fg . jointype & JT_OUTER ) != 0 ) )  location: 5949 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After WHERE-clause push-down into subquery %d:\n" , pSub -> selId ) ); location: 5955 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5957 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Push-down not possible\n" ) ); location: 5961 cross_layer: 5 file: select.c
zSavedAuthContext = pParse -> zAuthContext; location: 5964 cross_layer: 5 file: select.c
pParse -> zAuthContext = pItem -> zName; location: 5965 cross_layer: 5 file: select.c
if ( i == 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5976 cross_layer: 5 file: select.c
int addrTop = sqlite3VdbeCurrentAddr ( v ) + 1 ; location: 5983 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 5985 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_InitCoroutine , pItem -> regReturn , 0 , addrTop ); location: 5986 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , pItem -> pTab -> zName ) ); location: 5987 cross_layer: 5 file: select.c
pItem -> addrFillSub = addrTop; location: 5988 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_Coroutine , pItem -> regReturn ); location: 5989 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "CO-ROUTINE %u" , pSub -> selId ) ); location: 5990 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 5 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 5 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 5 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 5 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 5 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 5 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 5 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 5 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 5 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 5 file: select.c
if ( pPrior )  location: 6023 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 5 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 5 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 5 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 5 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 5 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 5 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 5 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 6047 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6048 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy; location: 6049 cross_layer: 5 file: select.c
pHaving = p -> pHaving; location: 6050 cross_layer: 5 file: select.c
sDistinct . isTnct = ( p -> selFlags & SF_Distinct ) != 0; location: 6051 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6056 cross_layer: 5 file: select.c
if ( ( p -> selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct && sqlite3ExprListCompare ( sSort . pOrderBy , pEList , - 1 ) == 0 && p -> pWin == 0 )  location: 6075 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 6079 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 5 file: select.c
assert ( sDistinct . isTnct ); location: 6084 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6102 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 5 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 5 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 5 file: select.c
sSort . addrSortIndex = - 1; location: 6113 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_EphemTab )  location: 6118 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 5 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 5 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 5 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 5 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 5 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 5 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 5 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 5 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 5 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 5 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_NOOP; location: 6145 cross_layer: 5 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 5 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 5 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 5 file: select.c
if ( pWin )  location: 6154 cross_layer: 5 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 5 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 5 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 5 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 5 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 5 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 5 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 5 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 5 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 5 file: select.c
if ( pWin )  location: 6190 cross_layer: 5 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 5 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 5 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 5 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 5 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 5 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 5 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 5 file: select.c
p -> nSelectRow = 66; location: 6249 cross_layer: 5 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 5 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 5 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 5 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 5 file: select.c
p -> nSelectRow = 0; location: 6276 cross_layer: 5 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 5 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 5 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 5 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 5 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 5 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 5 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 5 file: select.c
if ( pHaving )  location: 6296 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 5 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 5 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 5 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 5 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 5 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 5 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 5 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 5 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 5 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 5 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 5 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 5 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6331 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 5 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 5 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 5 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 5 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 5 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 5 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 5 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 5 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 5 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 5 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 5 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 5 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 5 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 5 file: select.c
j = nGroupBy; location: 6422 cross_layer: 5 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 5 file: select.c
nCol ++; location: 6425 cross_layer: 5 file: select.c
j ++; location: 6426 cross_layer: 5 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 5 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 5 file: select.c
j = nGroupBy; location: 6431 cross_layer: 5 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 5 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 5 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 5 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 5 file: select.c
j ++; location: 6438 cross_layer: 5 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 5 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 5 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 5 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 5 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 5 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 5 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 5 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 5 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 5 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 5 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 5 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 5 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 5 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 5 file: select.c
if ( ( pTab = isSimpleCount ( p , & sAggInfo ) ) != 0 )  location: 6573 cross_layer: 5 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 5 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 5 file: select.c
int iRoot = pTab -> tnum ; location: 6592 cross_layer: 5 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 5 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 5 file: select.c
if ( ! HasRowid ( pTab ) )  location: 6606 cross_layer: 5 file: select.c
pBest = sqlite3PrimaryKeyIndex ( pTab ); location: 6606 cross_layer: 5 file: select.c
if ( pIdx -> bUnordered == 0 && pIdx -> szIdxRow < pTab -> szTabRow && pIdx -> pPartIdxWhere == 0 && ( ! pBest || pIdx -> szIdxRow < pBest -> szIdxRow ) )  location: 6608 cross_layer: 5 file: select.c
pBest = pIdx; location: 6613 cross_layer: 5 file: select.c
if ( pBest )  location: 6616 cross_layer: 5 file: select.c
iRoot = pBest -> tnum; location: 6617 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 5 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 5 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 5 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 5 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 5 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 5 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 5 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 5 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 5 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 5 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 5 file: select.c
if ( regAcc )  location: 6676 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 5 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 5 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 5 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 5 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 5 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6727 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 5 file: select.c
return rc ; location: 6731 cross_layer: 5 file: select.c
if ( rc )  location: 2757 cross_layer: 4 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , tab2 , 0 ); location: 2763 cross_layer: 4 file: select.c
assert ( p -> addrOpenEphm [ 1 ] == - 1 ); location: 2764 cross_layer: 4 file: select.c
p -> addrOpenEphm [ 1 ] = addr; location: 2765 cross_layer: 4 file: select.c
p -> pPrior = 0; location: 2766 cross_layer: 4 file: select.c
pLimit = p -> pLimit; location: 2767 cross_layer: 4 file: select.c
p -> pLimit = 0; location: 2768 cross_layer: 4 file: select.c
intersectdest . iSDParm = tab2; location: 2769 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "%s USING TEMP B-TREE" , selectOpName ( p -> op ) ) ); location: 2770 cross_layer: 4 file: select.c
static const char *selectOpName(int id) location: 1366 cross_layer: 5 file: select.c
switch ( id )  location: 1368 cross_layer: 5 file: select.c
rc = sqlite3Select ( pParse , p , & intersectdest ); location: 2772 cross_layer: 4 file: select.c
int sqlite3Select(
Parse *pParse,         /* The parser context */
Select *p,             /* The SELECT statement being coded. */
SelectDest *pDest      /* What to do with the query results */
) location: 5676 cross_layer: 5 file: select.c
db = pParse -> db; location: 5695 cross_layer: 5 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 5696 cross_layer: 5 file: select.c
if ( p == 0 || db -> mallocFailed || pParse -> nErr )  location: 5697 cross_layer: 5 file: select.c
if ( sqlite3AuthCheck ( pParse , SQLITE_SELECT , 0 , 0 , 0 ) )  location: 5700 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "begin processing:\n" , pParse -> addrExplain ) ); location: 5703 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5705 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistFifo ); location: 5709 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Fifo ); location: 5710 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistQueue ); location: 5711 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Queue ); location: 5712 cross_layer: 5 file: select.c
if ( IgnorableOrderby ( pDest ) )  location: 5713 cross_layer: 5 file: select.c
assert ( pDest -> eDest == SRT_Exists || pDest -> eDest == SRT_Union || pDest -> eDest == SRT_Except || pDest -> eDest == SRT_Discard || pDest -> eDest == SRT_Queue || pDest -> eDest == SRT_DistFifo || pDest -> eDest == SRT_DistQueue || pDest -> eDest == SRT_Fifo ); location: 5714 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , p -> pOrderBy ); location: 5720 cross_layer: 5 file: select.c
p -> pOrderBy = 0; location: 5721 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 5722 cross_layer: 5 file: select.c
sqlite3SelectPrep ( pParse , p , 0 ); location: 5724 cross_layer: 5 file: select.c
if ( pParse -> nErr || db -> mallocFailed )  location: 5725 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 5728 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after name resolution:\n" ) ); location: 5731 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5732 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_Output )  location: 5736 cross_layer: 5 file: select.c
generateColumnNames ( pParse , p ); location: 5737 cross_layer: 5 file: select.c
if ( sqlite3WindowRewrite ( pParse , p ) )  location: 5741 cross_layer: 5 file: select.c
if ( p -> pWin && ( sqlite3SelectTrace & 0x108 ) != 0 )  location: 5745 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after window rewrite:\n" ) ); location: 5746 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5747 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5751 cross_layer: 5 file: select.c
isAgg = ( p -> selFlags & SF_Aggregate ) != 0; location: 5752 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5754 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5761 cross_layer: 5 file: select.c
Select * pSub = pItem -> pSelect ; location: 5762 cross_layer: 5 file: select.c
Table * pTab = pItem -> pTab ; location: 5763 cross_layer: 5 file: select.c
if ( ( pItem -> fg . jointype & JT_LEFT ) != 0 && sqlite3ExprImpliesNonNullRow ( p -> pWhere , pItem -> iCursor ) && OptimizationEnabled ( db , SQLITE_SimplifyJoin ) )  location: 5768 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "LEFT-JOIN simplifies to JOIN on term %d\n" , i ) ); location: 5772 cross_layer: 5 file: select.c
pItem -> fg . jointype &= ~ ( JT_LEFT | JT_OUTER ); location: 5774 cross_layer: 5 file: select.c
unsetJoinExpr ( p -> pWhere , pItem -> iCursor ); location: 5775 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5779 cross_layer: 5 file: select.c
if ( pTab -> nCol != pSub -> pEList -> nExpr )  location: 5783 cross_layer: 5 file: select.c
sqlite3ErrorMsg ( pParse , "expected %d columns for '%s' but got %d" , pTab -> nCol , pTab -> zName , pSub -> pEList -> nExpr ); location: 5784 cross_layer: 5 file: select.c
if ( ( pSub -> selFlags & SF_Aggregate ) != 0 )  location: 5796 cross_layer: 5 file: select.c
assert ( pSub -> pGroupBy == 0 ); location: 5797 cross_layer: 5 file: select.c
if ( pSub -> pOrderBy != 0 && i == 0 && ( p -> selFlags & SF_ComplexResult ) != 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5817 cross_layer: 5 file: select.c
if ( flattenSubquery ( pParse , p , i , isAgg ) )  location: 5826 cross_layer: 5 file: select.c
if ( pParse -> nErr )  location: 5827 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5831 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5832 cross_layer: 5 file: select.c
if ( ! IgnorableOrderby ( pDest ) )  location: 5833 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5834 cross_layer: 5 file: select.c
if ( p -> pPrior )  location: 5843 cross_layer: 5 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end compound-select processing\n" ) ); location: 5846 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 5847 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5848 cross_layer: 5 file: select.c
if ( p -> pNext == 0 )  location: 5851 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 5851 cross_layer: 5 file: select.c
return rc ; location: 5852 cross_layer: 5 file: select.c
if ( pTabList -> nSrc > 1 && OptimizationEnabled ( db , SQLITE_PropagateConst ) && propagateConstants ( pParse , p ) )  location: 5861 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After constant propagation:\n" ) ); location: 5867 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5868 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Constant propagation not helpful\n" ) ); location: 5872 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_QueryFlattener | SQLITE_CountOfView ) && countOfViewOptimization ( pParse , p ) )  location: 5876 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5879 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 5880 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5881 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5890 cross_layer: 5 file: select.c
if ( pItem -> colUsed == 0 && pItem -> zName != 0 )  location: 5913 cross_layer: 5 file: select.c
sqlite3AuthCheck ( pParse , SQLITE_READ , pItem -> zName , "" , pItem -> zDatabase ); location: 5914 cross_layer: 5 file: select.c
pSub = pItem -> pSelect; location: 5920 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5921 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub != 0 ); location: 5935 cross_layer: 5 file: select.c
pParse -> nHeight += sqlite3SelectExprHeight ( p ); location: 5944 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_PushDown ) && pushDownWhereTerms ( pParse , pSub , p -> pWhere , pItem -> iCursor , ( pItem -> fg . jointype & JT_OUTER ) != 0 ) )  location: 5949 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After WHERE-clause push-down into subquery %d:\n" , pSub -> selId ) ); location: 5955 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5957 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Push-down not possible\n" ) ); location: 5961 cross_layer: 5 file: select.c
zSavedAuthContext = pParse -> zAuthContext; location: 5964 cross_layer: 5 file: select.c
pParse -> zAuthContext = pItem -> zName; location: 5965 cross_layer: 5 file: select.c
if ( i == 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5976 cross_layer: 5 file: select.c
int addrTop = sqlite3VdbeCurrentAddr ( v ) + 1 ; location: 5983 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 5985 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_InitCoroutine , pItem -> regReturn , 0 , addrTop ); location: 5986 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , pItem -> pTab -> zName ) ); location: 5987 cross_layer: 5 file: select.c
pItem -> addrFillSub = addrTop; location: 5988 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_Coroutine , pItem -> regReturn ); location: 5989 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "CO-ROUTINE %u" , pSub -> selId ) ); location: 5990 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 5 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 5 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 5 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 5 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 5 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 5 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 5 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 5 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 5 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 5 file: select.c
if ( pPrior )  location: 6023 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 5 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 5 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 5 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 5 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 5 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 5 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 5 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 6047 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6048 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy; location: 6049 cross_layer: 5 file: select.c
pHaving = p -> pHaving; location: 6050 cross_layer: 5 file: select.c
sDistinct . isTnct = ( p -> selFlags & SF_Distinct ) != 0; location: 6051 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6056 cross_layer: 5 file: select.c
if ( ( p -> selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct && sqlite3ExprListCompare ( sSort . pOrderBy , pEList , - 1 ) == 0 && p -> pWin == 0 )  location: 6075 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 6079 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 5 file: select.c
assert ( sDistinct . isTnct ); location: 6084 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6102 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 5 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 5 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 5 file: select.c
sSort . addrSortIndex = - 1; location: 6113 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_EphemTab )  location: 6118 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 5 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 5 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 5 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 5 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 5 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 5 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 5 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 5 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 5 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 5 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_NOOP; location: 6145 cross_layer: 5 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 5 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 5 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 5 file: select.c
if ( pWin )  location: 6154 cross_layer: 5 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 5 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 5 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 5 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 5 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 5 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 5 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 5 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 5 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 5 file: select.c
if ( pWin )  location: 6190 cross_layer: 5 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 5 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 5 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 5 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 5 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 5 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 5 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 5 file: select.c
p -> nSelectRow = 66; location: 6249 cross_layer: 5 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 5 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 5 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 5 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 5 file: select.c
p -> nSelectRow = 0; location: 6276 cross_layer: 5 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 5 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 5 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 5 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 5 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 5 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 5 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 5 file: select.c
if ( pHaving )  location: 6296 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 5 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 5 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 5 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 5 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 5 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 5 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 5 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 5 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 5 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 5 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 5 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 5 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6331 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 5 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 5 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 5 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 5 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 5 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 5 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 5 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 5 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 5 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 5 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 5 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 5 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 5 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 5 file: select.c
j = nGroupBy; location: 6422 cross_layer: 5 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 5 file: select.c
nCol ++; location: 6425 cross_layer: 5 file: select.c
j ++; location: 6426 cross_layer: 5 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 5 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 5 file: select.c
j = nGroupBy; location: 6431 cross_layer: 5 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 5 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 5 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 5 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 5 file: select.c
j ++; location: 6438 cross_layer: 5 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 5 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 5 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 5 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 5 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 5 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 5 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 5 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 5 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 5 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 5 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 5 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 5 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 5 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 5 file: select.c
if ( ( pTab = isSimpleCount ( p , & sAggInfo ) ) != 0 )  location: 6573 cross_layer: 5 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 5 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 5 file: select.c
int iRoot = pTab -> tnum ; location: 6592 cross_layer: 5 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 5 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 5 file: select.c
if ( ! HasRowid ( pTab ) )  location: 6606 cross_layer: 5 file: select.c
pBest = sqlite3PrimaryKeyIndex ( pTab ); location: 6606 cross_layer: 5 file: select.c
if ( pIdx -> bUnordered == 0 && pIdx -> szIdxRow < pTab -> szTabRow && pIdx -> pPartIdxWhere == 0 && ( ! pBest || pIdx -> szIdxRow < pBest -> szIdxRow ) )  location: 6608 cross_layer: 5 file: select.c
pBest = pIdx; location: 6613 cross_layer: 5 file: select.c
if ( pBest )  location: 6616 cross_layer: 5 file: select.c
iRoot = pBest -> tnum; location: 6617 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 5 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 5 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 5 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 5 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 5 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 5 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 5 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 5 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 5 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 5 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 5 file: select.c
if ( regAcc )  location: 6676 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 5 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 5 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 5 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 5 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 5 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6727 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 5 file: select.c
return rc ; location: 6731 cross_layer: 5 file: select.c
testcase ( rc != SQLITE_OK ); location: 2773 cross_layer: 4 file: select.c
pDelete = p -> pPrior; location: 2774 cross_layer: 4 file: select.c
p -> pPrior = pPrior; location: 2775 cross_layer: 4 file: select.c
if ( p -> nSelectRow > pPrior -> nSelectRow )  location: 2776 cross_layer: 4 file: select.c
p -> nSelectRow = pPrior -> nSelectRow; location: 2777 cross_layer: 4 file: select.c
sqlite3ExprDelete ( db , p -> pLimit ); location: 2779 cross_layer: 4 file: select.c
p -> pLimit = pLimit; location: 2780 cross_layer: 4 file: select.c
assert ( p -> pEList ); location: 2785 cross_layer: 4 file: select.c
iBreak = sqlite3VdbeMakeLabel ( pParse ); location: 2786 cross_layer: 4 file: select.c
iCont = sqlite3VdbeMakeLabel ( pParse ); location: 2787 cross_layer: 4 file: select.c
computeLimitRegisters ( pParse , p , iBreak ); location: 2788 cross_layer: 4 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 5 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 5 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 5 file: select.c
if ( pLimit )  location: 2168 cross_layer: 5 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 5 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 5 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 5 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 5 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 5 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 5 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 5 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 5 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 5 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 5 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 5 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 5 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Rewind , tab1 , iBreak ); location: 2789 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2789 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 2790 cross_layer: 4 file: select.c
iStart = sqlite3VdbeAddOp2 ( v , OP_RowData , tab1 , r1 ); location: 2791 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_NotFound , tab2 , iCont , r1 , 0 ); location: 2792 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2793 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2794 cross_layer: 4 file: select.c
selectInnerLoop ( pParse , p , tab1 , 0 , 0 , & dest , iCont , iBreak ); location: 2795 cross_layer: 4 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 5 file: select.c
assert ( v ); location: 887 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 5 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 5 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 5 file: select.c
pSort = 0; location: 890 cross_layer: 5 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 5 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 5 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 5 file: select.c
if ( pSort )  location: 901 cross_layer: 5 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 5 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 5 file: select.c
nPrefixReg ++; location: 903 cross_layer: 5 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 5 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 5 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 5 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 5 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 5 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 5 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 5 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 5 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 5 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 5 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 5 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 5 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 5 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 5 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 5 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 5 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 5 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 5 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 5 file: select.c
nResultCol --; location: 976 cross_layer: 5 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 5 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 5 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 5 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 5 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 5 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 5 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 5 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 5 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 5 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 5 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 5 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 5 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 5 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 5 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 5 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 5 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 5 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 5 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 5 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 5 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 5 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 5 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 5 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 5 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 5 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 5 file: select.c
switch ( eDest )  location: 1072 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 5 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 5 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 5 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 5 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 5 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 5 file: select.c
if ( pSort )  location: 1122 cross_layer: 5 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 5 file: select.c
if ( pSort )  location: 1142 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 5 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 5 file: select.c
if ( pSort )  location: 1173 cross_layer: 5 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 5 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 5 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 5 file: select.c
if ( pSort )  location: 1190 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 5 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 5 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 5 file: select.c
assert ( pSO ); location: 1215 cross_layer: 5 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 5 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 5 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 5 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 5 file: select.c
if ( addrTest )  location: 1241 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 5 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 5 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 2797 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , tab1 , iStart ); location: 2798 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2798 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 2799 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Close , tab2 , 0 ); location: 2800 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Close , tab1 , 0 ); location: 2801 cross_layer: 4 file: select.c
if ( p -> pNext == 0 )  location: 2807 cross_layer: 4 file: select.c
ExplainQueryPlanPop ( pParse ); location: 2808 cross_layer: 4 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 4 file: select.c
if ( p -> selFlags & SF_UsesEphemeral )  location: 2823 cross_layer: 4 file: select.c
assert ( p -> pNext == 0 ); location: 2830 cross_layer: 4 file: select.c
nCol = p -> pEList -> nExpr; location: 2831 cross_layer: 4 file: select.c
pKeyInfo = sqlite3KeyInfoAlloc ( db , nCol , 1 ); location: 2832 cross_layer: 4 file: select.c
KeyInfo *sqlite3KeyInfoAlloc(sqlite3 *db, int N, int X) location: 1276 cross_layer: 5 file: select.c
int nExtra = ( N + X ) * ( sizeof ( CollSeq * ) + 1 ) - sizeof ( CollSeq * ) ; location: 1277 cross_layer: 5 file: select.c
KeyInfo * p = sqlite3DbMallocRawNN ( db , sizeof ( KeyInfo ) + nExtra ) ; location: 1278 cross_layer: 5 file: select.c
if ( p )  location: 1279 cross_layer: 5 file: select.c
p -> aSortFlags = ( u8 * ) & p -> aColl [ N + X ]; location: 1280 cross_layer: 5 file: select.c
p -> nKeyField = ( u16 ) N; location: 1281 cross_layer: 5 file: select.c
p -> nAllField = ( u16 ) ( N + X ); location: 1282 cross_layer: 5 file: select.c
p -> enc = ENC ( db ); location: 1283 cross_layer: 5 file: select.c
p -> db = db; location: 1284 cross_layer: 5 file: select.c
p -> nRef = 1; location: 1285 cross_layer: 5 file: select.c
memset ( & p [ 1 ] , 0 , nExtra ); location: 1286 cross_layer: 5 file: select.c
sqlite3OomFault ( db ); location: 1288 cross_layer: 5 file: select.c
return p ; location: 1290 cross_layer: 5 file: select.c
if ( ! pKeyInfo )  location: 2833 cross_layer: 4 file: select.c
for(i=0, apColl=pKeyInfo->aColl; i<nCol; i++, apColl++) location: 2837 cross_layer: 4 file: select.c
* apColl = multiSelectCollSeq ( pParse , p , i ); location: 2838 cross_layer: 4 file: select.c
static CollSeq *multiSelectCollSeq(Parse *pParse, Select *p, int iCol) location: 2210 cross_layer: 5 file: select.c
if ( p -> pPrior )  location: 2212 cross_layer: 5 file: select.c
pRet = multiSelectCollSeq ( pParse , p -> pPrior , iCol ); location: 2213 cross_layer: 5 file: select.c
assert ( iCol >= 0 ); location: 2217 cross_layer: 5 file: select.c
if ( pRet == 0 && ALWAYS ( iCol < p -> pEList -> nExpr ) )  location: 2221 cross_layer: 5 file: select.c
pRet = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ iCol ] . pExpr ); location: 2222 cross_layer: 5 file: select.c
return pRet ; location: 2224 cross_layer: 5 file: select.c
if ( 0 == * apColl )  location: 2839 cross_layer: 4 file: select.c
* apColl = db -> pDfltColl; location: 2840 cross_layer: 4 file: select.c
for(pLoop=p; pLoop; pLoop=pLoop->pPrior) location: 2844 cross_layer: 4 file: select.c
for(i=0; i<2; i++) location: 2845 cross_layer: 4 file: select.c
int addr = pLoop -> addrOpenEphm [ i ] ; location: 2846 cross_layer: 4 file: select.c
if ( addr < 0 )  location: 2847 cross_layer: 4 file: select.c
assert ( pLoop -> addrOpenEphm [ 1 ] < 0 ); location: 2850 cross_layer: 4 file: select.c
sqlite3VdbeChangeP2 ( v , addr , nCol ); location: 2853 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , addr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 2854 cross_layer: 4 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 5 file: select.c
if ( p )  location: 1308 cross_layer: 5 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 5 file: select.c
p -> nRef ++; location: 1310 cross_layer: 5 file: select.c
return p ; location: 1312 cross_layer: 5 file: select.c
pLoop -> addrOpenEphm [ i ] = - 1; location: 2856 cross_layer: 4 file: select.c
sqlite3KeyInfoUnref ( pKeyInfo ); location: 2859 cross_layer: 4 file: select.c
void sqlite3KeyInfoUnref(KeyInfo *p) location: 1296 cross_layer: 5 file: select.c
if ( p )  location: 1297 cross_layer: 5 file: select.c
assert ( p -> nRef > 0 ); location: 1298 cross_layer: 5 file: select.c
p -> nRef --; location: 1299 cross_layer: 5 file: select.c
if ( p -> nRef == 0 )  location: 1300 cross_layer: 5 file: select.c
sqlite3DbFreeNN ( p -> db , p ); location: 1300 cross_layer: 5 file: select.c
sqlite3SelectDelete ( db , pDelete ); location: 2865 cross_layer: 4 file: select.c
void sqlite3SelectDelete(sqlite3 *db, Select *p) location: 187 cross_layer: 5 file: select.c
if ( OK_IF_ALWAYS_TRUE ( p ) )  location: 188 cross_layer: 5 file: select.c
clearSelect ( db , p , 1 ); location: 188 cross_layer: 5 file: select.c
return rc ; location: 2866 cross_layer: 4 file: select.c
------------------------------
3 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 3 file: select.c
if ( rc )  location: 2609 cross_layer: 3 file: select.c
return rc ; location: 2866 cross_layer: 3 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 4 file: select.c
return rc ; location: 5852 cross_layer: 4 file: select.c
------------------------------
4 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , p , & destB ); location: 3296 cross_layer: 3 file: select.c
p -> iLimit = savedLimit; location: 3297 cross_layer: 3 file: select.c
p -> iOffset = savedOffset; location: 3298 cross_layer: 3 file: select.c
sqlite3VdbeEndCoroutine ( v , regAddrB ); location: 3299 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "Output routine for A" ) ); location: 3304 cross_layer: 3 file: select.c
addrOutA = generateOutputSubroutine ( pParse , p , & destA , pDest , regOutA , regPrev , pKeyDup , labelEnd ); location: 3305 cross_layer: 3 file: select.c
static int generateOutputSubroutine(
Parse *pParse,          /* Parsing context */
Select *p,              /* The SELECT statement */
SelectDest *pIn,        /* Coroutine supplying data */
SelectDest *pDest,      /* Where to send the data */
int regReturn,          /* The return address register */
int regPrev,            /* Previous result register.  No uniqueness if 0 */
KeyInfo *pKeyInfo,      /* For comparing with previous entry */
int iBreak              /* Jump here if we hit the LIMIT */
) location: 2912 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 2913 cross_layer: 4 file: select.c
addr = sqlite3VdbeCurrentAddr ( v ); location: 2917 cross_layer: 4 file: select.c
iContinue = sqlite3VdbeMakeLabel ( pParse ); location: 2918 cross_layer: 4 file: select.c
if ( regPrev )  location: 2922 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeAddOp1 ( v , OP_IfNot , regPrev ); location: 2924 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2924 cross_layer: 4 file: select.c
addr2 = sqlite3VdbeAddOp4 ( v , OP_Compare , pIn -> iSdst , regPrev + 1 , pIn -> nSdst , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 2925 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr2 + 2 , iContinue , addr2 + 2 ); location: 2927 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2927 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 2928 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , pIn -> iSdst , regPrev + 1 , pIn -> nSdst - 1 ); location: 2929 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regPrev ); location: 2930 cross_layer: 4 file: select.c
if ( pParse -> db -> mallocFailed )  location: 2932 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 2936 cross_layer: 4 file: select.c
assert ( pDest -> eDest != SRT_Exists ); location: 2938 cross_layer: 4 file: select.c
assert ( pDest -> eDest != SRT_Table ); location: 2939 cross_layer: 4 file: select.c
switch ( pDest -> eDest )  location: 2940 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 2944 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 2945 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 ); location: 2946 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , pDest -> iSDParm , r2 ); location: 2947 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , pDest -> iSDParm , r1 , r2 ); location: 2948 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 2949 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 2950 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2951 cross_layer: 4 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2960 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 2961 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 , pDest -> zAffSdst , pIn -> nSdst ); location: 2962 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , pDest -> iSDParm , r1 , pIn -> iSdst , pIn -> nSdst ); location: 2964 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2966 cross_layer: 4 file: select.c
if ( pParse -> nErr == 0 )  location: 2976 cross_layer: 4 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2977 cross_layer: 4 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSDParm , pIn -> nSdst ); location: 2978 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 2989 cross_layer: 4 file: select.c
pDest -> iSdst = sqlite3GetTempRange ( pParse , pIn -> nSdst ); location: 2990 cross_layer: 4 file: select.c
pDest -> nSdst = pIn -> nSdst; location: 2991 cross_layer: 4 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSdst , pIn -> nSdst ); location: 2993 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 2994 cross_layer: 4 file: select.c
assert ( pDest -> eDest == SRT_Output ); location: 3007 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pIn -> iSdst , pIn -> nSdst ); location: 3008 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 3015 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 3016 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3016 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iContinue ); location: 3021 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReturn ); location: 3022 cross_layer: 4 file: select.c
return addr ; location: 3024 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "Output routine for B" ) ); location: 3313 cross_layer: 3 file: select.c
addrOutB = generateOutputSubroutine ( pParse , p , & destB , pDest , regOutB , regPrev , pKeyDup , labelEnd ); location: 3314 cross_layer: 3 file: select.c
static int generateOutputSubroutine(
Parse *pParse,          /* Parsing context */
Select *p,              /* The SELECT statement */
SelectDest *pIn,        /* Coroutine supplying data */
SelectDest *pDest,      /* Where to send the data */
int regReturn,          /* The return address register */
int regPrev,            /* Previous result register.  No uniqueness if 0 */
KeyInfo *pKeyInfo,      /* For comparing with previous entry */
int iBreak              /* Jump here if we hit the LIMIT */
) location: 2912 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 2913 cross_layer: 4 file: select.c
addr = sqlite3VdbeCurrentAddr ( v ); location: 2917 cross_layer: 4 file: select.c
iContinue = sqlite3VdbeMakeLabel ( pParse ); location: 2918 cross_layer: 4 file: select.c
if ( regPrev )  location: 2922 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeAddOp1 ( v , OP_IfNot , regPrev ); location: 2924 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2924 cross_layer: 4 file: select.c
addr2 = sqlite3VdbeAddOp4 ( v , OP_Compare , pIn -> iSdst , regPrev + 1 , pIn -> nSdst , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 2925 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr2 + 2 , iContinue , addr2 + 2 ); location: 2927 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2927 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 2928 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , pIn -> iSdst , regPrev + 1 , pIn -> nSdst - 1 ); location: 2929 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regPrev ); location: 2930 cross_layer: 4 file: select.c
if ( pParse -> db -> mallocFailed )  location: 2932 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 2936 cross_layer: 4 file: select.c
assert ( pDest -> eDest != SRT_Exists ); location: 2938 cross_layer: 4 file: select.c
assert ( pDest -> eDest != SRT_Table ); location: 2939 cross_layer: 4 file: select.c
switch ( pDest -> eDest )  location: 2940 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 2944 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 2945 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 ); location: 2946 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , pDest -> iSDParm , r2 ); location: 2947 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , pDest -> iSDParm , r1 , r2 ); location: 2948 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 2949 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 2950 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2951 cross_layer: 4 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2960 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 2961 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 , pDest -> zAffSdst , pIn -> nSdst ); location: 2962 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , pDest -> iSDParm , r1 , pIn -> iSdst , pIn -> nSdst ); location: 2964 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2966 cross_layer: 4 file: select.c
if ( pParse -> nErr == 0 )  location: 2976 cross_layer: 4 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2977 cross_layer: 4 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSDParm , pIn -> nSdst ); location: 2978 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 2989 cross_layer: 4 file: select.c
pDest -> iSdst = sqlite3GetTempRange ( pParse , pIn -> nSdst ); location: 2990 cross_layer: 4 file: select.c
pDest -> nSdst = pIn -> nSdst; location: 2991 cross_layer: 4 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSdst , pIn -> nSdst ); location: 2993 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 2994 cross_layer: 4 file: select.c
assert ( pDest -> eDest == SRT_Output ); location: 3007 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pIn -> iSdst , pIn -> nSdst ); location: 3008 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 3015 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 3016 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3016 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iContinue ); location: 3021 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReturn ); location: 3022 cross_layer: 4 file: select.c
return addr ; location: 3024 cross_layer: 4 file: select.c
sqlite3KeyInfoUnref ( pKeyDup ); location: 3318 cross_layer: 3 file: select.c
void sqlite3KeyInfoUnref(KeyInfo *p) location: 1296 cross_layer: 4 file: select.c
if ( p )  location: 1297 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1298 cross_layer: 4 file: select.c
p -> nRef --; location: 1299 cross_layer: 4 file: select.c
if ( p -> nRef == 0 )  location: 1300 cross_layer: 4 file: select.c
sqlite3DbFreeNN ( p -> db , p ); location: 1300 cross_layer: 4 file: select.c
addrEofA_noB = addrEofA = labelEnd; location: 3324 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "eof-A subroutine" ) ); location: 3326 cross_layer: 3 file: select.c
addrEofA = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutB , addrOutB ); location: 3327 cross_layer: 3 file: select.c
addrEofA_noB = sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , labelEnd ); location: 3328 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 3329 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEofA ); location: 3330 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 3331 cross_layer: 3 file: select.c
addrEofB = addrEofA; location: 3338 cross_layer: 3 file: select.c
if ( p -> nSelectRow > pPrior -> nSelectRow )  location: 3339 cross_layer: 3 file: select.c
p -> nSelectRow = pPrior -> nSelectRow; location: 3339 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "eof-B subroutine" ) ); location: 3341 cross_layer: 3 file: select.c
addrEofB = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutA , addrOutA ); location: 3342 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , labelEnd ); location: 3343 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 3343 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEofB ); location: 3344 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "A-lt-B subroutine" ) ); location: 3349 cross_layer: 3 file: select.c
addrAltB = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutA , addrOutA ); location: 3350 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA ); location: 3351 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 3351 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3352 cross_layer: 3 file: select.c
addrAeqB = addrAltB; location: 3357 cross_layer: 3 file: select.c
addrAeqB = addrAltB; location: 3359 cross_layer: 3 file: select.c
addrAltB ++; location: 3360 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "A-eq-B subroutine" ) ); location: 3362 cross_layer: 3 file: select.c
addrAeqB = sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA ); location: 3363 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 3364 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3365 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "A-gt-B subroutine" ) ); location: 3370 cross_layer: 3 file: select.c
addrAgtB = sqlite3VdbeCurrentAddr ( v ); location: 3371 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutB , addrOutB ); location: 3373 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , addrEofB ); location: 3375 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 3375 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3376 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 3380 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA_noB ); location: 3381 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 3381 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , addrEofB ); location: 3382 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 3382 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , labelCmpr ); location: 3386 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Permutation , 0 , 0 , 0 , ( char * ) aPermute , P4_INTARRAY ); location: 3387 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , destA . iSdst , destB . iSdst , nOrderBy , ( char * ) pKeyMerge , P4_KEYINFO ); location: 3388 cross_layer: 3 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_PERMUTE ); location: 3390 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addrAltB , addrAeqB , addrAgtB ); location: 3391 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 3391 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , labelEnd ); location: 3395 cross_layer: 3 file: select.c
if ( p -> pPrior )  location: 3399 cross_layer: 3 file: select.c
sqlite3SelectDelete ( db , p -> pPrior ); location: 3400 cross_layer: 3 file: select.c
void sqlite3SelectDelete(sqlite3 *db, Select *p) location: 187 cross_layer: 4 file: select.c
if ( OK_IF_ALWAYS_TRUE ( p ) )  location: 188 cross_layer: 4 file: select.c
clearSelect ( db , p , 1 ); location: 188 cross_layer: 4 file: select.c
p -> pPrior = pPrior; location: 3402 cross_layer: 3 file: select.c
pPrior -> pNext = p; location: 3403 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 3407 cross_layer: 3 file: select.c
return pParse -> nErr != 0 ; location: 3408 cross_layer: 3 file: select.c
return multiSelectOrderBy ( pParse , p , pDest ) ; location: 2587 cross_layer: 4 file: select.c
------------------------------
5 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 4 file: select.c
if ( rc )  location: 2757 cross_layer: 4 file: select.c
testcase ( rc != SQLITE_OK ); location: 2773 cross_layer: 4 file: select.c
return rc ; location: 2866 cross_layer: 4 file: select.c
------------------------------
6 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
sqlite3Select ( pParse , p , & destQueue ); location: 2424 cross_layer: 4 file: select.c
assert ( p -> pPrior == 0 ); location: 2425 cross_layer: 4 file: select.c
p -> pPrior = pSetup; location: 2426 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrTop ); location: 2430 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 2431 cross_layer: 4 file: select.c
sqlite3ExprListDelete ( pParse -> db , p -> pOrderBy ); location: 2434 cross_layer: 4 file: select.c
p -> pOrderBy = pOrderBy; location: 2435 cross_layer: 4 file: select.c
p -> pLimit = pLimit; location: 2436 cross_layer: 4 file: select.c
------------------------------
7 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 4 file: select.c
if ( rc )  location: 2609 cross_layer: 4 file: select.c
return rc ; location: 2866 cross_layer: 4 file: select.c
------------------------------
8 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
sqlite3Select ( pParse , p , & destB ); location: 3296 cross_layer: 4 file: select.c
p -> iLimit = savedLimit; location: 3297 cross_layer: 4 file: select.c
p -> iOffset = savedOffset; location: 3298 cross_layer: 4 file: select.c
sqlite3VdbeEndCoroutine ( v , regAddrB ); location: 3299 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "Output routine for A" ) ); location: 3304 cross_layer: 4 file: select.c
addrOutA = generateOutputSubroutine ( pParse , p , & destA , pDest , regOutA , regPrev , pKeyDup , labelEnd ); location: 3305 cross_layer: 4 file: select.c
static int generateOutputSubroutine(
Parse *pParse,          /* Parsing context */
Select *p,              /* The SELECT statement */
SelectDest *pIn,        /* Coroutine supplying data */
SelectDest *pDest,      /* Where to send the data */
int regReturn,          /* The return address register */
int regPrev,            /* Previous result register.  No uniqueness if 0 */
KeyInfo *pKeyInfo,      /* For comparing with previous entry */
int iBreak              /* Jump here if we hit the LIMIT */
) location: 2912 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 2913 cross_layer: 5 file: select.c
addr = sqlite3VdbeCurrentAddr ( v ); location: 2917 cross_layer: 5 file: select.c
iContinue = sqlite3VdbeMakeLabel ( pParse ); location: 2918 cross_layer: 5 file: select.c
if ( regPrev )  location: 2922 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeAddOp1 ( v , OP_IfNot , regPrev ); location: 2924 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2924 cross_layer: 5 file: select.c
addr2 = sqlite3VdbeAddOp4 ( v , OP_Compare , pIn -> iSdst , regPrev + 1 , pIn -> nSdst , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 2925 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr2 + 2 , iContinue , addr2 + 2 ); location: 2927 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2927 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 2928 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , pIn -> iSdst , regPrev + 1 , pIn -> nSdst - 1 ); location: 2929 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regPrev ); location: 2930 cross_layer: 5 file: select.c
if ( pParse -> db -> mallocFailed )  location: 2932 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 2936 cross_layer: 5 file: select.c
assert ( pDest -> eDest != SRT_Exists ); location: 2938 cross_layer: 5 file: select.c
assert ( pDest -> eDest != SRT_Table ); location: 2939 cross_layer: 5 file: select.c
switch ( pDest -> eDest )  location: 2940 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 2944 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 2945 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 ); location: 2946 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , pDest -> iSDParm , r2 ); location: 2947 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , pDest -> iSDParm , r1 , r2 ); location: 2948 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 2949 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 2950 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2951 cross_layer: 5 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2960 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 2961 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 , pDest -> zAffSdst , pIn -> nSdst ); location: 2962 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , pDest -> iSDParm , r1 , pIn -> iSdst , pIn -> nSdst ); location: 2964 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2966 cross_layer: 5 file: select.c
if ( pParse -> nErr == 0 )  location: 2976 cross_layer: 5 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2977 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSDParm , pIn -> nSdst ); location: 2978 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 2989 cross_layer: 5 file: select.c
pDest -> iSdst = sqlite3GetTempRange ( pParse , pIn -> nSdst ); location: 2990 cross_layer: 5 file: select.c
pDest -> nSdst = pIn -> nSdst; location: 2991 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSdst , pIn -> nSdst ); location: 2993 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 2994 cross_layer: 5 file: select.c
assert ( pDest -> eDest == SRT_Output ); location: 3007 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pIn -> iSdst , pIn -> nSdst ); location: 3008 cross_layer: 5 file: select.c
if ( p -> iLimit )  location: 3015 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 3016 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3016 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iContinue ); location: 3021 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReturn ); location: 3022 cross_layer: 5 file: select.c
return addr ; location: 3024 cross_layer: 5 file: select.c
if ( op == TK_ALL || op == TK_UNION )  location: 3312 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "Output routine for B" ) ); location: 3313 cross_layer: 4 file: select.c
addrOutB = generateOutputSubroutine ( pParse , p , & destB , pDest , regOutB , regPrev , pKeyDup , labelEnd ); location: 3314 cross_layer: 4 file: select.c
static int generateOutputSubroutine(
Parse *pParse,          /* Parsing context */
Select *p,              /* The SELECT statement */
SelectDest *pIn,        /* Coroutine supplying data */
SelectDest *pDest,      /* Where to send the data */
int regReturn,          /* The return address register */
int regPrev,            /* Previous result register.  No uniqueness if 0 */
KeyInfo *pKeyInfo,      /* For comparing with previous entry */
int iBreak              /* Jump here if we hit the LIMIT */
) location: 2912 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 2913 cross_layer: 5 file: select.c
addr = sqlite3VdbeCurrentAddr ( v ); location: 2917 cross_layer: 5 file: select.c
iContinue = sqlite3VdbeMakeLabel ( pParse ); location: 2918 cross_layer: 5 file: select.c
if ( regPrev )  location: 2922 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeAddOp1 ( v , OP_IfNot , regPrev ); location: 2924 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2924 cross_layer: 5 file: select.c
addr2 = sqlite3VdbeAddOp4 ( v , OP_Compare , pIn -> iSdst , regPrev + 1 , pIn -> nSdst , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 2925 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr2 + 2 , iContinue , addr2 + 2 ); location: 2927 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2927 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 2928 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , pIn -> iSdst , regPrev + 1 , pIn -> nSdst - 1 ); location: 2929 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regPrev ); location: 2930 cross_layer: 5 file: select.c
if ( pParse -> db -> mallocFailed )  location: 2932 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 2936 cross_layer: 5 file: select.c
assert ( pDest -> eDest != SRT_Exists ); location: 2938 cross_layer: 5 file: select.c
assert ( pDest -> eDest != SRT_Table ); location: 2939 cross_layer: 5 file: select.c
switch ( pDest -> eDest )  location: 2940 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 2944 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 2945 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 ); location: 2946 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , pDest -> iSDParm , r2 ); location: 2947 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , pDest -> iSDParm , r1 , r2 ); location: 2948 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 2949 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 2950 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2951 cross_layer: 5 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2960 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 2961 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 , pDest -> zAffSdst , pIn -> nSdst ); location: 2962 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , pDest -> iSDParm , r1 , pIn -> iSdst , pIn -> nSdst ); location: 2964 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2966 cross_layer: 5 file: select.c
if ( pParse -> nErr == 0 )  location: 2976 cross_layer: 5 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2977 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSDParm , pIn -> nSdst ); location: 2978 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 2989 cross_layer: 5 file: select.c
pDest -> iSdst = sqlite3GetTempRange ( pParse , pIn -> nSdst ); location: 2990 cross_layer: 5 file: select.c
pDest -> nSdst = pIn -> nSdst; location: 2991 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSdst , pIn -> nSdst ); location: 2993 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 2994 cross_layer: 5 file: select.c
assert ( pDest -> eDest == SRT_Output ); location: 3007 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pIn -> iSdst , pIn -> nSdst ); location: 3008 cross_layer: 5 file: select.c
if ( p -> iLimit )  location: 3015 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 3016 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3016 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iContinue ); location: 3021 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReturn ); location: 3022 cross_layer: 5 file: select.c
return addr ; location: 3024 cross_layer: 5 file: select.c
sqlite3KeyInfoUnref ( pKeyDup ); location: 3318 cross_layer: 4 file: select.c
void sqlite3KeyInfoUnref(KeyInfo *p) location: 1296 cross_layer: 5 file: select.c
if ( p )  location: 1297 cross_layer: 5 file: select.c
assert ( p -> nRef > 0 ); location: 1298 cross_layer: 5 file: select.c
p -> nRef --; location: 1299 cross_layer: 5 file: select.c
if ( p -> nRef == 0 )  location: 1300 cross_layer: 5 file: select.c
sqlite3DbFreeNN ( p -> db , p ); location: 1300 cross_layer: 5 file: select.c
if ( op == TK_EXCEPT || op == TK_INTERSECT )  location: 3323 cross_layer: 4 file: select.c
addrEofA_noB = addrEofA = labelEnd; location: 3324 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "eof-A subroutine" ) ); location: 3326 cross_layer: 4 file: select.c
addrEofA = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutB , addrOutB ); location: 3327 cross_layer: 4 file: select.c
addrEofA_noB = sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , labelEnd ); location: 3328 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3329 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrEofA ); location: 3330 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 3331 cross_layer: 4 file: select.c
if ( op == TK_INTERSECT )  location: 3337 cross_layer: 4 file: select.c
addrEofB = addrEofA; location: 3338 cross_layer: 4 file: select.c
if ( p -> nSelectRow > pPrior -> nSelectRow )  location: 3339 cross_layer: 4 file: select.c
p -> nSelectRow = pPrior -> nSelectRow; location: 3339 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "eof-B subroutine" ) ); location: 3341 cross_layer: 4 file: select.c
addrEofB = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutA , addrOutA ); location: 3342 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , labelEnd ); location: 3343 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3343 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrEofB ); location: 3344 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "A-lt-B subroutine" ) ); location: 3349 cross_layer: 4 file: select.c
addrAltB = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutA , addrOutA ); location: 3350 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA ); location: 3351 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3351 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3352 cross_layer: 4 file: select.c
if ( op == TK_ALL )  location: 3356 cross_layer: 4 file: select.c
addrAeqB = addrAltB; location: 3357 cross_layer: 4 file: select.c
if ( op == TK_INTERSECT )  location: 3358 cross_layer: 4 file: select.c
addrAeqB = addrAltB; location: 3359 cross_layer: 4 file: select.c
addrAltB ++; location: 3360 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "A-eq-B subroutine" ) ); location: 3362 cross_layer: 4 file: select.c
addrAeqB = sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA ); location: 3363 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3364 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3365 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "A-gt-B subroutine" ) ); location: 3370 cross_layer: 4 file: select.c
addrAgtB = sqlite3VdbeCurrentAddr ( v ); location: 3371 cross_layer: 4 file: select.c
if ( op == TK_ALL || op == TK_UNION )  location: 3372 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutB , addrOutB ); location: 3373 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , addrEofB ); location: 3375 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3375 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3376 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 3380 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA_noB ); location: 3381 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3381 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , addrEofB ); location: 3382 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3382 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , labelCmpr ); location: 3386 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Permutation , 0 , 0 , 0 , ( char * ) aPermute , P4_INTARRAY ); location: 3387 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , destA . iSdst , destB . iSdst , nOrderBy , ( char * ) pKeyMerge , P4_KEYINFO ); location: 3388 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_PERMUTE ); location: 3390 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addrAltB , addrAeqB , addrAgtB ); location: 3391 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3391 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , labelEnd ); location: 3395 cross_layer: 4 file: select.c
if ( p -> pPrior )  location: 3399 cross_layer: 4 file: select.c
sqlite3SelectDelete ( db , p -> pPrior ); location: 3400 cross_layer: 4 file: select.c
void sqlite3SelectDelete(sqlite3 *db, Select *p) location: 187 cross_layer: 5 file: select.c
if ( OK_IF_ALWAYS_TRUE ( p ) )  location: 188 cross_layer: 5 file: select.c
clearSelect ( db , p , 1 ); location: 188 cross_layer: 5 file: select.c
p -> pPrior = pPrior; location: 3402 cross_layer: 4 file: select.c
pPrior -> pNext = p; location: 3403 cross_layer: 4 file: select.c
ExplainQueryPlanPop ( pParse ); location: 3407 cross_layer: 4 file: select.c
return pParse -> nErr != 0 ; location: 3408 cross_layer: 4 file: select.c
------------------------------
9 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 4 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 4 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 4 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 4 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 4 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 4 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 4 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 4 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 4 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 4 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 4 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 4 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 4 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 4 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 5 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 5 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 5 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 5 file: select.c
if ( pInfo )  location: 1353 cross_layer: 5 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 5 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 5 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 5 file: select.c
return pInfo ; location: 1360 cross_layer: 5 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 4 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 4 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 4 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 4 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 4 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 4 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 5 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 5 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 5 file: select.c
if ( pLimit )  location: 2168 cross_layer: 5 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 5 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 5 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 5 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 5 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 5 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 5 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 5 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 5 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 5 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 5 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 5 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 5 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 5 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 4 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 4 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 4 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 4 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 4 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 4 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 5 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 5 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 5 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 5 file: select.c
if ( pInfo )  location: 1353 cross_layer: 5 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 5 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 5 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 5 file: select.c
return pInfo ; location: 1360 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 4 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 4 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 4 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 4 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 4 file: select.c
if ( pWin )  location: 6154 cross_layer: 4 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 4 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 4 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 4 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 4 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 4 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 4 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 4 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 4 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 4 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 4 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 4 file: select.c
if ( pWin )  location: 6190 cross_layer: 4 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 4 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 4 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 4 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 4 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 4 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 4 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 4 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 5 file: select.c
assert ( v ); location: 887 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 5 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 5 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 5 file: select.c
pSort = 0; location: 890 cross_layer: 5 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 5 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 5 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 5 file: select.c
if ( pSort )  location: 901 cross_layer: 5 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 5 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 5 file: select.c
nPrefixReg ++; location: 903 cross_layer: 5 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 5 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 5 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 5 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 5 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 5 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 5 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 5 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 5 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 5 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 5 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 5 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 5 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 5 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 5 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 5 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 5 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 5 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 5 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 5 file: select.c
nResultCol --; location: 976 cross_layer: 5 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 5 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 5 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 5 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 5 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 5 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 5 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 5 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 5 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 5 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 5 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 5 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 5 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 5 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 5 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 5 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 5 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 5 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 5 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 5 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 5 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 5 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 5 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 5 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 5 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 5 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 5 file: select.c
switch ( eDest )  location: 1072 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 5 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 5 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 5 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 5 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 5 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 5 file: select.c
if ( pSort )  location: 1122 cross_layer: 5 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 5 file: select.c
if ( pSort )  location: 1142 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 5 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 5 file: select.c
if ( pSort )  location: 1173 cross_layer: 5 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 5 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 5 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 5 file: select.c
if ( pSort )  location: 1190 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 5 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 5 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 5 file: select.c
assert ( pSO ); location: 1215 cross_layer: 5 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 5 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 5 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 5 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 5 file: select.c
if ( addrTest )  location: 1241 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 5 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 5 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 4 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 4 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 4 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 5 file: select.c
assert ( v ); location: 887 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 5 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 5 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 5 file: select.c
pSort = 0; location: 890 cross_layer: 5 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 5 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 5 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 5 file: select.c
if ( pSort )  location: 901 cross_layer: 5 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 5 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 5 file: select.c
nPrefixReg ++; location: 903 cross_layer: 5 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 5 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 5 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 5 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 5 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 5 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 5 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 5 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 5 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 5 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 5 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 5 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 5 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 5 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 5 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 5 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 5 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 5 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 5 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 5 file: select.c
nResultCol --; location: 976 cross_layer: 5 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 5 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 5 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 5 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 5 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 5 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 5 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 5 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 5 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 5 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 5 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 5 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 5 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 5 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 5 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 5 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 5 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 5 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 5 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 5 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 5 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 5 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 5 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 5 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 5 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 5 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 5 file: select.c
switch ( eDest )  location: 1072 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 5 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 5 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 5 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 5 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 5 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 5 file: select.c
if ( pSort )  location: 1122 cross_layer: 5 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 5 file: select.c
if ( pSort )  location: 1142 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 5 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 5 file: select.c
if ( pSort )  location: 1173 cross_layer: 5 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 5 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 5 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 5 file: select.c
if ( pSort )  location: 1190 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 5 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 5 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 5 file: select.c
assert ( pSO ); location: 1215 cross_layer: 5 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 5 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 5 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 5 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 5 file: select.c
if ( addrTest )  location: 1241 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 5 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 5 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 4 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 4 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 4 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 4 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 4 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 4 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 4 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 4 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 4 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 4 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 4 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 4 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 4 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 4 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 4 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 4 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 4 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 4 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 4 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 4 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 4 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 4 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 4 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 5 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 5 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 5 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 5 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 5 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 4 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 4 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 4 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 4 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 4 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 5 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 5 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 5 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 5 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 5 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 5 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 5 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 5 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 5 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 5 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 5 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 5 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 4 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 4 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 4 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 4 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 4 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 4 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 4 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 4 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 4 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 4 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 4 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 4 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 4 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 4 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 4 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 5 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 5 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 5 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 5 file: select.c
if ( pInfo )  location: 1353 cross_layer: 5 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 5 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 5 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 5 file: select.c
return pInfo ; location: 1360 cross_layer: 5 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 4 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 4 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 4 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 4 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 4 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 4 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 4 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 4 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 4 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 4 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 4 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 4 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 4 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 4 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 4 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 4 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 4 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 5 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 4 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 4 file: select.c
j = nGroupBy; location: 6422 cross_layer: 4 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 4 file: select.c
nCol ++; location: 6425 cross_layer: 4 file: select.c
j ++; location: 6426 cross_layer: 4 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 4 file: select.c
j = nGroupBy; location: 6431 cross_layer: 4 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 4 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 4 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 4 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 4 file: select.c
j ++; location: 6438 cross_layer: 4 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 4 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 4 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 4 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 4 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 4 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 4 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 4 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 4 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 5 file: select.c
if ( p )  location: 1308 cross_layer: 5 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 5 file: select.c
p -> nRef ++; location: 1310 cross_layer: 5 file: select.c
return p ; location: 1312 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 4 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 4 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 4 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 4 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 4 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 4 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 5 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 5 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 5 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 5 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 5 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 5 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 5 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 5 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 5 file: select.c
if ( pList )  location: 5398 cross_layer: 5 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 5 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 5 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 5 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 5 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 5 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 5 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 5 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 5 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 5 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 5 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 5 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 5 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 5 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 5 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 5 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 5 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 5 file: select.c
if ( addrNext )  location: 5432 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 5 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 5 file: select.c
regHit = regAcc; location: 5437 cross_layer: 5 file: select.c
if ( regHit )  location: 5439 cross_layer: 5 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 5 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 5 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 4 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 4 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 4 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 4 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 4 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 4 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 4 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 4 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 5 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 5 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 4 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 4 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 5 file: select.c
assert ( v ); location: 887 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 5 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 5 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 5 file: select.c
pSort = 0; location: 890 cross_layer: 5 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 5 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 5 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 5 file: select.c
if ( pSort )  location: 901 cross_layer: 5 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 5 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 5 file: select.c
nPrefixReg ++; location: 903 cross_layer: 5 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 5 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 5 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 5 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 5 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 5 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 5 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 5 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 5 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 5 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 5 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 5 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 5 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 5 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 5 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 5 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 5 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 5 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 5 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 5 file: select.c
nResultCol --; location: 976 cross_layer: 5 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 5 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 5 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 5 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 5 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 5 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 5 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 5 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 5 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 5 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 5 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 5 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 5 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 5 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 5 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 5 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 5 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 5 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 5 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 5 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 5 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 5 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 5 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 5 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 5 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 5 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 5 file: select.c
switch ( eDest )  location: 1072 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 5 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 5 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 5 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 5 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 5 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 5 file: select.c
if ( pSort )  location: 1122 cross_layer: 5 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 5 file: select.c
if ( pSort )  location: 1142 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 5 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 5 file: select.c
if ( pSort )  location: 1173 cross_layer: 5 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 5 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 5 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 5 file: select.c
if ( pSort )  location: 1190 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 5 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 5 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 5 file: select.c
assert ( pSO ); location: 1215 cross_layer: 5 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 5 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 5 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 5 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 5 file: select.c
if ( addrTest )  location: 1241 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 5 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 5 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 4 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 4 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 4 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 5 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 5 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 5 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 5 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 5 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 5 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 5 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 5 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 5 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 5 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 5 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 4 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 4 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 4 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 4 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 4 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 4 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 4 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 4 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 4 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 5 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 5 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 5 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 5 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 4 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 4 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 4 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 4 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 4 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 4 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 4 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 5 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 5 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 5 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 5 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 5 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 5 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 5 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 5 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 5 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 5 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 5 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 5 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 4 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 4 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 4 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 4 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 4 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 5 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 5 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 5 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 5 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 5 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 5 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 5 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 5 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 5 file: select.c
if ( pList )  location: 5398 cross_layer: 5 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 5 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 5 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 5 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 5 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 5 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 5 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 5 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 5 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 5 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 5 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 5 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 5 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 5 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 5 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 5 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 5 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 5 file: select.c
if ( addrNext )  location: 5432 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 5 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 5 file: select.c
regHit = regAcc; location: 5437 cross_layer: 5 file: select.c
if ( regHit )  location: 5439 cross_layer: 5 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 5 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 5 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 5 file: select.c
if ( regAcc )  location: 6676 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 4 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 4 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 4 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 5 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 5 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 4 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 4 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 5 file: select.c
assert ( v ); location: 887 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 5 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 5 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 5 file: select.c
pSort = 0; location: 890 cross_layer: 5 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 5 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 5 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 5 file: select.c
if ( pSort )  location: 901 cross_layer: 5 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 5 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 5 file: select.c
nPrefixReg ++; location: 903 cross_layer: 5 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 5 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 5 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 5 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 5 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 5 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 5 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 5 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 5 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 5 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 5 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 5 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 5 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 5 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 5 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 5 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 5 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 5 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 5 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 5 file: select.c
nResultCol --; location: 976 cross_layer: 5 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 5 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 5 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 5 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 5 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 5 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 5 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 5 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 5 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 5 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 5 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 5 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 5 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 5 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 5 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 5 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 5 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 5 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 5 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 5 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 5 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 5 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 5 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 5 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 5 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 5 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 5 file: select.c
switch ( eDest )  location: 1072 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 5 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 5 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 5 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 5 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 5 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 5 file: select.c
if ( pSort )  location: 1122 cross_layer: 5 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 5 file: select.c
if ( pSort )  location: 1142 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 5 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 5 file: select.c
if ( pSort )  location: 1173 cross_layer: 5 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 5 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 5 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 5 file: select.c
if ( pSort )  location: 1190 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 5 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 5 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 5 file: select.c
assert ( pSO ); location: 1215 cross_layer: 5 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 5 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 5 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 5 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 5 file: select.c
if ( addrTest )  location: 1241 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 5 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 5 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 4 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 4 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 4 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 4 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 4 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 4 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 4 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 5 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 5 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 5 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 5 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 5 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 5 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 5 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 5 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 5 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 5 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 5 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 5 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 5 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 5 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 5 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 5 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 5 file: select.c
nColumn = 0; location: 1465 cross_layer: 5 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 5 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 5 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 5 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 5 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 5 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 5 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 5 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 5 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 5 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 5 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 5 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 5 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 5 file: select.c
iCol ++; location: 1495 cross_layer: 5 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 5 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 5 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 5 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 5 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 5 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 5 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 5 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 5 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 5 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 5 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 5 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 5 file: select.c
iRead = iCol --; location: 1539 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 5 file: select.c
switch ( eDest )  location: 1545 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 5 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 5 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 5 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 5 file: select.c
if ( regRowid )  location: 1579 cross_layer: 5 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 5 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 5 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 4 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 4 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 4 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 4 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 4 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 4 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 4 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 4 file: select.c
return rc ; location: 6731 cross_layer: 4 file: select.c
------------------------------
10 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 4 file: select.c
testcase ( rc != SQLITE_OK ); location: 2625 cross_layer: 4 file: select.c
if ( rc )  location: 2676 cross_layer: 4 file: select.c
testcase ( rc != SQLITE_OK ); location: 2695 cross_layer: 4 file: select.c
if ( rc )  location: 2757 cross_layer: 4 file: select.c
testcase ( rc != SQLITE_OK ); location: 2773 cross_layer: 4 file: select.c
return rc ; location: 2866 cross_layer: 4 file: select.c
------------------------------
11 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 4 file: select.c
if ( rc )  location: 2676 cross_layer: 4 file: select.c
testcase ( rc != SQLITE_OK ); location: 2695 cross_layer: 4 file: select.c
if ( rc )  location: 2757 cross_layer: 4 file: select.c
testcase ( rc != SQLITE_OK ); location: 2773 cross_layer: 4 file: select.c
return rc ; location: 2866 cross_layer: 4 file: select.c
------------------------------
12 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 4 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 4 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 4 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 4 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 4 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 4 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 4 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 4 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 4 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 4 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 4 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 4 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 4 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 4 file: select.c
static struct SrcList_item *isSelfJoinView(
SrcList *pTabList,           /* Search for self-joins in this FROM clause */
struct SrcList_item *pThis   /* Search for prior reference to this subquery */
) location: 5543 cross_layer: 5 file: select.c
for(pItem = pTabList->a; pItem<pThis; pItem++) location: 5545 cross_layer: 5 file: select.c
if ( pItem -> pSelect == 0 )  location: 5547 cross_layer: 5 file: select.c
if ( pItem -> fg . viaCoroutine )  location: 5548 cross_layer: 5 file: select.c
if ( pItem -> zName == 0 )  location: 5549 cross_layer: 5 file: select.c
assert ( pItem -> pTab != 0 ); location: 5550 cross_layer: 5 file: select.c
assert ( pThis -> pTab != 0 ); location: 5551 cross_layer: 5 file: select.c
if ( pItem -> pTab -> pSchema != pThis -> pTab -> pSchema )  location: 5552 cross_layer: 5 file: select.c
if ( sqlite3_stricmp ( pItem -> zName , pThis -> zName ) != 0 )  location: 5553 cross_layer: 5 file: select.c
pS1 = pItem -> pSelect; location: 5554 cross_layer: 5 file: select.c
if ( pItem -> pTab -> pSchema == 0 && pThis -> pSelect -> selId != pS1 -> selId )  location: 5555 cross_layer: 5 file: select.c
if ( sqlite3ExprCompare ( 0 , pThis -> pSelect -> pWhere , pS1 -> pWhere , - 1 ) || sqlite3ExprCompare ( 0 , pThis -> pSelect -> pHaving , pS1 -> pHaving , - 1 ) )  location: 5560 cross_layer: 5 file: select.c
return pItem ; location: 5567 cross_layer: 5 file: select.c
if ( pPrior )  location: 6023 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 4 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 4 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 4 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 4 file: select.c
void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm) location: 115 cross_layer: 5 file: select.c
pDest -> eDest = ( u8 ) eDest; location: 116 cross_layer: 5 file: select.c
pDest -> iSDParm = iParm; location: 117 cross_layer: 5 file: select.c
pDest -> zAffSdst = 0; location: 118 cross_layer: 5 file: select.c
pDest -> iSdst = 0; location: 119 cross_layer: 5 file: select.c
pDest -> nSdst = 0; location: 120 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 4 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 4 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 4 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 4 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 4 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 4 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 4 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 4 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 4 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 4 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 4 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 4 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 4 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 4 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 4 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 5 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 5 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 5 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 5 file: select.c
if ( pInfo )  location: 1353 cross_layer: 5 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 5 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 5 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 5 file: select.c
return pInfo ; location: 1360 cross_layer: 5 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 4 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 4 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 4 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 4 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 4 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 4 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 5 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 5 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 5 file: select.c
if ( pLimit )  location: 2168 cross_layer: 5 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 5 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 5 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 5 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 5 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 5 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 5 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 5 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 5 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 5 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 5 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 5 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 5 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 5 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 4 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 4 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 4 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 4 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 4 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 4 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 5 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 5 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 5 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 5 file: select.c
if ( pInfo )  location: 1353 cross_layer: 5 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 5 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 5 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 5 file: select.c
return pInfo ; location: 1360 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 4 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 4 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 4 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 4 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 4 file: select.c
if ( pWin )  location: 6154 cross_layer: 4 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 4 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 4 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 4 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 4 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 4 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 4 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 4 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 4 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 4 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 4 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 4 file: select.c
if ( pWin )  location: 6190 cross_layer: 4 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 4 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 4 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 4 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 4 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 4 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 4 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 4 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 5 file: select.c
assert ( v ); location: 887 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 5 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 5 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 5 file: select.c
pSort = 0; location: 890 cross_layer: 5 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 5 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 5 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 5 file: select.c
if ( pSort )  location: 901 cross_layer: 5 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 5 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 5 file: select.c
nPrefixReg ++; location: 903 cross_layer: 5 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 5 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 5 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 5 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 5 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 5 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 5 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 5 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 5 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 5 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 5 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 5 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 5 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 5 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 5 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 5 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 5 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 5 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 5 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 5 file: select.c
nResultCol --; location: 976 cross_layer: 5 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 5 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 5 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 5 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 5 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 5 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 5 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 5 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 5 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 5 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 5 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 5 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 5 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 5 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 5 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 5 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 5 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 5 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 5 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 5 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 5 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 5 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 5 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 5 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 5 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 5 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 5 file: select.c
switch ( eDest )  location: 1072 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 5 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 5 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 5 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 5 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 5 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 5 file: select.c
if ( pSort )  location: 1122 cross_layer: 5 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 5 file: select.c
if ( pSort )  location: 1142 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 5 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 5 file: select.c
if ( pSort )  location: 1173 cross_layer: 5 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 5 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 5 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 5 file: select.c
if ( pSort )  location: 1190 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 5 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 5 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 5 file: select.c
assert ( pSO ); location: 1215 cross_layer: 5 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 5 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 5 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 5 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 5 file: select.c
if ( addrTest )  location: 1241 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 5 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 5 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 4 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 4 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 4 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 5 file: select.c
assert ( v ); location: 887 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 5 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 5 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 5 file: select.c
pSort = 0; location: 890 cross_layer: 5 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 5 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 5 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 5 file: select.c
if ( pSort )  location: 901 cross_layer: 5 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 5 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 5 file: select.c
nPrefixReg ++; location: 903 cross_layer: 5 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 5 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 5 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 5 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 5 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 5 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 5 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 5 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 5 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 5 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 5 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 5 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 5 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 5 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 5 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 5 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 5 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 5 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 5 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 5 file: select.c
nResultCol --; location: 976 cross_layer: 5 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 5 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 5 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 5 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 5 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 5 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 5 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 5 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 5 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 5 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 5 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 5 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 5 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 5 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 5 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 5 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 5 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 5 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 5 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 5 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 5 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 5 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 5 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 5 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 5 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 5 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 5 file: select.c
switch ( eDest )  location: 1072 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 5 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 5 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 5 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 5 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 5 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 5 file: select.c
if ( pSort )  location: 1122 cross_layer: 5 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 5 file: select.c
if ( pSort )  location: 1142 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 5 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 5 file: select.c
if ( pSort )  location: 1173 cross_layer: 5 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 5 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 5 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 5 file: select.c
if ( pSort )  location: 1190 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 5 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 5 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 5 file: select.c
assert ( pSO ); location: 1215 cross_layer: 5 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 5 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 5 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 5 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 5 file: select.c
if ( addrTest )  location: 1241 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 5 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 5 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 4 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 4 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 4 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 4 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 4 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 4 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 4 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 4 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 4 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 4 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 4 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 4 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 4 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 4 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 4 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 4 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 4 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 4 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 4 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 4 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 4 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 4 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 4 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 5 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 5 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 5 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 5 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 5 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 4 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 4 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 4 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 4 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 4 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 5 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 5 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 5 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 5 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 5 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 5 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 5 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 5 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 5 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 5 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 5 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 5 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 4 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 4 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 4 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 4 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 4 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 4 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 4 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 4 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 4 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 4 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 4 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 4 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 4 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 4 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 4 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 5 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 5 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 5 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 5 file: select.c
if ( pInfo )  location: 1353 cross_layer: 5 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 5 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 5 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 5 file: select.c
return pInfo ; location: 1360 cross_layer: 5 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 4 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 4 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 4 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 4 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 4 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 4 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 4 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 4 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 4 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 4 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 4 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 4 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 4 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 4 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 4 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 4 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 4 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 5 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 4 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 4 file: select.c
j = nGroupBy; location: 6422 cross_layer: 4 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 4 file: select.c
nCol ++; location: 6425 cross_layer: 4 file: select.c
j ++; location: 6426 cross_layer: 4 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 4 file: select.c
j = nGroupBy; location: 6431 cross_layer: 4 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 4 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 4 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 4 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 4 file: select.c
j ++; location: 6438 cross_layer: 4 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 4 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 4 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 4 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 4 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 4 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 4 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 4 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 4 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 5 file: select.c
if ( p )  location: 1308 cross_layer: 5 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 5 file: select.c
p -> nRef ++; location: 1310 cross_layer: 5 file: select.c
return p ; location: 1312 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 4 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 4 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 4 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 4 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 4 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 4 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 5 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 5 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 5 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 5 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 5 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 5 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 5 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 5 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 5 file: select.c
if ( pList )  location: 5398 cross_layer: 5 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 5 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 5 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 5 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 5 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 5 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 5 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 5 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 5 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 5 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 5 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 5 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 5 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 5 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 5 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 5 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 5 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 5 file: select.c
if ( addrNext )  location: 5432 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 5 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 5 file: select.c
regHit = regAcc; location: 5437 cross_layer: 5 file: select.c
if ( regHit )  location: 5439 cross_layer: 5 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 5 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 5 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 4 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 4 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 4 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 4 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 4 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 4 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 4 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 4 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 5 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 5 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 4 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 4 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 5 file: select.c
assert ( v ); location: 887 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 5 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 5 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 5 file: select.c
pSort = 0; location: 890 cross_layer: 5 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 5 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 5 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 5 file: select.c
if ( pSort )  location: 901 cross_layer: 5 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 5 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 5 file: select.c
nPrefixReg ++; location: 903 cross_layer: 5 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 5 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 5 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 5 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 5 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 5 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 5 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 5 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 5 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 5 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 5 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 5 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 5 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 5 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 5 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 5 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 5 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 5 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 5 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 5 file: select.c
nResultCol --; location: 976 cross_layer: 5 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 5 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 5 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 5 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 5 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 5 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 5 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 5 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 5 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 5 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 5 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 5 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 5 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 5 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 5 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 5 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 5 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 5 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 5 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 5 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 5 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 5 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 5 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 5 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 5 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 5 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 5 file: select.c
switch ( eDest )  location: 1072 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 5 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 5 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 5 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 5 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 5 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 5 file: select.c
if ( pSort )  location: 1122 cross_layer: 5 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 5 file: select.c
if ( pSort )  location: 1142 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 5 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 5 file: select.c
if ( pSort )  location: 1173 cross_layer: 5 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 5 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 5 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 5 file: select.c
if ( pSort )  location: 1190 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 5 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 5 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 5 file: select.c
assert ( pSO ); location: 1215 cross_layer: 5 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 5 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 5 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 5 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 5 file: select.c
if ( addrTest )  location: 1241 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 5 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 5 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 4 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 4 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 4 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 5 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 5 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 5 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 5 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 5 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 5 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 5 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 5 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 5 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 5 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 5 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 4 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 4 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 4 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 4 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 4 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 4 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 4 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 4 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 4 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 5 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 5 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 5 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 5 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 4 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 4 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 4 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 4 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 4 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 4 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 4 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 5 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 5 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 5 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 5 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 5 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 5 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 5 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 5 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 5 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 5 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 5 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 5 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 4 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 4 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 4 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 4 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 4 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 5 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 5 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 5 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 5 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 5 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 5 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 5 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 5 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 5 file: select.c
if ( pList )  location: 5398 cross_layer: 5 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 5 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 5 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 5 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 5 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 5 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 5 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 5 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 5 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 5 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 5 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 5 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 5 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 5 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 5 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 5 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 5 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 5 file: select.c
if ( addrNext )  location: 5432 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 5 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 5 file: select.c
regHit = regAcc; location: 5437 cross_layer: 5 file: select.c
if ( regHit )  location: 5439 cross_layer: 5 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 5 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 5 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 5 file: select.c
if ( regAcc )  location: 6676 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 4 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 4 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 4 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 5 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 5 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 4 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 4 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 5 file: select.c
assert ( v ); location: 887 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 5 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 5 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 5 file: select.c
pSort = 0; location: 890 cross_layer: 5 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 5 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 5 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 5 file: select.c
if ( pSort )  location: 901 cross_layer: 5 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 5 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 5 file: select.c
nPrefixReg ++; location: 903 cross_layer: 5 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 5 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 5 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 5 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 5 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 5 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 5 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 5 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 5 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 5 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 5 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 5 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 5 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 5 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 5 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 5 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 5 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 5 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 5 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 5 file: select.c
nResultCol --; location: 976 cross_layer: 5 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 5 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 5 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 5 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 5 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 5 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 5 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 5 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 5 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 5 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 5 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 5 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 5 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 5 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 5 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 5 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 5 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 5 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 5 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 5 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 5 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 5 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 5 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 5 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 5 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 5 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 5 file: select.c
switch ( eDest )  location: 1072 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 5 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 5 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 5 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 5 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 5 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 5 file: select.c
if ( pSort )  location: 1122 cross_layer: 5 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 5 file: select.c
if ( pSort )  location: 1142 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 5 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 5 file: select.c
if ( pSort )  location: 1173 cross_layer: 5 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 5 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 5 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 5 file: select.c
if ( pSort )  location: 1190 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 5 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 5 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 5 file: select.c
assert ( pSO ); location: 1215 cross_layer: 5 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 5 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 5 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 5 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 5 file: select.c
if ( addrTest )  location: 1241 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 5 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 5 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 4 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 4 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 4 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 4 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 4 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 4 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 4 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 5 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 5 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 5 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 5 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 5 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 5 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 5 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 5 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 5 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 5 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 5 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 5 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 5 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 5 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 5 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 5 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 5 file: select.c
nColumn = 0; location: 1465 cross_layer: 5 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 5 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 5 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 5 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 5 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 5 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 5 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 5 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 5 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 5 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 5 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 5 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 5 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 5 file: select.c
iCol ++; location: 1495 cross_layer: 5 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 5 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 5 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 5 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 5 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 5 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 5 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 5 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 5 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 5 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 5 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 5 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 5 file: select.c
iRead = iCol --; location: 1539 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 5 file: select.c
switch ( eDest )  location: 1545 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 5 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 5 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 5 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 5 file: select.c
if ( regRowid )  location: 1579 cross_layer: 5 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 5 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 5 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 4 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 4 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 4 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 4 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 4 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 4 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 4 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 4 file: select.c
return rc ; location: 6731 cross_layer: 4 file: select.c
------------------------------
13 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
sqlite3Select ( pParse , pPrior , & destA ); location: 3281 cross_layer: 4 file: select.c
sqlite3VdbeEndCoroutine ( v , regAddrA ); location: 3282 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 3283 cross_layer: 4 file: select.c
addrSelectB = sqlite3VdbeCurrentAddr ( v ) + 1; location: 3288 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeAddOp3 ( v , OP_InitCoroutine , regAddrB , 0 , addrSelectB ); location: 3289 cross_layer: 4 file: select.c
VdbeComment ( ( v , "right SELECT" ) ); location: 3290 cross_layer: 4 file: select.c
savedLimit = p -> iLimit; location: 3291 cross_layer: 4 file: select.c
savedOffset = p -> iOffset; location: 3292 cross_layer: 4 file: select.c
p -> iLimit = regLimitB; location: 3293 cross_layer: 4 file: select.c
p -> iOffset = 0; location: 3294 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "RIGHT" ) ); location: 3295 cross_layer: 4 file: select.c
sqlite3Select ( pParse , p , & destB ); location: 3296 cross_layer: 4 file: select.c
p -> iLimit = savedLimit; location: 3297 cross_layer: 4 file: select.c
p -> iOffset = savedOffset; location: 3298 cross_layer: 4 file: select.c
sqlite3VdbeEndCoroutine ( v , regAddrB ); location: 3299 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "Output routine for A" ) ); location: 3304 cross_layer: 4 file: select.c
addrOutA = generateOutputSubroutine ( pParse , p , & destA , pDest , regOutA , regPrev , pKeyDup , labelEnd ); location: 3305 cross_layer: 4 file: select.c
static int generateOutputSubroutine(
Parse *pParse,          /* Parsing context */
Select *p,              /* The SELECT statement */
SelectDest *pIn,        /* Coroutine supplying data */
SelectDest *pDest,      /* Where to send the data */
int regReturn,          /* The return address register */
int regPrev,            /* Previous result register.  No uniqueness if 0 */
KeyInfo *pKeyInfo,      /* For comparing with previous entry */
int iBreak              /* Jump here if we hit the LIMIT */
) location: 2912 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 2913 cross_layer: 5 file: select.c
addr = sqlite3VdbeCurrentAddr ( v ); location: 2917 cross_layer: 5 file: select.c
iContinue = sqlite3VdbeMakeLabel ( pParse ); location: 2918 cross_layer: 5 file: select.c
if ( regPrev )  location: 2922 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeAddOp1 ( v , OP_IfNot , regPrev ); location: 2924 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2924 cross_layer: 5 file: select.c
addr2 = sqlite3VdbeAddOp4 ( v , OP_Compare , pIn -> iSdst , regPrev + 1 , pIn -> nSdst , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 2925 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr2 + 2 , iContinue , addr2 + 2 ); location: 2927 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2927 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 2928 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , pIn -> iSdst , regPrev + 1 , pIn -> nSdst - 1 ); location: 2929 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regPrev ); location: 2930 cross_layer: 5 file: select.c
if ( pParse -> db -> mallocFailed )  location: 2932 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 2936 cross_layer: 5 file: select.c
assert ( pDest -> eDest != SRT_Exists ); location: 2938 cross_layer: 5 file: select.c
assert ( pDest -> eDest != SRT_Table ); location: 2939 cross_layer: 5 file: select.c
switch ( pDest -> eDest )  location: 2940 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 2944 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 2945 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 ); location: 2946 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , pDest -> iSDParm , r2 ); location: 2947 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , pDest -> iSDParm , r1 , r2 ); location: 2948 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 2949 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 2950 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2951 cross_layer: 5 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2960 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 2961 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 , pDest -> zAffSdst , pIn -> nSdst ); location: 2962 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , pDest -> iSDParm , r1 , pIn -> iSdst , pIn -> nSdst ); location: 2964 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2966 cross_layer: 5 file: select.c
if ( pParse -> nErr == 0 )  location: 2976 cross_layer: 5 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2977 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSDParm , pIn -> nSdst ); location: 2978 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 2989 cross_layer: 5 file: select.c
pDest -> iSdst = sqlite3GetTempRange ( pParse , pIn -> nSdst ); location: 2990 cross_layer: 5 file: select.c
pDest -> nSdst = pIn -> nSdst; location: 2991 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSdst , pIn -> nSdst ); location: 2993 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 2994 cross_layer: 5 file: select.c
assert ( pDest -> eDest == SRT_Output ); location: 3007 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pIn -> iSdst , pIn -> nSdst ); location: 3008 cross_layer: 5 file: select.c
if ( p -> iLimit )  location: 3015 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 3016 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3016 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iContinue ); location: 3021 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReturn ); location: 3022 cross_layer: 5 file: select.c
return addr ; location: 3024 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "Output routine for B" ) ); location: 3313 cross_layer: 4 file: select.c
addrOutB = generateOutputSubroutine ( pParse , p , & destB , pDest , regOutB , regPrev , pKeyDup , labelEnd ); location: 3314 cross_layer: 4 file: select.c
static int generateOutputSubroutine(
Parse *pParse,          /* Parsing context */
Select *p,              /* The SELECT statement */
SelectDest *pIn,        /* Coroutine supplying data */
SelectDest *pDest,      /* Where to send the data */
int regReturn,          /* The return address register */
int regPrev,            /* Previous result register.  No uniqueness if 0 */
KeyInfo *pKeyInfo,      /* For comparing with previous entry */
int iBreak              /* Jump here if we hit the LIMIT */
) location: 2912 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 2913 cross_layer: 5 file: select.c
addr = sqlite3VdbeCurrentAddr ( v ); location: 2917 cross_layer: 5 file: select.c
iContinue = sqlite3VdbeMakeLabel ( pParse ); location: 2918 cross_layer: 5 file: select.c
if ( regPrev )  location: 2922 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeAddOp1 ( v , OP_IfNot , regPrev ); location: 2924 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2924 cross_layer: 5 file: select.c
addr2 = sqlite3VdbeAddOp4 ( v , OP_Compare , pIn -> iSdst , regPrev + 1 , pIn -> nSdst , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 2925 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr2 + 2 , iContinue , addr2 + 2 ); location: 2927 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2927 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 2928 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , pIn -> iSdst , regPrev + 1 , pIn -> nSdst - 1 ); location: 2929 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regPrev ); location: 2930 cross_layer: 5 file: select.c
if ( pParse -> db -> mallocFailed )  location: 2932 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 2936 cross_layer: 5 file: select.c
assert ( pDest -> eDest != SRT_Exists ); location: 2938 cross_layer: 5 file: select.c
assert ( pDest -> eDest != SRT_Table ); location: 2939 cross_layer: 5 file: select.c
switch ( pDest -> eDest )  location: 2940 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 2944 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 2945 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 ); location: 2946 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , pDest -> iSDParm , r2 ); location: 2947 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , pDest -> iSDParm , r1 , r2 ); location: 2948 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 2949 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 2950 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2951 cross_layer: 5 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2960 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 2961 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 , pDest -> zAffSdst , pIn -> nSdst ); location: 2962 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , pDest -> iSDParm , r1 , pIn -> iSdst , pIn -> nSdst ); location: 2964 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2966 cross_layer: 5 file: select.c
if ( pParse -> nErr == 0 )  location: 2976 cross_layer: 5 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2977 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSDParm , pIn -> nSdst ); location: 2978 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 2989 cross_layer: 5 file: select.c
pDest -> iSdst = sqlite3GetTempRange ( pParse , pIn -> nSdst ); location: 2990 cross_layer: 5 file: select.c
pDest -> nSdst = pIn -> nSdst; location: 2991 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSdst , pIn -> nSdst ); location: 2993 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 2994 cross_layer: 5 file: select.c
assert ( pDest -> eDest == SRT_Output ); location: 3007 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pIn -> iSdst , pIn -> nSdst ); location: 3008 cross_layer: 5 file: select.c
if ( p -> iLimit )  location: 3015 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 3016 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3016 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iContinue ); location: 3021 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReturn ); location: 3022 cross_layer: 5 file: select.c
return addr ; location: 3024 cross_layer: 5 file: select.c
sqlite3KeyInfoUnref ( pKeyDup ); location: 3318 cross_layer: 4 file: select.c
void sqlite3KeyInfoUnref(KeyInfo *p) location: 1296 cross_layer: 5 file: select.c
if ( p )  location: 1297 cross_layer: 5 file: select.c
assert ( p -> nRef > 0 ); location: 1298 cross_layer: 5 file: select.c
p -> nRef --; location: 1299 cross_layer: 5 file: select.c
if ( p -> nRef == 0 )  location: 1300 cross_layer: 5 file: select.c
sqlite3DbFreeNN ( p -> db , p ); location: 1300 cross_layer: 5 file: select.c
addrEofA_noB = addrEofA = labelEnd; location: 3324 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "eof-A subroutine" ) ); location: 3326 cross_layer: 4 file: select.c
addrEofA = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutB , addrOutB ); location: 3327 cross_layer: 4 file: select.c
addrEofA_noB = sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , labelEnd ); location: 3328 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3329 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrEofA ); location: 3330 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 3331 cross_layer: 4 file: select.c
addrEofB = addrEofA; location: 3338 cross_layer: 4 file: select.c
if ( p -> nSelectRow > pPrior -> nSelectRow )  location: 3339 cross_layer: 4 file: select.c
p -> nSelectRow = pPrior -> nSelectRow; location: 3339 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "eof-B subroutine" ) ); location: 3341 cross_layer: 4 file: select.c
addrEofB = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutA , addrOutA ); location: 3342 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , labelEnd ); location: 3343 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3343 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrEofB ); location: 3344 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "A-lt-B subroutine" ) ); location: 3349 cross_layer: 4 file: select.c
addrAltB = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutA , addrOutA ); location: 3350 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA ); location: 3351 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3351 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3352 cross_layer: 4 file: select.c
addrAeqB = addrAltB; location: 3357 cross_layer: 4 file: select.c
addrAeqB = addrAltB; location: 3359 cross_layer: 4 file: select.c
addrAltB ++; location: 3360 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "A-eq-B subroutine" ) ); location: 3362 cross_layer: 4 file: select.c
addrAeqB = sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA ); location: 3363 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3364 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3365 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "A-gt-B subroutine" ) ); location: 3370 cross_layer: 4 file: select.c
addrAgtB = sqlite3VdbeCurrentAddr ( v ); location: 3371 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutB , addrOutB ); location: 3373 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , addrEofB ); location: 3375 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3375 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3376 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 3380 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA_noB ); location: 3381 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3381 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , addrEofB ); location: 3382 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3382 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , labelCmpr ); location: 3386 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Permutation , 0 , 0 , 0 , ( char * ) aPermute , P4_INTARRAY ); location: 3387 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , destA . iSdst , destB . iSdst , nOrderBy , ( char * ) pKeyMerge , P4_KEYINFO ); location: 3388 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_PERMUTE ); location: 3390 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addrAltB , addrAeqB , addrAgtB ); location: 3391 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3391 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , labelEnd ); location: 3395 cross_layer: 4 file: select.c
if ( p -> pPrior )  location: 3399 cross_layer: 4 file: select.c
sqlite3SelectDelete ( db , p -> pPrior ); location: 3400 cross_layer: 4 file: select.c
void sqlite3SelectDelete(sqlite3 *db, Select *p) location: 187 cross_layer: 5 file: select.c
if ( OK_IF_ALWAYS_TRUE ( p ) )  location: 188 cross_layer: 5 file: select.c
clearSelect ( db , p , 1 ); location: 188 cross_layer: 5 file: select.c
p -> pPrior = pPrior; location: 3402 cross_layer: 4 file: select.c
pPrior -> pNext = p; location: 3403 cross_layer: 4 file: select.c
ExplainQueryPlanPop ( pParse ); location: 3407 cross_layer: 4 file: select.c
return pParse -> nErr != 0 ; location: 3408 cross_layer: 4 file: select.c
------------------------------
14 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
rc = sqlite3Select ( pParse , p , & intersectdest ); location: 2772 cross_layer: 4 file: select.c
testcase ( rc != SQLITE_OK ); location: 2773 cross_layer: 4 file: select.c
return rc ; location: 2866 cross_layer: 4 file: select.c
------------------------------
15 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
rc = sqlite3Select ( pParse , pSetup , & destQueue ); location: 2389 cross_layer: 4 file: select.c
if ( rc )  location: 2391 cross_layer: 4 file: select.c
------------------------------
16 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 4 file: select.c
testcase ( rc != SQLITE_OK ); location: 2695 cross_layer: 4 file: select.c
if ( rc )  location: 2757 cross_layer: 4 file: select.c
testcase ( rc != SQLITE_OK ); location: 2773 cross_layer: 4 file: select.c
return rc ; location: 2866 cross_layer: 4 file: select.c
------------------------------
17 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 3 file: select.c
testcase ( rc != SQLITE_OK ); location: 2625 cross_layer: 3 file: select.c
if ( rc )  location: 2676 cross_layer: 3 file: select.c
testcase ( rc != SQLITE_OK ); location: 2695 cross_layer: 3 file: select.c
if ( rc )  location: 2757 cross_layer: 3 file: select.c
testcase ( rc != SQLITE_OK ); location: 2773 cross_layer: 3 file: select.c
return rc ; location: 2866 cross_layer: 3 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 4 file: select.c
return rc ; location: 5852 cross_layer: 4 file: select.c
------------------------------
18 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 3 file: select.c
if ( rc )  location: 2676 cross_layer: 3 file: select.c
testcase ( rc != SQLITE_OK ); location: 2695 cross_layer: 3 file: select.c
if ( rc )  location: 2757 cross_layer: 3 file: select.c
testcase ( rc != SQLITE_OK ); location: 2773 cross_layer: 3 file: select.c
return rc ; location: 2866 cross_layer: 3 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 4 file: select.c
return rc ; location: 5852 cross_layer: 4 file: select.c
------------------------------
19 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 3 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 3 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 3 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 3 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 3 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 3 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 3 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 3 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 3 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 3 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 3 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 3 file: select.c
static struct SrcList_item *isSelfJoinView(
SrcList *pTabList,           /* Search for self-joins in this FROM clause */
struct SrcList_item *pThis   /* Search for prior reference to this subquery */
) location: 5543 cross_layer: 4 file: select.c
for(pItem = pTabList->a; pItem<pThis; pItem++) location: 5545 cross_layer: 4 file: select.c
if ( pItem -> pSelect == 0 )  location: 5547 cross_layer: 4 file: select.c
if ( pItem -> fg . viaCoroutine )  location: 5548 cross_layer: 4 file: select.c
if ( pItem -> zName == 0 )  location: 5549 cross_layer: 4 file: select.c
assert ( pItem -> pTab != 0 ); location: 5550 cross_layer: 4 file: select.c
assert ( pThis -> pTab != 0 ); location: 5551 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema != pThis -> pTab -> pSchema )  location: 5552 cross_layer: 4 file: select.c
if ( sqlite3_stricmp ( pItem -> zName , pThis -> zName ) != 0 )  location: 5553 cross_layer: 4 file: select.c
pS1 = pItem -> pSelect; location: 5554 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema == 0 && pThis -> pSelect -> selId != pS1 -> selId )  location: 5555 cross_layer: 4 file: select.c
if ( sqlite3ExprCompare ( 0 , pThis -> pSelect -> pWhere , pS1 -> pWhere , - 1 ) || sqlite3ExprCompare ( 0 , pThis -> pSelect -> pHaving , pS1 -> pHaving , - 1 ) )  location: 5560 cross_layer: 4 file: select.c
return pItem ; location: 5567 cross_layer: 4 file: select.c
if ( pPrior )  location: 6023 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 3 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 3 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 3 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 3 file: select.c
void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm) location: 115 cross_layer: 4 file: select.c
pDest -> eDest = ( u8 ) eDest; location: 116 cross_layer: 4 file: select.c
pDest -> iSDParm = iParm; location: 117 cross_layer: 4 file: select.c
pDest -> zAffSdst = 0; location: 118 cross_layer: 4 file: select.c
pDest -> iSdst = 0; location: 119 cross_layer: 4 file: select.c
pDest -> nSdst = 0; location: 120 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 3 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 4 file: select.c
if ( rc )  location: 2757 cross_layer: 4 file: select.c
testcase ( rc != SQLITE_OK ); location: 2773 cross_layer: 4 file: select.c
return rc ; location: 2866 cross_layer: 4 file: select.c
------------------------------
20 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 3 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 3 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 3 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 3 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 3 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 3 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 3 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 3 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 3 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 3 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 3 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 3 file: select.c
static struct SrcList_item *isSelfJoinView(
SrcList *pTabList,           /* Search for self-joins in this FROM clause */
struct SrcList_item *pThis   /* Search for prior reference to this subquery */
) location: 5543 cross_layer: 4 file: select.c
for(pItem = pTabList->a; pItem<pThis; pItem++) location: 5545 cross_layer: 4 file: select.c
if ( pItem -> pSelect == 0 )  location: 5547 cross_layer: 4 file: select.c
if ( pItem -> fg . viaCoroutine )  location: 5548 cross_layer: 4 file: select.c
if ( pItem -> zName == 0 )  location: 5549 cross_layer: 4 file: select.c
assert ( pItem -> pTab != 0 ); location: 5550 cross_layer: 4 file: select.c
assert ( pThis -> pTab != 0 ); location: 5551 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema != pThis -> pTab -> pSchema )  location: 5552 cross_layer: 4 file: select.c
if ( sqlite3_stricmp ( pItem -> zName , pThis -> zName ) != 0 )  location: 5553 cross_layer: 4 file: select.c
pS1 = pItem -> pSelect; location: 5554 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema == 0 && pThis -> pSelect -> selId != pS1 -> selId )  location: 5555 cross_layer: 4 file: select.c
if ( sqlite3ExprCompare ( 0 , pThis -> pSelect -> pWhere , pS1 -> pWhere , - 1 ) || sqlite3ExprCompare ( 0 , pThis -> pSelect -> pHaving , pS1 -> pHaving , - 1 ) )  location: 5560 cross_layer: 4 file: select.c
return pItem ; location: 5567 cross_layer: 4 file: select.c
if ( pPrior )  location: 6023 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 3 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 3 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 3 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 3 file: select.c
void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm) location: 115 cross_layer: 4 file: select.c
pDest -> eDest = ( u8 ) eDest; location: 116 cross_layer: 4 file: select.c
pDest -> iSDParm = iParm; location: 117 cross_layer: 4 file: select.c
pDest -> zAffSdst = 0; location: 118 cross_layer: 4 file: select.c
pDest -> iSdst = 0; location: 119 cross_layer: 4 file: select.c
pDest -> nSdst = 0; location: 120 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 3 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
sqlite3Select ( pParse , p , & destQueue ); location: 2424 cross_layer: 4 file: select.c
assert ( p -> pPrior == 0 ); location: 2425 cross_layer: 4 file: select.c
p -> pPrior = pSetup; location: 2426 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrTop ); location: 2430 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 2431 cross_layer: 4 file: select.c
sqlite3ExprListDelete ( pParse -> db , p -> pOrderBy ); location: 2434 cross_layer: 4 file: select.c
p -> pOrderBy = pOrderBy; location: 2435 cross_layer: 4 file: select.c
p -> pLimit = pLimit; location: 2436 cross_layer: 4 file: select.c
------------------------------
21 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 3 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 3 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 3 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 3 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 3 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 3 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 3 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 3 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 3 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 3 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 3 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 3 file: select.c
static struct SrcList_item *isSelfJoinView(
SrcList *pTabList,           /* Search for self-joins in this FROM clause */
struct SrcList_item *pThis   /* Search for prior reference to this subquery */
) location: 5543 cross_layer: 4 file: select.c
for(pItem = pTabList->a; pItem<pThis; pItem++) location: 5545 cross_layer: 4 file: select.c
if ( pItem -> pSelect == 0 )  location: 5547 cross_layer: 4 file: select.c
if ( pItem -> fg . viaCoroutine )  location: 5548 cross_layer: 4 file: select.c
if ( pItem -> zName == 0 )  location: 5549 cross_layer: 4 file: select.c
assert ( pItem -> pTab != 0 ); location: 5550 cross_layer: 4 file: select.c
assert ( pThis -> pTab != 0 ); location: 5551 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema != pThis -> pTab -> pSchema )  location: 5552 cross_layer: 4 file: select.c
if ( sqlite3_stricmp ( pItem -> zName , pThis -> zName ) != 0 )  location: 5553 cross_layer: 4 file: select.c
pS1 = pItem -> pSelect; location: 5554 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema == 0 && pThis -> pSelect -> selId != pS1 -> selId )  location: 5555 cross_layer: 4 file: select.c
if ( sqlite3ExprCompare ( 0 , pThis -> pSelect -> pWhere , pS1 -> pWhere , - 1 ) || sqlite3ExprCompare ( 0 , pThis -> pSelect -> pHaving , pS1 -> pHaving , - 1 ) )  location: 5560 cross_layer: 4 file: select.c
return pItem ; location: 5567 cross_layer: 4 file: select.c
if ( pPrior )  location: 6023 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 3 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 3 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 3 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 3 file: select.c
void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm) location: 115 cross_layer: 4 file: select.c
pDest -> eDest = ( u8 ) eDest; location: 116 cross_layer: 4 file: select.c
pDest -> iSDParm = iParm; location: 117 cross_layer: 4 file: select.c
pDest -> zAffSdst = 0; location: 118 cross_layer: 4 file: select.c
pDest -> iSdst = 0; location: 119 cross_layer: 4 file: select.c
pDest -> nSdst = 0; location: 120 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 3 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 4 file: select.c
if ( rc )  location: 2609 cross_layer: 4 file: select.c
return rc ; location: 2866 cross_layer: 4 file: select.c
------------------------------
22 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 3 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 3 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 3 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 3 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 3 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 3 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 3 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 3 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 3 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 3 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 3 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 3 file: select.c
static struct SrcList_item *isSelfJoinView(
SrcList *pTabList,           /* Search for self-joins in this FROM clause */
struct SrcList_item *pThis   /* Search for prior reference to this subquery */
) location: 5543 cross_layer: 4 file: select.c
for(pItem = pTabList->a; pItem<pThis; pItem++) location: 5545 cross_layer: 4 file: select.c
if ( pItem -> pSelect == 0 )  location: 5547 cross_layer: 4 file: select.c
if ( pItem -> fg . viaCoroutine )  location: 5548 cross_layer: 4 file: select.c
if ( pItem -> zName == 0 )  location: 5549 cross_layer: 4 file: select.c
assert ( pItem -> pTab != 0 ); location: 5550 cross_layer: 4 file: select.c
assert ( pThis -> pTab != 0 ); location: 5551 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema != pThis -> pTab -> pSchema )  location: 5552 cross_layer: 4 file: select.c
if ( sqlite3_stricmp ( pItem -> zName , pThis -> zName ) != 0 )  location: 5553 cross_layer: 4 file: select.c
pS1 = pItem -> pSelect; location: 5554 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema == 0 && pThis -> pSelect -> selId != pS1 -> selId )  location: 5555 cross_layer: 4 file: select.c
if ( sqlite3ExprCompare ( 0 , pThis -> pSelect -> pWhere , pS1 -> pWhere , - 1 ) || sqlite3ExprCompare ( 0 , pThis -> pSelect -> pHaving , pS1 -> pHaving , - 1 ) )  location: 5560 cross_layer: 4 file: select.c
return pItem ; location: 5567 cross_layer: 4 file: select.c
if ( pPrior )  location: 6023 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 3 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 3 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 3 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 3 file: select.c
void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm) location: 115 cross_layer: 4 file: select.c
pDest -> eDest = ( u8 ) eDest; location: 116 cross_layer: 4 file: select.c
pDest -> iSDParm = iParm; location: 117 cross_layer: 4 file: select.c
pDest -> zAffSdst = 0; location: 118 cross_layer: 4 file: select.c
pDest -> iSdst = 0; location: 119 cross_layer: 4 file: select.c
pDest -> nSdst = 0; location: 120 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 3 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
sqlite3Select ( pParse , p , & destB ); location: 3296 cross_layer: 4 file: select.c
p -> iLimit = savedLimit; location: 3297 cross_layer: 4 file: select.c
p -> iOffset = savedOffset; location: 3298 cross_layer: 4 file: select.c
sqlite3VdbeEndCoroutine ( v , regAddrB ); location: 3299 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "Output routine for A" ) ); location: 3304 cross_layer: 4 file: select.c
addrOutA = generateOutputSubroutine ( pParse , p , & destA , pDest , regOutA , regPrev , pKeyDup , labelEnd ); location: 3305 cross_layer: 4 file: select.c
static int generateOutputSubroutine(
Parse *pParse,          /* Parsing context */
Select *p,              /* The SELECT statement */
SelectDest *pIn,        /* Coroutine supplying data */
SelectDest *pDest,      /* Where to send the data */
int regReturn,          /* The return address register */
int regPrev,            /* Previous result register.  No uniqueness if 0 */
KeyInfo *pKeyInfo,      /* For comparing with previous entry */
int iBreak              /* Jump here if we hit the LIMIT */
) location: 2912 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 2913 cross_layer: 5 file: select.c
addr = sqlite3VdbeCurrentAddr ( v ); location: 2917 cross_layer: 5 file: select.c
iContinue = sqlite3VdbeMakeLabel ( pParse ); location: 2918 cross_layer: 5 file: select.c
if ( regPrev )  location: 2922 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeAddOp1 ( v , OP_IfNot , regPrev ); location: 2924 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2924 cross_layer: 5 file: select.c
addr2 = sqlite3VdbeAddOp4 ( v , OP_Compare , pIn -> iSdst , regPrev + 1 , pIn -> nSdst , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 2925 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr2 + 2 , iContinue , addr2 + 2 ); location: 2927 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2927 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 2928 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , pIn -> iSdst , regPrev + 1 , pIn -> nSdst - 1 ); location: 2929 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regPrev ); location: 2930 cross_layer: 5 file: select.c
if ( pParse -> db -> mallocFailed )  location: 2932 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 2936 cross_layer: 5 file: select.c
assert ( pDest -> eDest != SRT_Exists ); location: 2938 cross_layer: 5 file: select.c
assert ( pDest -> eDest != SRT_Table ); location: 2939 cross_layer: 5 file: select.c
switch ( pDest -> eDest )  location: 2940 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 2944 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 2945 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 ); location: 2946 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , pDest -> iSDParm , r2 ); location: 2947 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , pDest -> iSDParm , r1 , r2 ); location: 2948 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 2949 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 2950 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2951 cross_layer: 5 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2960 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 2961 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 , pDest -> zAffSdst , pIn -> nSdst ); location: 2962 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , pDest -> iSDParm , r1 , pIn -> iSdst , pIn -> nSdst ); location: 2964 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2966 cross_layer: 5 file: select.c
if ( pParse -> nErr == 0 )  location: 2976 cross_layer: 5 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2977 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSDParm , pIn -> nSdst ); location: 2978 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 2989 cross_layer: 5 file: select.c
pDest -> iSdst = sqlite3GetTempRange ( pParse , pIn -> nSdst ); location: 2990 cross_layer: 5 file: select.c
pDest -> nSdst = pIn -> nSdst; location: 2991 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSdst , pIn -> nSdst ); location: 2993 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 2994 cross_layer: 5 file: select.c
assert ( pDest -> eDest == SRT_Output ); location: 3007 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pIn -> iSdst , pIn -> nSdst ); location: 3008 cross_layer: 5 file: select.c
if ( p -> iLimit )  location: 3015 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 3016 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3016 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iContinue ); location: 3021 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReturn ); location: 3022 cross_layer: 5 file: select.c
return addr ; location: 3024 cross_layer: 5 file: select.c
if ( op == TK_ALL || op == TK_UNION )  location: 3312 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "Output routine for B" ) ); location: 3313 cross_layer: 4 file: select.c
addrOutB = generateOutputSubroutine ( pParse , p , & destB , pDest , regOutB , regPrev , pKeyDup , labelEnd ); location: 3314 cross_layer: 4 file: select.c
static int generateOutputSubroutine(
Parse *pParse,          /* Parsing context */
Select *p,              /* The SELECT statement */
SelectDest *pIn,        /* Coroutine supplying data */
SelectDest *pDest,      /* Where to send the data */
int regReturn,          /* The return address register */
int regPrev,            /* Previous result register.  No uniqueness if 0 */
KeyInfo *pKeyInfo,      /* For comparing with previous entry */
int iBreak              /* Jump here if we hit the LIMIT */
) location: 2912 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 2913 cross_layer: 5 file: select.c
addr = sqlite3VdbeCurrentAddr ( v ); location: 2917 cross_layer: 5 file: select.c
iContinue = sqlite3VdbeMakeLabel ( pParse ); location: 2918 cross_layer: 5 file: select.c
if ( regPrev )  location: 2922 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeAddOp1 ( v , OP_IfNot , regPrev ); location: 2924 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2924 cross_layer: 5 file: select.c
addr2 = sqlite3VdbeAddOp4 ( v , OP_Compare , pIn -> iSdst , regPrev + 1 , pIn -> nSdst , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 2925 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr2 + 2 , iContinue , addr2 + 2 ); location: 2927 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2927 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 2928 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , pIn -> iSdst , regPrev + 1 , pIn -> nSdst - 1 ); location: 2929 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regPrev ); location: 2930 cross_layer: 5 file: select.c
if ( pParse -> db -> mallocFailed )  location: 2932 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 2936 cross_layer: 5 file: select.c
assert ( pDest -> eDest != SRT_Exists ); location: 2938 cross_layer: 5 file: select.c
assert ( pDest -> eDest != SRT_Table ); location: 2939 cross_layer: 5 file: select.c
switch ( pDest -> eDest )  location: 2940 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 2944 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 2945 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 ); location: 2946 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , pDest -> iSDParm , r2 ); location: 2947 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , pDest -> iSDParm , r1 , r2 ); location: 2948 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 2949 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 2950 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2951 cross_layer: 5 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2960 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 2961 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 , pDest -> zAffSdst , pIn -> nSdst ); location: 2962 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , pDest -> iSDParm , r1 , pIn -> iSdst , pIn -> nSdst ); location: 2964 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2966 cross_layer: 5 file: select.c
if ( pParse -> nErr == 0 )  location: 2976 cross_layer: 5 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2977 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSDParm , pIn -> nSdst ); location: 2978 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 2989 cross_layer: 5 file: select.c
pDest -> iSdst = sqlite3GetTempRange ( pParse , pIn -> nSdst ); location: 2990 cross_layer: 5 file: select.c
pDest -> nSdst = pIn -> nSdst; location: 2991 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSdst , pIn -> nSdst ); location: 2993 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 2994 cross_layer: 5 file: select.c
assert ( pDest -> eDest == SRT_Output ); location: 3007 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pIn -> iSdst , pIn -> nSdst ); location: 3008 cross_layer: 5 file: select.c
if ( p -> iLimit )  location: 3015 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 3016 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3016 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iContinue ); location: 3021 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReturn ); location: 3022 cross_layer: 5 file: select.c
return addr ; location: 3024 cross_layer: 5 file: select.c
sqlite3KeyInfoUnref ( pKeyDup ); location: 3318 cross_layer: 4 file: select.c
void sqlite3KeyInfoUnref(KeyInfo *p) location: 1296 cross_layer: 5 file: select.c
if ( p )  location: 1297 cross_layer: 5 file: select.c
assert ( p -> nRef > 0 ); location: 1298 cross_layer: 5 file: select.c
p -> nRef --; location: 1299 cross_layer: 5 file: select.c
if ( p -> nRef == 0 )  location: 1300 cross_layer: 5 file: select.c
sqlite3DbFreeNN ( p -> db , p ); location: 1300 cross_layer: 5 file: select.c
if ( op == TK_EXCEPT || op == TK_INTERSECT )  location: 3323 cross_layer: 4 file: select.c
addrEofA_noB = addrEofA = labelEnd; location: 3324 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "eof-A subroutine" ) ); location: 3326 cross_layer: 4 file: select.c
addrEofA = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutB , addrOutB ); location: 3327 cross_layer: 4 file: select.c
addrEofA_noB = sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , labelEnd ); location: 3328 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3329 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrEofA ); location: 3330 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 3331 cross_layer: 4 file: select.c
if ( op == TK_INTERSECT )  location: 3337 cross_layer: 4 file: select.c
addrEofB = addrEofA; location: 3338 cross_layer: 4 file: select.c
if ( p -> nSelectRow > pPrior -> nSelectRow )  location: 3339 cross_layer: 4 file: select.c
p -> nSelectRow = pPrior -> nSelectRow; location: 3339 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "eof-B subroutine" ) ); location: 3341 cross_layer: 4 file: select.c
addrEofB = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutA , addrOutA ); location: 3342 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , labelEnd ); location: 3343 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3343 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrEofB ); location: 3344 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "A-lt-B subroutine" ) ); location: 3349 cross_layer: 4 file: select.c
addrAltB = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutA , addrOutA ); location: 3350 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA ); location: 3351 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3351 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3352 cross_layer: 4 file: select.c
if ( op == TK_ALL )  location: 3356 cross_layer: 4 file: select.c
addrAeqB = addrAltB; location: 3357 cross_layer: 4 file: select.c
if ( op == TK_INTERSECT )  location: 3358 cross_layer: 4 file: select.c
addrAeqB = addrAltB; location: 3359 cross_layer: 4 file: select.c
addrAltB ++; location: 3360 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "A-eq-B subroutine" ) ); location: 3362 cross_layer: 4 file: select.c
addrAeqB = sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA ); location: 3363 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3364 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3365 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "A-gt-B subroutine" ) ); location: 3370 cross_layer: 4 file: select.c
addrAgtB = sqlite3VdbeCurrentAddr ( v ); location: 3371 cross_layer: 4 file: select.c
if ( op == TK_ALL || op == TK_UNION )  location: 3372 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutB , addrOutB ); location: 3373 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , addrEofB ); location: 3375 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3375 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3376 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 3380 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA_noB ); location: 3381 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3381 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , addrEofB ); location: 3382 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3382 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , labelCmpr ); location: 3386 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Permutation , 0 , 0 , 0 , ( char * ) aPermute , P4_INTARRAY ); location: 3387 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , destA . iSdst , destB . iSdst , nOrderBy , ( char * ) pKeyMerge , P4_KEYINFO ); location: 3388 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_PERMUTE ); location: 3390 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addrAltB , addrAeqB , addrAgtB ); location: 3391 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3391 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , labelEnd ); location: 3395 cross_layer: 4 file: select.c
if ( p -> pPrior )  location: 3399 cross_layer: 4 file: select.c
sqlite3SelectDelete ( db , p -> pPrior ); location: 3400 cross_layer: 4 file: select.c
void sqlite3SelectDelete(sqlite3 *db, Select *p) location: 187 cross_layer: 5 file: select.c
if ( OK_IF_ALWAYS_TRUE ( p ) )  location: 188 cross_layer: 5 file: select.c
clearSelect ( db , p , 1 ); location: 188 cross_layer: 5 file: select.c
p -> pPrior = pPrior; location: 3402 cross_layer: 4 file: select.c
pPrior -> pNext = p; location: 3403 cross_layer: 4 file: select.c
ExplainQueryPlanPop ( pParse ); location: 3407 cross_layer: 4 file: select.c
return pParse -> nErr != 0 ; location: 3408 cross_layer: 4 file: select.c
------------------------------
23 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 3 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 3 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 3 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 3 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 3 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 3 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 3 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 3 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 3 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 3 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 3 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 3 file: select.c
static struct SrcList_item *isSelfJoinView(
SrcList *pTabList,           /* Search for self-joins in this FROM clause */
struct SrcList_item *pThis   /* Search for prior reference to this subquery */
) location: 5543 cross_layer: 4 file: select.c
for(pItem = pTabList->a; pItem<pThis; pItem++) location: 5545 cross_layer: 4 file: select.c
if ( pItem -> pSelect == 0 )  location: 5547 cross_layer: 4 file: select.c
if ( pItem -> fg . viaCoroutine )  location: 5548 cross_layer: 4 file: select.c
if ( pItem -> zName == 0 )  location: 5549 cross_layer: 4 file: select.c
assert ( pItem -> pTab != 0 ); location: 5550 cross_layer: 4 file: select.c
assert ( pThis -> pTab != 0 ); location: 5551 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema != pThis -> pTab -> pSchema )  location: 5552 cross_layer: 4 file: select.c
if ( sqlite3_stricmp ( pItem -> zName , pThis -> zName ) != 0 )  location: 5553 cross_layer: 4 file: select.c
pS1 = pItem -> pSelect; location: 5554 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema == 0 && pThis -> pSelect -> selId != pS1 -> selId )  location: 5555 cross_layer: 4 file: select.c
if ( sqlite3ExprCompare ( 0 , pThis -> pSelect -> pWhere , pS1 -> pWhere , - 1 ) || sqlite3ExprCompare ( 0 , pThis -> pSelect -> pHaving , pS1 -> pHaving , - 1 ) )  location: 5560 cross_layer: 4 file: select.c
return pItem ; location: 5567 cross_layer: 4 file: select.c
if ( pPrior )  location: 6023 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 3 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 3 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 3 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 3 file: select.c
void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm) location: 115 cross_layer: 4 file: select.c
pDest -> eDest = ( u8 ) eDest; location: 116 cross_layer: 4 file: select.c
pDest -> iSDParm = iParm; location: 117 cross_layer: 4 file: select.c
pDest -> zAffSdst = 0; location: 118 cross_layer: 4 file: select.c
pDest -> iSdst = 0; location: 119 cross_layer: 4 file: select.c
pDest -> nSdst = 0; location: 120 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 3 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 4 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 4 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 4 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 4 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 4 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 4 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 4 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 4 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 4 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 4 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 4 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 4 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 4 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 4 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 5 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 5 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 5 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 5 file: select.c
if ( pInfo )  location: 1353 cross_layer: 5 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 5 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 5 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 5 file: select.c
return pInfo ; location: 1360 cross_layer: 5 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 4 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 4 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 4 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 4 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 4 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 4 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 5 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 5 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 5 file: select.c
if ( pLimit )  location: 2168 cross_layer: 5 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 5 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 5 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 5 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 5 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 5 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 5 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 5 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 5 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 5 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 5 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 5 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 5 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 5 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 4 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 4 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 4 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 4 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 4 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 4 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 5 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 5 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 5 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 5 file: select.c
if ( pInfo )  location: 1353 cross_layer: 5 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 5 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 5 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 5 file: select.c
return pInfo ; location: 1360 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 4 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 4 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 4 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 4 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 4 file: select.c
if ( pWin )  location: 6154 cross_layer: 4 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 4 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 4 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 4 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 4 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 4 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 4 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 4 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 4 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 4 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 4 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 4 file: select.c
if ( pWin )  location: 6190 cross_layer: 4 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 4 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 4 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 4 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 4 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 4 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 4 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 4 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 5 file: select.c
assert ( v ); location: 887 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 5 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 5 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 5 file: select.c
pSort = 0; location: 890 cross_layer: 5 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 5 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 5 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 5 file: select.c
if ( pSort )  location: 901 cross_layer: 5 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 5 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 5 file: select.c
nPrefixReg ++; location: 903 cross_layer: 5 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 5 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 5 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 5 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 5 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 5 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 5 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 5 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 5 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 5 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 5 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 5 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 5 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 5 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 5 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 5 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 5 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 5 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 5 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 5 file: select.c
nResultCol --; location: 976 cross_layer: 5 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 5 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 5 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 5 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 5 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 5 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 5 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 5 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 5 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 5 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 5 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 5 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 5 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 5 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 5 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 5 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 5 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 5 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 5 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 5 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 5 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 5 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 5 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 5 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 5 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 5 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 5 file: select.c
switch ( eDest )  location: 1072 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 5 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 5 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 5 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 5 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 5 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 5 file: select.c
if ( pSort )  location: 1122 cross_layer: 5 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 5 file: select.c
if ( pSort )  location: 1142 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 5 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 5 file: select.c
if ( pSort )  location: 1173 cross_layer: 5 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 5 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 5 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 5 file: select.c
if ( pSort )  location: 1190 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 5 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 5 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 5 file: select.c
assert ( pSO ); location: 1215 cross_layer: 5 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 5 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 5 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 5 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 5 file: select.c
if ( addrTest )  location: 1241 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 5 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 5 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 4 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 4 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 4 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 5 file: select.c
assert ( v ); location: 887 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 5 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 5 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 5 file: select.c
pSort = 0; location: 890 cross_layer: 5 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 5 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 5 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 5 file: select.c
if ( pSort )  location: 901 cross_layer: 5 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 5 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 5 file: select.c
nPrefixReg ++; location: 903 cross_layer: 5 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 5 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 5 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 5 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 5 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 5 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 5 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 5 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 5 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 5 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 5 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 5 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 5 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 5 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 5 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 5 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 5 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 5 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 5 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 5 file: select.c
nResultCol --; location: 976 cross_layer: 5 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 5 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 5 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 5 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 5 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 5 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 5 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 5 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 5 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 5 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 5 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 5 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 5 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 5 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 5 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 5 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 5 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 5 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 5 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 5 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 5 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 5 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 5 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 5 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 5 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 5 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 5 file: select.c
switch ( eDest )  location: 1072 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 5 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 5 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 5 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 5 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 5 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 5 file: select.c
if ( pSort )  location: 1122 cross_layer: 5 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 5 file: select.c
if ( pSort )  location: 1142 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 5 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 5 file: select.c
if ( pSort )  location: 1173 cross_layer: 5 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 5 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 5 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 5 file: select.c
if ( pSort )  location: 1190 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 5 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 5 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 5 file: select.c
assert ( pSO ); location: 1215 cross_layer: 5 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 5 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 5 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 5 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 5 file: select.c
if ( addrTest )  location: 1241 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 5 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 5 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 4 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 4 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 4 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 4 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 4 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 4 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 4 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 4 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 4 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 4 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 4 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 4 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 4 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 4 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 4 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 4 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 4 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 4 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 4 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 4 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 4 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 4 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 4 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 5 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 5 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 5 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 5 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 5 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 4 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 4 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 4 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 4 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 4 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 5 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 5 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 5 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 5 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 5 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 5 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 5 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 5 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 5 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 5 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 5 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 5 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 4 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 4 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 4 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 4 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 4 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 4 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 4 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 4 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 4 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 4 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 4 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 4 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 4 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 4 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 4 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 5 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 5 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 5 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 5 file: select.c
if ( pInfo )  location: 1353 cross_layer: 5 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 5 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 5 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 5 file: select.c
return pInfo ; location: 1360 cross_layer: 5 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 4 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 4 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 4 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 4 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 4 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 4 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 4 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 4 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 4 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 4 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 4 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 4 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 4 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 4 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 4 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 4 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 4 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 5 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 4 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 4 file: select.c
j = nGroupBy; location: 6422 cross_layer: 4 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 4 file: select.c
nCol ++; location: 6425 cross_layer: 4 file: select.c
j ++; location: 6426 cross_layer: 4 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 4 file: select.c
j = nGroupBy; location: 6431 cross_layer: 4 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 4 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 4 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 4 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 4 file: select.c
j ++; location: 6438 cross_layer: 4 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 4 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 4 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 4 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 4 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 4 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 4 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 4 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 4 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 5 file: select.c
if ( p )  location: 1308 cross_layer: 5 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 5 file: select.c
p -> nRef ++; location: 1310 cross_layer: 5 file: select.c
return p ; location: 1312 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 4 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 4 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 4 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 4 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 4 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 4 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 5 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 5 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 5 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 5 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 5 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 5 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 5 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 5 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 5 file: select.c
if ( pList )  location: 5398 cross_layer: 5 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 5 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 5 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 5 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 5 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 5 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 5 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 5 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 5 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 5 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 5 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 5 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 5 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 5 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 5 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 5 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 5 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 5 file: select.c
if ( addrNext )  location: 5432 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 5 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 5 file: select.c
regHit = regAcc; location: 5437 cross_layer: 5 file: select.c
if ( regHit )  location: 5439 cross_layer: 5 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 5 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 5 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 4 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 4 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 4 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 4 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 4 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 4 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 4 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 4 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 5 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 5 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 4 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 4 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 5 file: select.c
assert ( v ); location: 887 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 5 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 5 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 5 file: select.c
pSort = 0; location: 890 cross_layer: 5 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 5 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 5 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 5 file: select.c
if ( pSort )  location: 901 cross_layer: 5 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 5 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 5 file: select.c
nPrefixReg ++; location: 903 cross_layer: 5 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 5 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 5 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 5 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 5 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 5 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 5 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 5 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 5 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 5 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 5 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 5 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 5 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 5 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 5 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 5 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 5 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 5 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 5 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 5 file: select.c
nResultCol --; location: 976 cross_layer: 5 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 5 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 5 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 5 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 5 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 5 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 5 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 5 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 5 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 5 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 5 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 5 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 5 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 5 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 5 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 5 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 5 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 5 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 5 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 5 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 5 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 5 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 5 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 5 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 5 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 5 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 5 file: select.c
switch ( eDest )  location: 1072 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 5 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 5 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 5 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 5 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 5 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 5 file: select.c
if ( pSort )  location: 1122 cross_layer: 5 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 5 file: select.c
if ( pSort )  location: 1142 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 5 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 5 file: select.c
if ( pSort )  location: 1173 cross_layer: 5 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 5 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 5 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 5 file: select.c
if ( pSort )  location: 1190 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 5 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 5 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 5 file: select.c
assert ( pSO ); location: 1215 cross_layer: 5 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 5 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 5 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 5 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 5 file: select.c
if ( addrTest )  location: 1241 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 5 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 5 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 4 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 4 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 4 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 5 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 5 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 5 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 5 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 5 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 5 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 5 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 5 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 5 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 5 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 5 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 4 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 4 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 4 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 4 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 4 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 4 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 4 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 4 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 4 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 5 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 5 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 5 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 5 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 4 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 4 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 4 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 4 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 4 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 4 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 4 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 5 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 5 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 5 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 5 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 5 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 5 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 5 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 5 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 5 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 5 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 5 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 5 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 4 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 4 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 4 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 4 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 4 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 5 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 5 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 5 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 5 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 5 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 5 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 5 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 5 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 5 file: select.c
if ( pList )  location: 5398 cross_layer: 5 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 5 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 5 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 5 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 5 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 5 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 5 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 5 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 5 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 5 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 5 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 5 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 5 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 5 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 5 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 5 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 5 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 5 file: select.c
if ( addrNext )  location: 5432 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 5 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 5 file: select.c
regHit = regAcc; location: 5437 cross_layer: 5 file: select.c
if ( regHit )  location: 5439 cross_layer: 5 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 5 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 5 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 5 file: select.c
if ( regAcc )  location: 6676 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 4 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 4 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 4 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 5 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 5 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 4 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 4 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 5 file: select.c
assert ( v ); location: 887 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 5 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 5 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 5 file: select.c
pSort = 0; location: 890 cross_layer: 5 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 5 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 5 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 5 file: select.c
if ( pSort )  location: 901 cross_layer: 5 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 5 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 5 file: select.c
nPrefixReg ++; location: 903 cross_layer: 5 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 5 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 5 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 5 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 5 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 5 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 5 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 5 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 5 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 5 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 5 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 5 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 5 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 5 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 5 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 5 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 5 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 5 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 5 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 5 file: select.c
nResultCol --; location: 976 cross_layer: 5 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 5 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 5 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 5 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 5 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 5 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 5 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 5 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 5 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 5 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 5 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 5 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 5 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 5 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 5 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 5 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 5 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 5 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 5 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 5 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 5 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 5 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 5 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 5 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 5 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 5 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 5 file: select.c
switch ( eDest )  location: 1072 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 5 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 5 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 5 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 5 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 5 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 5 file: select.c
if ( pSort )  location: 1122 cross_layer: 5 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 5 file: select.c
if ( pSort )  location: 1142 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 5 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 5 file: select.c
if ( pSort )  location: 1173 cross_layer: 5 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 5 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 5 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 5 file: select.c
if ( pSort )  location: 1190 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 5 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 5 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 5 file: select.c
assert ( pSO ); location: 1215 cross_layer: 5 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 5 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 5 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 5 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 5 file: select.c
if ( addrTest )  location: 1241 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 5 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 5 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 4 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 4 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 4 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 4 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 4 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 4 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 4 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 5 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 5 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 5 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 5 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 5 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 5 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 5 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 5 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 5 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 5 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 5 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 5 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 5 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 5 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 5 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 5 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 5 file: select.c
nColumn = 0; location: 1465 cross_layer: 5 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 5 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 5 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 5 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 5 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 5 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 5 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 5 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 5 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 5 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 5 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 5 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 5 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 5 file: select.c
iCol ++; location: 1495 cross_layer: 5 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 5 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 5 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 5 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 5 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 5 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 5 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 5 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 5 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 5 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 5 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 5 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 5 file: select.c
iRead = iCol --; location: 1539 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 5 file: select.c
switch ( eDest )  location: 1545 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 5 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 5 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 5 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 5 file: select.c
if ( regRowid )  location: 1579 cross_layer: 5 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 5 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 5 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 4 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 4 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 4 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 4 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 4 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 4 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 4 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 4 file: select.c
return rc ; location: 6731 cross_layer: 4 file: select.c
------------------------------
24 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 3 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 3 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 3 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 3 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 3 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 3 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 3 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 3 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 3 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 3 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 3 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 3 file: select.c
static struct SrcList_item *isSelfJoinView(
SrcList *pTabList,           /* Search for self-joins in this FROM clause */
struct SrcList_item *pThis   /* Search for prior reference to this subquery */
) location: 5543 cross_layer: 4 file: select.c
for(pItem = pTabList->a; pItem<pThis; pItem++) location: 5545 cross_layer: 4 file: select.c
if ( pItem -> pSelect == 0 )  location: 5547 cross_layer: 4 file: select.c
if ( pItem -> fg . viaCoroutine )  location: 5548 cross_layer: 4 file: select.c
if ( pItem -> zName == 0 )  location: 5549 cross_layer: 4 file: select.c
assert ( pItem -> pTab != 0 ); location: 5550 cross_layer: 4 file: select.c
assert ( pThis -> pTab != 0 ); location: 5551 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema != pThis -> pTab -> pSchema )  location: 5552 cross_layer: 4 file: select.c
if ( sqlite3_stricmp ( pItem -> zName , pThis -> zName ) != 0 )  location: 5553 cross_layer: 4 file: select.c
pS1 = pItem -> pSelect; location: 5554 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema == 0 && pThis -> pSelect -> selId != pS1 -> selId )  location: 5555 cross_layer: 4 file: select.c
if ( sqlite3ExprCompare ( 0 , pThis -> pSelect -> pWhere , pS1 -> pWhere , - 1 ) || sqlite3ExprCompare ( 0 , pThis -> pSelect -> pHaving , pS1 -> pHaving , - 1 ) )  location: 5560 cross_layer: 4 file: select.c
return pItem ; location: 5567 cross_layer: 4 file: select.c
if ( pPrior )  location: 6023 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 3 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 3 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 3 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 3 file: select.c
void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm) location: 115 cross_layer: 4 file: select.c
pDest -> eDest = ( u8 ) eDest; location: 116 cross_layer: 4 file: select.c
pDest -> iSDParm = iParm; location: 117 cross_layer: 4 file: select.c
pDest -> zAffSdst = 0; location: 118 cross_layer: 4 file: select.c
pDest -> iSdst = 0; location: 119 cross_layer: 4 file: select.c
pDest -> nSdst = 0; location: 120 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 3 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 4 file: select.c
testcase ( rc != SQLITE_OK ); location: 2625 cross_layer: 4 file: select.c
if ( rc )  location: 2676 cross_layer: 4 file: select.c
testcase ( rc != SQLITE_OK ); location: 2695 cross_layer: 4 file: select.c
if ( rc )  location: 2757 cross_layer: 4 file: select.c
testcase ( rc != SQLITE_OK ); location: 2773 cross_layer: 4 file: select.c
return rc ; location: 2866 cross_layer: 4 file: select.c
------------------------------
25 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 3 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 3 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 3 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 3 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 3 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 3 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 3 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 3 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 3 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 3 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 3 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 3 file: select.c
static struct SrcList_item *isSelfJoinView(
SrcList *pTabList,           /* Search for self-joins in this FROM clause */
struct SrcList_item *pThis   /* Search for prior reference to this subquery */
) location: 5543 cross_layer: 4 file: select.c
for(pItem = pTabList->a; pItem<pThis; pItem++) location: 5545 cross_layer: 4 file: select.c
if ( pItem -> pSelect == 0 )  location: 5547 cross_layer: 4 file: select.c
if ( pItem -> fg . viaCoroutine )  location: 5548 cross_layer: 4 file: select.c
if ( pItem -> zName == 0 )  location: 5549 cross_layer: 4 file: select.c
assert ( pItem -> pTab != 0 ); location: 5550 cross_layer: 4 file: select.c
assert ( pThis -> pTab != 0 ); location: 5551 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema != pThis -> pTab -> pSchema )  location: 5552 cross_layer: 4 file: select.c
if ( sqlite3_stricmp ( pItem -> zName , pThis -> zName ) != 0 )  location: 5553 cross_layer: 4 file: select.c
pS1 = pItem -> pSelect; location: 5554 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema == 0 && pThis -> pSelect -> selId != pS1 -> selId )  location: 5555 cross_layer: 4 file: select.c
if ( sqlite3ExprCompare ( 0 , pThis -> pSelect -> pWhere , pS1 -> pWhere , - 1 ) || sqlite3ExprCompare ( 0 , pThis -> pSelect -> pHaving , pS1 -> pHaving , - 1 ) )  location: 5560 cross_layer: 4 file: select.c
return pItem ; location: 5567 cross_layer: 4 file: select.c
if ( pPrior )  location: 6023 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 3 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 3 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 3 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 3 file: select.c
void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm) location: 115 cross_layer: 4 file: select.c
pDest -> eDest = ( u8 ) eDest; location: 116 cross_layer: 4 file: select.c
pDest -> iSDParm = iParm; location: 117 cross_layer: 4 file: select.c
pDest -> zAffSdst = 0; location: 118 cross_layer: 4 file: select.c
pDest -> iSdst = 0; location: 119 cross_layer: 4 file: select.c
pDest -> nSdst = 0; location: 120 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 3 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 4 file: select.c
if ( rc )  location: 2676 cross_layer: 4 file: select.c
testcase ( rc != SQLITE_OK ); location: 2695 cross_layer: 4 file: select.c
if ( rc )  location: 2757 cross_layer: 4 file: select.c
testcase ( rc != SQLITE_OK ); location: 2773 cross_layer: 4 file: select.c
return rc ; location: 2866 cross_layer: 4 file: select.c
------------------------------
26 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 3 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 3 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 3 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 3 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 3 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 3 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 3 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 3 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 3 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 3 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 3 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 3 file: select.c
static struct SrcList_item *isSelfJoinView(
SrcList *pTabList,           /* Search for self-joins in this FROM clause */
struct SrcList_item *pThis   /* Search for prior reference to this subquery */
) location: 5543 cross_layer: 4 file: select.c
for(pItem = pTabList->a; pItem<pThis; pItem++) location: 5545 cross_layer: 4 file: select.c
if ( pItem -> pSelect == 0 )  location: 5547 cross_layer: 4 file: select.c
if ( pItem -> fg . viaCoroutine )  location: 5548 cross_layer: 4 file: select.c
if ( pItem -> zName == 0 )  location: 5549 cross_layer: 4 file: select.c
assert ( pItem -> pTab != 0 ); location: 5550 cross_layer: 4 file: select.c
assert ( pThis -> pTab != 0 ); location: 5551 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema != pThis -> pTab -> pSchema )  location: 5552 cross_layer: 4 file: select.c
if ( sqlite3_stricmp ( pItem -> zName , pThis -> zName ) != 0 )  location: 5553 cross_layer: 4 file: select.c
pS1 = pItem -> pSelect; location: 5554 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema == 0 && pThis -> pSelect -> selId != pS1 -> selId )  location: 5555 cross_layer: 4 file: select.c
if ( sqlite3ExprCompare ( 0 , pThis -> pSelect -> pWhere , pS1 -> pWhere , - 1 ) || sqlite3ExprCompare ( 0 , pThis -> pSelect -> pHaving , pS1 -> pHaving , - 1 ) )  location: 5560 cross_layer: 4 file: select.c
return pItem ; location: 5567 cross_layer: 4 file: select.c
if ( pPrior )  location: 6023 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 3 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 3 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 3 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 3 file: select.c
void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm) location: 115 cross_layer: 4 file: select.c
pDest -> eDest = ( u8 ) eDest; location: 116 cross_layer: 4 file: select.c
pDest -> iSDParm = iParm; location: 117 cross_layer: 4 file: select.c
pDest -> zAffSdst = 0; location: 118 cross_layer: 4 file: select.c
pDest -> iSdst = 0; location: 119 cross_layer: 4 file: select.c
pDest -> nSdst = 0; location: 120 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 3 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 4 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 4 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 4 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 4 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 4 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 4 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 4 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 4 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 4 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 4 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 4 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 4 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 4 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 4 file: select.c
static struct SrcList_item *isSelfJoinView(
SrcList *pTabList,           /* Search for self-joins in this FROM clause */
struct SrcList_item *pThis   /* Search for prior reference to this subquery */
) location: 5543 cross_layer: 5 file: select.c
if ( pItem -> pSelect == 0 )  location: 5547 cross_layer: 5 file: select.c
if ( pItem -> fg . viaCoroutine )  location: 5548 cross_layer: 5 file: select.c
if ( pItem -> zName == 0 )  location: 5549 cross_layer: 5 file: select.c
assert ( pItem -> pTab != 0 ); location: 5550 cross_layer: 5 file: select.c
assert ( pThis -> pTab != 0 ); location: 5551 cross_layer: 5 file: select.c
if ( pItem -> pTab -> pSchema != pThis -> pTab -> pSchema )  location: 5552 cross_layer: 5 file: select.c
if ( sqlite3_stricmp ( pItem -> zName , pThis -> zName ) != 0 )  location: 5553 cross_layer: 5 file: select.c
pS1 = pItem -> pSelect; location: 5554 cross_layer: 5 file: select.c
if ( pItem -> pTab -> pSchema == 0 && pThis -> pSelect -> selId != pS1 -> selId )  location: 5555 cross_layer: 5 file: select.c
if ( sqlite3ExprCompare ( 0 , pThis -> pSelect -> pWhere , pS1 -> pWhere , - 1 ) || sqlite3ExprCompare ( 0 , pThis -> pSelect -> pHaving , pS1 -> pHaving , - 1 ) )  location: 5560 cross_layer: 5 file: select.c
return pItem ; location: 5567 cross_layer: 5 file: select.c
if ( pPrior )  location: 6023 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 4 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 4 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 4 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 4 file: select.c
void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm) location: 115 cross_layer: 5 file: select.c
pDest -> eDest = ( u8 ) eDest; location: 116 cross_layer: 5 file: select.c
pDest -> iSDParm = iParm; location: 117 cross_layer: 5 file: select.c
pDest -> zAffSdst = 0; location: 118 cross_layer: 5 file: select.c
pDest -> iSdst = 0; location: 119 cross_layer: 5 file: select.c
pDest -> nSdst = 0; location: 120 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 4 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 4 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 4 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 4 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 4 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 4 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 4 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 4 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 4 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 4 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 4 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 4 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 4 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 4 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 4 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 5 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 5 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 5 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 5 file: select.c
if ( pInfo )  location: 1353 cross_layer: 5 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 5 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 5 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 5 file: select.c
return pInfo ; location: 1360 cross_layer: 5 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 4 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 4 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 4 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 4 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 4 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 4 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 5 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 5 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 5 file: select.c
if ( pLimit )  location: 2168 cross_layer: 5 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 5 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 5 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 5 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 5 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 5 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 5 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 5 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 5 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 5 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 5 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 5 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 5 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 5 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 4 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 4 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 4 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 4 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 4 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 4 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 5 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 5 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 5 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 5 file: select.c
if ( pInfo )  location: 1353 cross_layer: 5 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 5 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 5 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 5 file: select.c
return pInfo ; location: 1360 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 4 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 4 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 4 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 4 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 4 file: select.c
if ( pWin )  location: 6154 cross_layer: 4 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 4 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 4 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 4 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 4 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 4 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 4 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 4 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 4 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 4 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 4 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 4 file: select.c
if ( pWin )  location: 6190 cross_layer: 4 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 4 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 4 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 4 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 4 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 4 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 4 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 4 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 5 file: select.c
assert ( v ); location: 887 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 5 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 5 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 5 file: select.c
pSort = 0; location: 890 cross_layer: 5 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 5 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 5 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 5 file: select.c
if ( pSort )  location: 901 cross_layer: 5 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 5 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 5 file: select.c
nPrefixReg ++; location: 903 cross_layer: 5 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 5 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 5 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 5 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 5 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 5 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 5 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 5 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 5 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 5 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 5 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 5 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 5 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 5 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 5 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 5 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 5 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 5 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 5 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 5 file: select.c
nResultCol --; location: 976 cross_layer: 5 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 5 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 5 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 5 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 5 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 5 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 5 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 5 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 5 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 5 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 5 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 5 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 5 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 5 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 5 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 5 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 5 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 5 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 5 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 5 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 5 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 5 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 5 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 5 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 5 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 5 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 5 file: select.c
switch ( eDest )  location: 1072 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 5 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 5 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 5 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 5 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 5 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 5 file: select.c
if ( pSort )  location: 1122 cross_layer: 5 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 5 file: select.c
if ( pSort )  location: 1142 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 5 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 5 file: select.c
if ( pSort )  location: 1173 cross_layer: 5 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 5 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 5 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 5 file: select.c
if ( pSort )  location: 1190 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 5 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 5 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 5 file: select.c
assert ( pSO ); location: 1215 cross_layer: 5 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 5 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 5 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 5 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 5 file: select.c
if ( addrTest )  location: 1241 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 5 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 5 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 4 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 4 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 4 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 5 file: select.c
assert ( v ); location: 887 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 5 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 5 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 5 file: select.c
pSort = 0; location: 890 cross_layer: 5 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 5 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 5 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 5 file: select.c
if ( pSort )  location: 901 cross_layer: 5 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 5 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 5 file: select.c
nPrefixReg ++; location: 903 cross_layer: 5 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 5 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 5 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 5 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 5 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 5 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 5 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 5 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 5 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 5 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 5 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 5 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 5 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 5 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 5 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 5 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 5 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 5 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 5 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 5 file: select.c
nResultCol --; location: 976 cross_layer: 5 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 5 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 5 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 5 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 5 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 5 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 5 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 5 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 5 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 5 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 5 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 5 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 5 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 5 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 5 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 5 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 5 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 5 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 5 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 5 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 5 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 5 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 5 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 5 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 5 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 5 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 5 file: select.c
switch ( eDest )  location: 1072 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 5 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 5 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 5 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 5 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 5 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 5 file: select.c
if ( pSort )  location: 1122 cross_layer: 5 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 5 file: select.c
if ( pSort )  location: 1142 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 5 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 5 file: select.c
if ( pSort )  location: 1173 cross_layer: 5 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 5 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 5 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 5 file: select.c
if ( pSort )  location: 1190 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 5 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 5 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 5 file: select.c
assert ( pSO ); location: 1215 cross_layer: 5 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 5 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 5 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 5 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 5 file: select.c
if ( addrTest )  location: 1241 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 5 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 5 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 4 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 4 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 4 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 4 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 4 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 4 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 4 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 4 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 4 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 4 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 4 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 4 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 4 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 4 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 4 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 4 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 4 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 4 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 4 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 4 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 4 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 4 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 4 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 5 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 5 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 5 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 5 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 5 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 4 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 4 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 4 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 4 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 4 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 5 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 5 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 5 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 5 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 5 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 5 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 5 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 5 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 5 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 5 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 5 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 5 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 4 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 4 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 4 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 4 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 4 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 4 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 4 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 4 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 4 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 4 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 4 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 4 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 4 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 4 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 4 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 5 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 5 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 5 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 5 file: select.c
if ( pInfo )  location: 1353 cross_layer: 5 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 5 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 5 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 5 file: select.c
return pInfo ; location: 1360 cross_layer: 5 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 4 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 4 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 4 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 4 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 4 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 4 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 4 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 4 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 4 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 4 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 4 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 4 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 4 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 4 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 4 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 4 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 4 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 5 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 4 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 4 file: select.c
j = nGroupBy; location: 6422 cross_layer: 4 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 4 file: select.c
nCol ++; location: 6425 cross_layer: 4 file: select.c
j ++; location: 6426 cross_layer: 4 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 4 file: select.c
j = nGroupBy; location: 6431 cross_layer: 4 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 4 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 4 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 4 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 4 file: select.c
j ++; location: 6438 cross_layer: 4 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 4 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 4 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 4 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 4 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 4 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 4 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 4 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 4 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 5 file: select.c
if ( p )  location: 1308 cross_layer: 5 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 5 file: select.c
p -> nRef ++; location: 1310 cross_layer: 5 file: select.c
return p ; location: 1312 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 4 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 4 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 4 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 4 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 4 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 4 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 5 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 5 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 5 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 5 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 5 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 5 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 5 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 5 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 5 file: select.c
if ( pList )  location: 5398 cross_layer: 5 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 5 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 5 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 5 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 5 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 5 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 5 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 5 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 5 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 5 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 5 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 5 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 5 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 5 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 5 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 5 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 5 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 5 file: select.c
if ( addrNext )  location: 5432 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 5 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 5 file: select.c
regHit = regAcc; location: 5437 cross_layer: 5 file: select.c
if ( regHit )  location: 5439 cross_layer: 5 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 5 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 5 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 4 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 4 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 4 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 4 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 4 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 4 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 4 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 4 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 5 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 5 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 4 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 4 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 5 file: select.c
assert ( v ); location: 887 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 5 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 5 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 5 file: select.c
pSort = 0; location: 890 cross_layer: 5 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 5 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 5 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 5 file: select.c
if ( pSort )  location: 901 cross_layer: 5 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 5 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 5 file: select.c
nPrefixReg ++; location: 903 cross_layer: 5 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 5 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 5 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 5 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 5 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 5 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 5 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 5 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 5 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 5 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 5 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 5 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 5 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 5 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 5 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 5 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 5 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 5 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 5 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 5 file: select.c
nResultCol --; location: 976 cross_layer: 5 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 5 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 5 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 5 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 5 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 5 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 5 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 5 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 5 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 5 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 5 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 5 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 5 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 5 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 5 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 5 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 5 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 5 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 5 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 5 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 5 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 5 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 5 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 5 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 5 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 5 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 5 file: select.c
switch ( eDest )  location: 1072 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 5 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 5 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 5 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 5 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 5 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 5 file: select.c
if ( pSort )  location: 1122 cross_layer: 5 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 5 file: select.c
if ( pSort )  location: 1142 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 5 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 5 file: select.c
if ( pSort )  location: 1173 cross_layer: 5 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 5 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 5 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 5 file: select.c
if ( pSort )  location: 1190 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 5 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 5 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 5 file: select.c
assert ( pSO ); location: 1215 cross_layer: 5 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 5 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 5 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 5 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 5 file: select.c
if ( addrTest )  location: 1241 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 5 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 5 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 4 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 4 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 4 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 5 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 5 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 5 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 5 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 5 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 5 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 5 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 5 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 5 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 5 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 5 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 4 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 4 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 4 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 4 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 4 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 4 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 4 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 4 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 4 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 5 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 5 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 5 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 5 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 4 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 4 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 4 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 4 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 4 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 4 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 4 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 5 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 5 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 5 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 5 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 5 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 5 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 5 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 5 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 5 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 5 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 5 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 5 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 4 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 4 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 4 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 4 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 4 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 5 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 5 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 5 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 5 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 5 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 5 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 5 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 5 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 5 file: select.c
if ( pList )  location: 5398 cross_layer: 5 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 5 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 5 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 5 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 5 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 5 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 5 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 5 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 5 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 5 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 5 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 5 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 5 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 5 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 5 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 5 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 5 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 5 file: select.c
if ( addrNext )  location: 5432 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 5 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 5 file: select.c
regHit = regAcc; location: 5437 cross_layer: 5 file: select.c
if ( regHit )  location: 5439 cross_layer: 5 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 5 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 5 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 5 file: select.c
if ( regAcc )  location: 6676 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 4 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 4 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 4 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 5 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 5 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 4 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 4 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 5 file: select.c
assert ( v ); location: 887 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 5 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 5 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 5 file: select.c
pSort = 0; location: 890 cross_layer: 5 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 5 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 5 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 5 file: select.c
if ( pSort )  location: 901 cross_layer: 5 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 5 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 5 file: select.c
nPrefixReg ++; location: 903 cross_layer: 5 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 5 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 5 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 5 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 5 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 5 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 5 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 5 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 5 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 5 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 5 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 5 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 5 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 5 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 5 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 5 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 5 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 5 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 5 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 5 file: select.c
nResultCol --; location: 976 cross_layer: 5 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 5 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 5 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 5 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 5 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 5 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 5 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 5 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 5 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 5 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 5 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 5 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 5 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 5 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 5 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 5 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 5 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 5 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 5 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 5 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 5 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 5 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 5 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 5 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 5 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 5 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 5 file: select.c
switch ( eDest )  location: 1072 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 5 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 5 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 5 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 5 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 5 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 5 file: select.c
if ( pSort )  location: 1122 cross_layer: 5 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 5 file: select.c
if ( pSort )  location: 1142 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 5 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 5 file: select.c
if ( pSort )  location: 1173 cross_layer: 5 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 5 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 5 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 5 file: select.c
if ( pSort )  location: 1190 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 5 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 5 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 5 file: select.c
assert ( pSO ); location: 1215 cross_layer: 5 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 5 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 5 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 5 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 5 file: select.c
if ( addrTest )  location: 1241 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 5 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 5 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 4 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 4 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 4 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 4 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 4 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 4 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 4 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 5 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 5 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 5 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 5 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 5 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 5 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 5 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 5 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 5 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 5 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 5 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 5 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 5 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 5 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 5 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 5 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 5 file: select.c
nColumn = 0; location: 1465 cross_layer: 5 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 5 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 5 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 5 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 5 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 5 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 5 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 5 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 5 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 5 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 5 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 5 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 5 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 5 file: select.c
iCol ++; location: 1495 cross_layer: 5 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 5 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 5 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 5 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 5 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 5 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 5 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 5 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 5 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 5 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 5 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 5 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 5 file: select.c
iRead = iCol --; location: 1539 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 5 file: select.c
switch ( eDest )  location: 1545 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 5 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 5 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 5 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 5 file: select.c
if ( regRowid )  location: 1579 cross_layer: 5 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 5 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 5 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 4 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 4 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 4 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 4 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 4 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 4 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 4 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 4 file: select.c
return rc ; location: 6731 cross_layer: 4 file: select.c
------------------------------
27 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 3 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 3 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 3 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 3 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 3 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 3 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 3 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 3 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 3 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 3 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 3 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 3 file: select.c
static struct SrcList_item *isSelfJoinView(
SrcList *pTabList,           /* Search for self-joins in this FROM clause */
struct SrcList_item *pThis   /* Search for prior reference to this subquery */
) location: 5543 cross_layer: 4 file: select.c
for(pItem = pTabList->a; pItem<pThis; pItem++) location: 5545 cross_layer: 4 file: select.c
if ( pItem -> pSelect == 0 )  location: 5547 cross_layer: 4 file: select.c
if ( pItem -> fg . viaCoroutine )  location: 5548 cross_layer: 4 file: select.c
if ( pItem -> zName == 0 )  location: 5549 cross_layer: 4 file: select.c
assert ( pItem -> pTab != 0 ); location: 5550 cross_layer: 4 file: select.c
assert ( pThis -> pTab != 0 ); location: 5551 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema != pThis -> pTab -> pSchema )  location: 5552 cross_layer: 4 file: select.c
if ( sqlite3_stricmp ( pItem -> zName , pThis -> zName ) != 0 )  location: 5553 cross_layer: 4 file: select.c
pS1 = pItem -> pSelect; location: 5554 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema == 0 && pThis -> pSelect -> selId != pS1 -> selId )  location: 5555 cross_layer: 4 file: select.c
if ( sqlite3ExprCompare ( 0 , pThis -> pSelect -> pWhere , pS1 -> pWhere , - 1 ) || sqlite3ExprCompare ( 0 , pThis -> pSelect -> pHaving , pS1 -> pHaving , - 1 ) )  location: 5560 cross_layer: 4 file: select.c
return pItem ; location: 5567 cross_layer: 4 file: select.c
if ( pPrior )  location: 6023 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 3 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 3 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 3 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 3 file: select.c
void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm) location: 115 cross_layer: 4 file: select.c
pDest -> eDest = ( u8 ) eDest; location: 116 cross_layer: 4 file: select.c
pDest -> iSDParm = iParm; location: 117 cross_layer: 4 file: select.c
pDest -> zAffSdst = 0; location: 118 cross_layer: 4 file: select.c
pDest -> iSdst = 0; location: 119 cross_layer: 4 file: select.c
pDest -> nSdst = 0; location: 120 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 3 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
sqlite3Select ( pParse , pPrior , & destA ); location: 3281 cross_layer: 4 file: select.c
sqlite3VdbeEndCoroutine ( v , regAddrA ); location: 3282 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 3283 cross_layer: 4 file: select.c
addrSelectB = sqlite3VdbeCurrentAddr ( v ) + 1; location: 3288 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeAddOp3 ( v , OP_InitCoroutine , regAddrB , 0 , addrSelectB ); location: 3289 cross_layer: 4 file: select.c
VdbeComment ( ( v , "right SELECT" ) ); location: 3290 cross_layer: 4 file: select.c
savedLimit = p -> iLimit; location: 3291 cross_layer: 4 file: select.c
savedOffset = p -> iOffset; location: 3292 cross_layer: 4 file: select.c
p -> iLimit = regLimitB; location: 3293 cross_layer: 4 file: select.c
p -> iOffset = 0; location: 3294 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "RIGHT" ) ); location: 3295 cross_layer: 4 file: select.c
sqlite3Select ( pParse , p , & destB ); location: 3296 cross_layer: 4 file: select.c
p -> iLimit = savedLimit; location: 3297 cross_layer: 4 file: select.c
p -> iOffset = savedOffset; location: 3298 cross_layer: 4 file: select.c
sqlite3VdbeEndCoroutine ( v , regAddrB ); location: 3299 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "Output routine for A" ) ); location: 3304 cross_layer: 4 file: select.c
addrOutA = generateOutputSubroutine ( pParse , p , & destA , pDest , regOutA , regPrev , pKeyDup , labelEnd ); location: 3305 cross_layer: 4 file: select.c
static int generateOutputSubroutine(
Parse *pParse,          /* Parsing context */
Select *p,              /* The SELECT statement */
SelectDest *pIn,        /* Coroutine supplying data */
SelectDest *pDest,      /* Where to send the data */
int regReturn,          /* The return address register */
int regPrev,            /* Previous result register.  No uniqueness if 0 */
KeyInfo *pKeyInfo,      /* For comparing with previous entry */
int iBreak              /* Jump here if we hit the LIMIT */
) location: 2912 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 2913 cross_layer: 5 file: select.c
addr = sqlite3VdbeCurrentAddr ( v ); location: 2917 cross_layer: 5 file: select.c
iContinue = sqlite3VdbeMakeLabel ( pParse ); location: 2918 cross_layer: 5 file: select.c
if ( regPrev )  location: 2922 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeAddOp1 ( v , OP_IfNot , regPrev ); location: 2924 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2924 cross_layer: 5 file: select.c
addr2 = sqlite3VdbeAddOp4 ( v , OP_Compare , pIn -> iSdst , regPrev + 1 , pIn -> nSdst , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 2925 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr2 + 2 , iContinue , addr2 + 2 ); location: 2927 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2927 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 2928 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , pIn -> iSdst , regPrev + 1 , pIn -> nSdst - 1 ); location: 2929 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regPrev ); location: 2930 cross_layer: 5 file: select.c
if ( pParse -> db -> mallocFailed )  location: 2932 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 2936 cross_layer: 5 file: select.c
assert ( pDest -> eDest != SRT_Exists ); location: 2938 cross_layer: 5 file: select.c
assert ( pDest -> eDest != SRT_Table ); location: 2939 cross_layer: 5 file: select.c
switch ( pDest -> eDest )  location: 2940 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 2944 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 2945 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 ); location: 2946 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , pDest -> iSDParm , r2 ); location: 2947 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , pDest -> iSDParm , r1 , r2 ); location: 2948 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 2949 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 2950 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2951 cross_layer: 5 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2960 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 2961 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 , pDest -> zAffSdst , pIn -> nSdst ); location: 2962 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , pDest -> iSDParm , r1 , pIn -> iSdst , pIn -> nSdst ); location: 2964 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2966 cross_layer: 5 file: select.c
if ( pParse -> nErr == 0 )  location: 2976 cross_layer: 5 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2977 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSDParm , pIn -> nSdst ); location: 2978 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 2989 cross_layer: 5 file: select.c
pDest -> iSdst = sqlite3GetTempRange ( pParse , pIn -> nSdst ); location: 2990 cross_layer: 5 file: select.c
pDest -> nSdst = pIn -> nSdst; location: 2991 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSdst , pIn -> nSdst ); location: 2993 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 2994 cross_layer: 5 file: select.c
assert ( pDest -> eDest == SRT_Output ); location: 3007 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pIn -> iSdst , pIn -> nSdst ); location: 3008 cross_layer: 5 file: select.c
if ( p -> iLimit )  location: 3015 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 3016 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3016 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iContinue ); location: 3021 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReturn ); location: 3022 cross_layer: 5 file: select.c
return addr ; location: 3024 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "Output routine for B" ) ); location: 3313 cross_layer: 4 file: select.c
addrOutB = generateOutputSubroutine ( pParse , p , & destB , pDest , regOutB , regPrev , pKeyDup , labelEnd ); location: 3314 cross_layer: 4 file: select.c
static int generateOutputSubroutine(
Parse *pParse,          /* Parsing context */
Select *p,              /* The SELECT statement */
SelectDest *pIn,        /* Coroutine supplying data */
SelectDest *pDest,      /* Where to send the data */
int regReturn,          /* The return address register */
int regPrev,            /* Previous result register.  No uniqueness if 0 */
KeyInfo *pKeyInfo,      /* For comparing with previous entry */
int iBreak              /* Jump here if we hit the LIMIT */
) location: 2912 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 2913 cross_layer: 5 file: select.c
addr = sqlite3VdbeCurrentAddr ( v ); location: 2917 cross_layer: 5 file: select.c
iContinue = sqlite3VdbeMakeLabel ( pParse ); location: 2918 cross_layer: 5 file: select.c
if ( regPrev )  location: 2922 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeAddOp1 ( v , OP_IfNot , regPrev ); location: 2924 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2924 cross_layer: 5 file: select.c
addr2 = sqlite3VdbeAddOp4 ( v , OP_Compare , pIn -> iSdst , regPrev + 1 , pIn -> nSdst , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 2925 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr2 + 2 , iContinue , addr2 + 2 ); location: 2927 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2927 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 2928 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , pIn -> iSdst , regPrev + 1 , pIn -> nSdst - 1 ); location: 2929 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regPrev ); location: 2930 cross_layer: 5 file: select.c
if ( pParse -> db -> mallocFailed )  location: 2932 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 2936 cross_layer: 5 file: select.c
assert ( pDest -> eDest != SRT_Exists ); location: 2938 cross_layer: 5 file: select.c
assert ( pDest -> eDest != SRT_Table ); location: 2939 cross_layer: 5 file: select.c
switch ( pDest -> eDest )  location: 2940 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 2944 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 2945 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 ); location: 2946 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , pDest -> iSDParm , r2 ); location: 2947 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , pDest -> iSDParm , r1 , r2 ); location: 2948 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 2949 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 2950 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2951 cross_layer: 5 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2960 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 2961 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 , pDest -> zAffSdst , pIn -> nSdst ); location: 2962 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , pDest -> iSDParm , r1 , pIn -> iSdst , pIn -> nSdst ); location: 2964 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2966 cross_layer: 5 file: select.c
if ( pParse -> nErr == 0 )  location: 2976 cross_layer: 5 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2977 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSDParm , pIn -> nSdst ); location: 2978 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 2989 cross_layer: 5 file: select.c
pDest -> iSdst = sqlite3GetTempRange ( pParse , pIn -> nSdst ); location: 2990 cross_layer: 5 file: select.c
pDest -> nSdst = pIn -> nSdst; location: 2991 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSdst , pIn -> nSdst ); location: 2993 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 2994 cross_layer: 5 file: select.c
assert ( pDest -> eDest == SRT_Output ); location: 3007 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pIn -> iSdst , pIn -> nSdst ); location: 3008 cross_layer: 5 file: select.c
if ( p -> iLimit )  location: 3015 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 3016 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3016 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iContinue ); location: 3021 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReturn ); location: 3022 cross_layer: 5 file: select.c
return addr ; location: 3024 cross_layer: 5 file: select.c
sqlite3KeyInfoUnref ( pKeyDup ); location: 3318 cross_layer: 4 file: select.c
void sqlite3KeyInfoUnref(KeyInfo *p) location: 1296 cross_layer: 5 file: select.c
if ( p )  location: 1297 cross_layer: 5 file: select.c
assert ( p -> nRef > 0 ); location: 1298 cross_layer: 5 file: select.c
p -> nRef --; location: 1299 cross_layer: 5 file: select.c
if ( p -> nRef == 0 )  location: 1300 cross_layer: 5 file: select.c
sqlite3DbFreeNN ( p -> db , p ); location: 1300 cross_layer: 5 file: select.c
addrEofA_noB = addrEofA = labelEnd; location: 3324 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "eof-A subroutine" ) ); location: 3326 cross_layer: 4 file: select.c
addrEofA = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutB , addrOutB ); location: 3327 cross_layer: 4 file: select.c
addrEofA_noB = sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , labelEnd ); location: 3328 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3329 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrEofA ); location: 3330 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 3331 cross_layer: 4 file: select.c
addrEofB = addrEofA; location: 3338 cross_layer: 4 file: select.c
if ( p -> nSelectRow > pPrior -> nSelectRow )  location: 3339 cross_layer: 4 file: select.c
p -> nSelectRow = pPrior -> nSelectRow; location: 3339 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "eof-B subroutine" ) ); location: 3341 cross_layer: 4 file: select.c
addrEofB = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutA , addrOutA ); location: 3342 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , labelEnd ); location: 3343 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3343 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrEofB ); location: 3344 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "A-lt-B subroutine" ) ); location: 3349 cross_layer: 4 file: select.c
addrAltB = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutA , addrOutA ); location: 3350 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA ); location: 3351 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3351 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3352 cross_layer: 4 file: select.c
addrAeqB = addrAltB; location: 3357 cross_layer: 4 file: select.c
addrAeqB = addrAltB; location: 3359 cross_layer: 4 file: select.c
addrAltB ++; location: 3360 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "A-eq-B subroutine" ) ); location: 3362 cross_layer: 4 file: select.c
addrAeqB = sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA ); location: 3363 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3364 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3365 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "A-gt-B subroutine" ) ); location: 3370 cross_layer: 4 file: select.c
addrAgtB = sqlite3VdbeCurrentAddr ( v ); location: 3371 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutB , addrOutB ); location: 3373 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , addrEofB ); location: 3375 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3375 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3376 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 3380 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA_noB ); location: 3381 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3381 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , addrEofB ); location: 3382 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3382 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , labelCmpr ); location: 3386 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Permutation , 0 , 0 , 0 , ( char * ) aPermute , P4_INTARRAY ); location: 3387 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , destA . iSdst , destB . iSdst , nOrderBy , ( char * ) pKeyMerge , P4_KEYINFO ); location: 3388 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_PERMUTE ); location: 3390 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addrAltB , addrAeqB , addrAgtB ); location: 3391 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3391 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , labelEnd ); location: 3395 cross_layer: 4 file: select.c
if ( p -> pPrior )  location: 3399 cross_layer: 4 file: select.c
sqlite3SelectDelete ( db , p -> pPrior ); location: 3400 cross_layer: 4 file: select.c
void sqlite3SelectDelete(sqlite3 *db, Select *p) location: 187 cross_layer: 5 file: select.c
if ( OK_IF_ALWAYS_TRUE ( p ) )  location: 188 cross_layer: 5 file: select.c
clearSelect ( db , p , 1 ); location: 188 cross_layer: 5 file: select.c
p -> pPrior = pPrior; location: 3402 cross_layer: 4 file: select.c
pPrior -> pNext = p; location: 3403 cross_layer: 4 file: select.c
ExplainQueryPlanPop ( pParse ); location: 3407 cross_layer: 4 file: select.c
return pParse -> nErr != 0 ; location: 3408 cross_layer: 4 file: select.c
------------------------------
28 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 3 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 3 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 3 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 3 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 3 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 3 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 3 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 3 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 3 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 3 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 3 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 3 file: select.c
static struct SrcList_item *isSelfJoinView(
SrcList *pTabList,           /* Search for self-joins in this FROM clause */
struct SrcList_item *pThis   /* Search for prior reference to this subquery */
) location: 5543 cross_layer: 4 file: select.c
for(pItem = pTabList->a; pItem<pThis; pItem++) location: 5545 cross_layer: 4 file: select.c
if ( pItem -> pSelect == 0 )  location: 5547 cross_layer: 4 file: select.c
if ( pItem -> fg . viaCoroutine )  location: 5548 cross_layer: 4 file: select.c
if ( pItem -> zName == 0 )  location: 5549 cross_layer: 4 file: select.c
assert ( pItem -> pTab != 0 ); location: 5550 cross_layer: 4 file: select.c
assert ( pThis -> pTab != 0 ); location: 5551 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema != pThis -> pTab -> pSchema )  location: 5552 cross_layer: 4 file: select.c
if ( sqlite3_stricmp ( pItem -> zName , pThis -> zName ) != 0 )  location: 5553 cross_layer: 4 file: select.c
pS1 = pItem -> pSelect; location: 5554 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema == 0 && pThis -> pSelect -> selId != pS1 -> selId )  location: 5555 cross_layer: 4 file: select.c
if ( sqlite3ExprCompare ( 0 , pThis -> pSelect -> pWhere , pS1 -> pWhere , - 1 ) || sqlite3ExprCompare ( 0 , pThis -> pSelect -> pHaving , pS1 -> pHaving , - 1 ) )  location: 5560 cross_layer: 4 file: select.c
return pItem ; location: 5567 cross_layer: 4 file: select.c
if ( pPrior )  location: 6023 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 3 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 3 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 3 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 3 file: select.c
void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm) location: 115 cross_layer: 4 file: select.c
pDest -> eDest = ( u8 ) eDest; location: 116 cross_layer: 4 file: select.c
pDest -> iSDParm = iParm; location: 117 cross_layer: 4 file: select.c
pDest -> zAffSdst = 0; location: 118 cross_layer: 4 file: select.c
pDest -> iSdst = 0; location: 119 cross_layer: 4 file: select.c
pDest -> nSdst = 0; location: 120 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 3 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
rc = sqlite3Select ( pParse , p , & intersectdest ); location: 2772 cross_layer: 4 file: select.c
testcase ( rc != SQLITE_OK ); location: 2773 cross_layer: 4 file: select.c
return rc ; location: 2866 cross_layer: 4 file: select.c
------------------------------
29 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 3 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 3 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 3 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 3 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 3 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 3 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 3 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 3 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 3 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 3 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 3 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 3 file: select.c
static struct SrcList_item *isSelfJoinView(
SrcList *pTabList,           /* Search for self-joins in this FROM clause */
struct SrcList_item *pThis   /* Search for prior reference to this subquery */
) location: 5543 cross_layer: 4 file: select.c
for(pItem = pTabList->a; pItem<pThis; pItem++) location: 5545 cross_layer: 4 file: select.c
if ( pItem -> pSelect == 0 )  location: 5547 cross_layer: 4 file: select.c
if ( pItem -> fg . viaCoroutine )  location: 5548 cross_layer: 4 file: select.c
if ( pItem -> zName == 0 )  location: 5549 cross_layer: 4 file: select.c
assert ( pItem -> pTab != 0 ); location: 5550 cross_layer: 4 file: select.c
assert ( pThis -> pTab != 0 ); location: 5551 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema != pThis -> pTab -> pSchema )  location: 5552 cross_layer: 4 file: select.c
if ( sqlite3_stricmp ( pItem -> zName , pThis -> zName ) != 0 )  location: 5553 cross_layer: 4 file: select.c
pS1 = pItem -> pSelect; location: 5554 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema == 0 && pThis -> pSelect -> selId != pS1 -> selId )  location: 5555 cross_layer: 4 file: select.c
if ( sqlite3ExprCompare ( 0 , pThis -> pSelect -> pWhere , pS1 -> pWhere , - 1 ) || sqlite3ExprCompare ( 0 , pThis -> pSelect -> pHaving , pS1 -> pHaving , - 1 ) )  location: 5560 cross_layer: 4 file: select.c
return pItem ; location: 5567 cross_layer: 4 file: select.c
if ( pPrior )  location: 6023 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 3 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 3 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 3 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 3 file: select.c
void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm) location: 115 cross_layer: 4 file: select.c
pDest -> eDest = ( u8 ) eDest; location: 116 cross_layer: 4 file: select.c
pDest -> iSDParm = iParm; location: 117 cross_layer: 4 file: select.c
pDest -> zAffSdst = 0; location: 118 cross_layer: 4 file: select.c
pDest -> iSdst = 0; location: 119 cross_layer: 4 file: select.c
pDest -> nSdst = 0; location: 120 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 3 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
rc = sqlite3Select ( pParse , pSetup , & destQueue ); location: 2389 cross_layer: 4 file: select.c
if ( rc )  location: 2391 cross_layer: 4 file: select.c
------------------------------
30 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 3 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 3 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 3 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 3 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 3 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 3 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 3 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 3 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 3 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 3 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 3 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 3 file: select.c
static struct SrcList_item *isSelfJoinView(
SrcList *pTabList,           /* Search for self-joins in this FROM clause */
struct SrcList_item *pThis   /* Search for prior reference to this subquery */
) location: 5543 cross_layer: 4 file: select.c
for(pItem = pTabList->a; pItem<pThis; pItem++) location: 5545 cross_layer: 4 file: select.c
if ( pItem -> pSelect == 0 )  location: 5547 cross_layer: 4 file: select.c
if ( pItem -> fg . viaCoroutine )  location: 5548 cross_layer: 4 file: select.c
if ( pItem -> zName == 0 )  location: 5549 cross_layer: 4 file: select.c
assert ( pItem -> pTab != 0 ); location: 5550 cross_layer: 4 file: select.c
assert ( pThis -> pTab != 0 ); location: 5551 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema != pThis -> pTab -> pSchema )  location: 5552 cross_layer: 4 file: select.c
if ( sqlite3_stricmp ( pItem -> zName , pThis -> zName ) != 0 )  location: 5553 cross_layer: 4 file: select.c
pS1 = pItem -> pSelect; location: 5554 cross_layer: 4 file: select.c
if ( pItem -> pTab -> pSchema == 0 && pThis -> pSelect -> selId != pS1 -> selId )  location: 5555 cross_layer: 4 file: select.c
if ( sqlite3ExprCompare ( 0 , pThis -> pSelect -> pWhere , pS1 -> pWhere , - 1 ) || sqlite3ExprCompare ( 0 , pThis -> pSelect -> pHaving , pS1 -> pHaving , - 1 ) )  location: 5560 cross_layer: 4 file: select.c
return pItem ; location: 5567 cross_layer: 4 file: select.c
if ( pPrior )  location: 6023 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 3 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 3 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 3 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 3 file: select.c
void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm) location: 115 cross_layer: 4 file: select.c
pDest -> eDest = ( u8 ) eDest; location: 116 cross_layer: 4 file: select.c
pDest -> iSDParm = iParm; location: 117 cross_layer: 4 file: select.c
pDest -> zAffSdst = 0; location: 118 cross_layer: 4 file: select.c
pDest -> iSdst = 0; location: 119 cross_layer: 4 file: select.c
pDest -> nSdst = 0; location: 120 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 3 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 3 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 3 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 3 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 3 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 3 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 3 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 3 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 3 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 3 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++) location: 1355 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 3 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 3 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 3 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 3 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 3 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 3 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 4 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 4 file: select.c
if ( pLimit )  location: 2168 cross_layer: 4 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 4 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 4 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 4 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 4 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 4 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 4 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 4 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 4 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 4 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 4 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 4 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 4 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 4 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 3 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 3 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 3 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 3 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 3 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 3 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 3 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 3 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 3 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 3 file: select.c
if ( pWin )  location: 6154 cross_layer: 3 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 3 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 3 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 3 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 3 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 3 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 3 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 3 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 3 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 3 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 3 file: select.c
if ( pWin )  location: 6190 cross_layer: 3 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 3 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 3 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 3 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 3 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 3 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 3 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 3 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 3 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 3 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 3 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 3 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 3 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 3 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 3 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 3 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 3 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 3 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 3 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 3 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 3 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 3 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 3 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 3 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 3 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 3 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 3 file: select.c
static void havingToWhere(Parse *pParse, Select *p) location: 5520 cross_layer: 4 file: select.c
sWalker . pParse = pParse; location: 5523 cross_layer: 4 file: select.c
sWalker . xExprCallback = havingToWhereExprCb; location: 5524 cross_layer: 4 file: select.c
sWalker . u . pSelect = p; location: 5525 cross_layer: 4 file: select.c
sqlite3WalkExpr ( & sWalker , p -> pHaving ); location: 5526 cross_layer: 4 file: select.c
if ( sWalker . eCode && ( sqlite3SelectTrace & 0x100 ) != 0 )  location: 5528 cross_layer: 4 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Move HAVING terms into WHERE:\n" ) ); location: 5529 cross_layer: 4 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5530 cross_layer: 4 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 3 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 3 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 3 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 3 file: select.c
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax) location: 4429 cross_layer: 4 file: select.c
ExprList * pEList = pFunc -> x . pList ; location: 4431 cross_layer: 4 file: select.c
assert ( * ppMinMax == 0 ); location: 4436 cross_layer: 4 file: select.c
assert ( pFunc -> op == TK_AGG_FUNCTION ); location: 4437 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pFunc ) ); location: 4438 cross_layer: 4 file: select.c
if ( pEList == 0 || pEList -> nExpr != 1 || ExprHasProperty ( pFunc , EP_WinFunc ) )  location: 4439 cross_layer: 4 file: select.c
zFunc = pFunc -> u . zToken; location: 4442 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "min" ) == 0 )  location: 4443 cross_layer: 4 file: select.c
if ( sqlite3StrICmp ( zFunc , "max" ) == 0 )  location: 4446 cross_layer: 4 file: select.c
* ppMinMax = pOrderBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 4452 cross_layer: 4 file: select.c
assert ( pOrderBy != 0 || db -> mallocFailed ); location: 4453 cross_layer: 4 file: select.c
if ( pOrderBy )  location: 4454 cross_layer: 4 file: select.c
pOrderBy -> a [ 0 ] . sortFlags = sortFlags; location: 4454 cross_layer: 4 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 3 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 3 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 3 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 3 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 3 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 3 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 3 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 3 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 3 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 3 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 3 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 3 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 3 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 3 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 3 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoFromExprList(
Parse *pParse,       /* Parsing context */
ExprList *pList,     /* Form the KeyInfo object from this ExprList */
int iStart,          /* Begin with this column of pList */
int nExtra           /* Add this many extra columns to the end */
) location: 1344 cross_layer: 4 file: select.c
sqlite3 * db = pParse -> db ; location: 1348 cross_layer: 4 file: select.c
nExpr = pList -> nExpr; location: 1351 cross_layer: 4 file: select.c
pInfo = sqlite3KeyInfoAlloc ( db , nExpr - iStart , nExtra + 1 ); location: 1352 cross_layer: 4 file: select.c
if ( pInfo )  location: 1353 cross_layer: 4 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pInfo ) ); location: 1354 cross_layer: 4 file: select.c
pInfo -> aColl [ i - iStart ] = sqlite3ExprNNCollSeq ( pParse , pItem -> pExpr ); location: 1356 cross_layer: 4 file: select.c
pInfo -> aSortFlags [ i - iStart ] = pItem -> sortFlags; location: 1357 cross_layer: 4 file: select.c
return pInfo ; location: 1360 cross_layer: 4 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 3 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 3 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 3 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 3 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 3 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 3 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 3 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 3 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 3 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 3 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 3 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 3 file: select.c
j = nGroupBy; location: 6422 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 3 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 3 file: select.c
nCol ++; location: 6425 cross_layer: 3 file: select.c
j ++; location: 6426 cross_layer: 3 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 3 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 3 file: select.c
j = nGroupBy; location: 6431 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 3 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 3 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 3 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 3 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 3 file: select.c
j ++; location: 6438 cross_layer: 3 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 3 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 3 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 3 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 3 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 3 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 3 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 3 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 3 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 3 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 3 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 3 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 3 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 3 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 4 file: select.c
if ( p )  location: 1308 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 4 file: select.c
p -> nRef ++; location: 1310 cross_layer: 4 file: select.c
return p ; location: 1312 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 3 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 3 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 3 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 3 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5373 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++) location: 5419 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) location: 5442 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 3 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 3 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 3 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 3 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 3 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 3 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) location: 5346 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 3 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nColumn; i++) location: 5311 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
for(i=0; i<pAggInfo->nFunc; i++) location: 5315 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++) location: 5321 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 3 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 3 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 3 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 3 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 3 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 3 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 3 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 3 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 3 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 3 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 3 file: select.c
static void explainSimpleCount(
Parse *pParse,                  /* Parse context */
Table *pTab,                    /* Table being queried */
Index *pIdx                     /* Index used to optimize scan, or NULL */
) location: 5461 cross_layer: 4 file: select.c
if ( pParse -> explain == 2 )  location: 5462 cross_layer: 4 file: select.c
int bCover = ( pIdx != 0 && ( HasRowid ( pTab ) || ! IsPrimaryKeyIndex ( pIdx ) ) ) ; location: 5463 cross_layer: 4 file: select.c
sqlite3VdbeExplain ( pParse , 0 , "SCAN TABLE %s%s%s" , pTab -> zName , bCover ? " USING COVERING INDEX " : "" , bCover ? pIdx -> zName : "" ); location: 5464 cross_layer: 4 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 3 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 3 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 3 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 3 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 3 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 3 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 3 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 3 file: select.c
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) location: 5301 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5302 cross_layer: 4 file: select.c
int nReg = pAggInfo -> nFunc + pAggInfo -> nColumn ; location: 5305 cross_layer: 4 file: select.c
if ( nReg == 0 )  location: 5306 cross_layer: 4 file: select.c
assert ( nReg == pAggInfo -> mxReg - pAggInfo -> mnReg + 1 ); location: 5310 cross_layer: 4 file: select.c
assert ( pAggInfo -> aCol [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aCol [ i ] . iMem <= pAggInfo -> mxReg ); location: 5312 cross_layer: 4 file: select.c
assert ( pAggInfo -> aFunc [ i ] . iMem >= pAggInfo -> mnReg && pAggInfo -> aFunc [ i ] . iMem <= pAggInfo -> mxReg ); location: 5316 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , pAggInfo -> mnReg , pAggInfo -> mxReg ); location: 5320 cross_layer: 4 file: select.c
if ( pFunc -> iDistinct >= 0 )  location: 5322 cross_layer: 4 file: select.c
Expr * pE = pFunc -> pExpr ; location: 5323 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pE , EP_xIsSelect ) ); location: 5324 cross_layer: 4 file: select.c
if ( pE -> x . pList == 0 || pE -> x . pList -> nExpr != 1 )  location: 5325 cross_layer: 4 file: select.c
sqlite3ErrorMsg ( pParse , "DISTINCT aggregates must have exactly one "
"argument" ) location: 5327 cross_layer: 4 file: select.c
pFunc -> iDistinct = - 1; location: 5328 cross_layer: 4 file: select.c
KeyInfo * pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pE -> x . pList , 0 , 0 ) ; location: 5330 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , pFunc -> iDistinct , 0 , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 5331 cross_layer: 4 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 3 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 3 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 3 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 3 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 3 file: select.c
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo) location: 5364 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5365 cross_layer: 4 file: select.c
pAggInfo -> directMode = 1; location: 5372 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5377 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5378 cross_layer: 4 file: select.c
assert ( ! IsWindowFunc ( pF -> pExpr ) ); location: 5379 cross_layer: 4 file: select.c
if ( ExprHasProperty ( pF -> pExpr , EP_WinFunc ) )  location: 5380 cross_layer: 4 file: select.c
Expr * pFilter = pF -> pExpr -> y . pWin -> pFilter ; location: 5381 cross_layer: 4 file: select.c
if ( pAggInfo -> nAccumulator && ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) )  location: 5382 cross_layer: 4 file: select.c
if ( regHit == 0 )  location: 5385 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5385 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regAcc , regHit ); location: 5393 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5395 cross_layer: 4 file: select.c
sqlite3ExprIfFalse ( pParse , pFilter , addrNext , SQLITE_JUMPIFNULL ); location: 5396 cross_layer: 4 file: select.c
if ( pList )  location: 5398 cross_layer: 4 file: select.c
nArg = pList -> nExpr; location: 5399 cross_layer: 4 file: select.c
regAgg = sqlite3GetTempRange ( pParse , nArg ); location: 5400 cross_layer: 4 file: select.c
sqlite3ExprCodeExprList ( pParse , pList , regAgg , 0 , SQLITE_ECEL_DUP ); location: 5401 cross_layer: 4 file: select.c
if ( pF -> iDistinct >= 0 )  location: 5406 cross_layer: 4 file: select.c
if ( addrNext == 0 )  location: 5407 cross_layer: 4 file: select.c
addrNext = sqlite3VdbeMakeLabel ( pParse ); location: 5408 cross_layer: 4 file: select.c
testcase ( nArg == 0 ); location: 5410 cross_layer: 4 file: select.c
testcase ( nArg > 1 ); location: 5411 cross_layer: 4 file: select.c
codeDistinct ( pParse , pF -> iDistinct , addrNext , 1 , regAgg ); location: 5412 cross_layer: 4 file: select.c
if ( pF -> pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 5414 cross_layer: 4 file: select.c
assert ( pList != 0 ); location: 5418 cross_layer: 4 file: select.c
pColl = sqlite3ExprCollSeq ( pParse , pItem -> pExpr ); location: 5420 cross_layer: 4 file: select.c
if ( ! pColl )  location: 5422 cross_layer: 4 file: select.c
pColl = pParse -> db -> pDfltColl; location: 5423 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5425 cross_layer: 4 file: select.c
regHit = ++ pParse -> nMem; location: 5425 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_CollSeq , regHit , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ); location: 5426 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_AggStep , 0 , regAgg , pF -> iMem ); location: 5428 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5429 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , ( u8 ) nArg ); location: 5430 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regAgg , nArg ); location: 5431 cross_layer: 4 file: select.c
if ( addrNext )  location: 5432 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrNext ); location: 5433 cross_layer: 4 file: select.c
if ( regHit == 0 && pAggInfo -> nAccumulator )  location: 5436 cross_layer: 4 file: select.c
regHit = regAcc; location: 5437 cross_layer: 4 file: select.c
if ( regHit )  location: 5439 cross_layer: 4 file: select.c
addrHitTest = sqlite3VdbeAddOp1 ( v , OP_If , regHit ); location: 5440 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 5440 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , pC -> pExpr , pC -> iMem ); location: 5443 cross_layer: 4 file: select.c
pAggInfo -> directMode = 0; location: 5446 cross_layer: 4 file: select.c
if ( addrHitTest )  location: 5447 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrHitTest ); location: 5448 cross_layer: 4 file: select.c
if ( regAcc )  location: 6676 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 3 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 3 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 3 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 3 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 3 file: select.c
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) location: 5342 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 5343 cross_layer: 4 file: select.c
ExprList * pList = pF -> pExpr -> x . pList ; location: 5347 cross_layer: 4 file: select.c
assert ( ! ExprHasProperty ( pF -> pExpr , EP_xIsSelect ) ); location: 5348 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_AggFinal , pF -> iMem , pList ? pList -> nExpr : 0 ); location: 5349 cross_layer: 4 file: select.c
sqlite3VdbeAppendP4 ( v , pF -> pFunc , P4_FUNCDEF ); location: 5350 cross_layer: 4 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 3 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 3 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 3 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 4 file: select.c
assert ( v ); location: 887 cross_layer: 4 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 4 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 4 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 4 file: select.c
pSort = 0; location: 890 cross_layer: 4 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 4 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 4 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 4 file: select.c
if ( pSort )  location: 901 cross_layer: 4 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 4 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 4 file: select.c
nPrefixReg ++; location: 903 cross_layer: 4 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 4 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 4 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 4 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 4 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 4 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 4 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 4 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 4 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 4 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 4 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 4 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 4 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 4 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 4 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 4 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 4 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 4 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 4 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 4 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 4 file: select.c
nResultCol --; location: 976 cross_layer: 4 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 4 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 4 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 4 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 4 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 4 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 4 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 4 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 4 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 4 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 4 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 4 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 4 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 4 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 4 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 4 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 4 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 4 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 4 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 4 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 4 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 4 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 4 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 4 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 4 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 4 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 4 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 4 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 4 file: select.c
switch ( eDest )  location: 1072 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 4 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 4 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 4 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 4 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 4 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 4 file: select.c
if ( pSort )  location: 1122 cross_layer: 4 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 4 file: select.c
if ( pSort )  location: 1142 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 4 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 4 file: select.c
if ( pSort )  location: 1173 cross_layer: 4 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 4 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 4 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 4 file: select.c
if ( pSort )  location: 1190 cross_layer: 4 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 4 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 4 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 4 file: select.c
assert ( pSO ); location: 1215 cross_layer: 4 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 4 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 4 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 4 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 4 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 4 file: select.c
if ( addrTest )  location: 1241 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 4 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 4 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 3 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 3 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 3 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 3 file: select.c
static void explainTempTable(Parse *pParse, const char *zUsage) location: 1388 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 0 , "USE TEMP B-TREE FOR %s" , zUsage ) ); location: 1389 cross_layer: 4 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 3 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 3 file: select.c
static void generateSortTail(
Parse *pParse,    /* Parsing context */
Select *p,        /* The SELECT statement */
SortCtx *pSort,   /* Information on the ORDER BY clause */
int nColumn,      /* Number of columns of data */
SelectDest *pDest /* Write the sorted results here */
) location: 1420 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 1421 cross_layer: 4 file: select.c
int addrBreak = pSort -> labelDone ; location: 1422 cross_layer: 4 file: select.c
int addrContinue = sqlite3VdbeMakeLabel ( pParse ) ; location: 1423 cross_layer: 4 file: select.c
ExprList * pOrderBy = pSort -> pOrderBy ; location: 1427 cross_layer: 4 file: select.c
int eDest = pDest -> eDest ; location: 1428 cross_layer: 4 file: select.c
int iParm = pDest -> iSDParm ; location: 1429 cross_layer: 4 file: select.c
struct ExprList_item * aOutEx = p -> pEList -> a ; location: 1438 cross_layer: 4 file: select.c
assert ( addrBreak < 0 ); location: 1440 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1441 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , pSort -> regReturn , pSort -> labelBkOut ); location: 1442 cross_layer: 4 file: select.c
sqlite3VdbeGoto ( v , addrBreak ); location: 1443 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , pSort -> labelBkOut ); location: 1444 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1449 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1450 cross_layer: 4 file: select.c
int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 1451 cross_layer: 4 file: select.c
sqlite3OpenTable ( pParse , pSort -> aDefer [ i ] . iCsr , iDb , pTab , OP_OpenRead ); location: 1452 cross_layer: 4 file: select.c
nRefKey = MAX ( nRefKey , pSort -> aDefer [ i ] . nKey ); location: 1453 cross_layer: 4 file: select.c
iTab = pSort -> iECursor; location: 1457 cross_layer: 4 file: select.c
if ( eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem )  location: 1458 cross_layer: 4 file: select.c
regRow = pDest -> iSdst; location: 1460 cross_layer: 4 file: select.c
regRowid = sqlite3GetTempReg ( pParse ); location: 1462 cross_layer: 4 file: select.c
if ( eDest == SRT_EphemTab || eDest == SRT_Table )  location: 1463 cross_layer: 4 file: select.c
regRow = sqlite3GetTempReg ( pParse ); location: 1464 cross_layer: 4 file: select.c
nColumn = 0; location: 1465 cross_layer: 4 file: select.c
regRow = sqlite3GetTempRange ( pParse , nColumn ); location: 1467 cross_layer: 4 file: select.c
nKey = pOrderBy -> nExpr - pSort -> nOBSat; location: 1470 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1471 cross_layer: 4 file: select.c
int regSortOut = ++ pParse -> nMem ; location: 1472 cross_layer: 4 file: select.c
iSortTab = pParse -> nTab ++; location: 1473 cross_layer: 4 file: select.c
if ( pSort -> labelBkOut )  location: 1474 cross_layer: 4 file: select.c
addrOnce = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 1475 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1475 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , iSortTab , regSortOut , nKey + 1 + nColumn + nRefKey ); location: 1477 cross_layer: 4 file: select.c
if ( addrOnce )  location: 1479 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addrOnce ); location: 1479 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_SorterSort , iTab , addrBreak ); location: 1480 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1481 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1482 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , iTab , regSortOut , iSortTab ); location: 1483 cross_layer: 4 file: select.c
addr = 1 + sqlite3VdbeAddOp2 ( v , OP_Sort , iTab , addrBreak ); location: 1486 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1486 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , addrContinue ); location: 1487 cross_layer: 4 file: select.c
iSortTab = iTab; location: 1488 cross_layer: 4 file: select.c
for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++) location: 1491 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1493 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol == 0 )  location: 1495 cross_layer: 4 file: select.c
iCol ++; location: 1495 cross_layer: 4 file: select.c
if ( pSort -> nDefer )  location: 1498 cross_layer: 4 file: select.c
int iKey = iCol + 1 ; location: 1499 cross_layer: 4 file: select.c
int regKey = sqlite3GetTempRange ( pParse , nRefKey ) ; location: 1500 cross_layer: 4 file: select.c
for(i=0; i<pSort->nDefer; i++) location: 1502 cross_layer: 4 file: select.c
int iCsr = pSort -> aDefer [ i ] . iCsr ; location: 1503 cross_layer: 4 file: select.c
Table * pTab = pSort -> aDefer [ i ] . pTab ; location: 1504 cross_layer: 4 file: select.c
int nKey = pSort -> aDefer [ i ] . nKey ; location: 1505 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1507 cross_layer: 4 file: select.c
if ( HasRowid ( pTab ) )  location: 1508 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey ); location: 1509 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SeekRowid , iCsr , sqlite3VdbeCurrentAddr ( v ) + 1 , regKey ); location: 1510 cross_layer: 4 file: select.c
assert ( sqlite3PrimaryKeyIndex ( pTab ) -> nKeyCol == nKey ); location: 1515 cross_layer: 4 file: select.c
for(k=0; k<nKey; k++) location: 1516 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iKey ++ , regKey + k ); location: 1517 cross_layer: 4 file: select.c
iJmp = sqlite3VdbeCurrentAddr ( v ); location: 1519 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_SeekGE , iCsr , iJmp + 2 , regKey , nKey ); location: 1520 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxLE , iCsr , iJmp + 3 , regKey , nKey ); location: 1521 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_NullRow , iCsr ); location: 1522 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regKey , nRefKey ); location: 1525 cross_layer: 4 file: select.c
for(i=nColumn-1; i>=0; i--) location: 1528 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . bSorterRef )  location: 1530 cross_layer: 4 file: select.c
sqlite3ExprCode ( pParse , aOutEx [ i ] . pExpr , regRow + i ); location: 1531 cross_layer: 4 file: select.c
if ( aOutEx [ i ] . u . x . iOrderByCol )  location: 1536 cross_layer: 4 file: select.c
iRead = aOutEx [ i ] . u . x . iOrderByCol - 1; location: 1537 cross_layer: 4 file: select.c
iRead = iCol --; location: 1539 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , iRead , regRow + i ); location: 1541 cross_layer: 4 file: select.c
VdbeComment ( ( v , "%s" , aOutEx [ i ] . zName ? aOutEx [ i ] . zName : aOutEx [ i ] . zSpan ) ); location: 1542 cross_layer: 4 file: select.c
switch ( eDest )  location: 1545 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , iSortTab , nKey + bSeq , regRow ); location: 1548 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , regRowid ); location: 1549 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , regRow , regRowid ); location: 1550 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1551 cross_layer: 4 file: select.c
assert ( nColumn == sqlite3Strlen30 ( pDest -> zAffSdst ) ); location: 1556 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , nColumn , regRowid , pDest -> zAffSdst , nColumn ); location: 1557 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , regRowid , regRow , nColumn ); location: 1559 cross_layer: 4 file: select.c
assert ( eDest == SRT_Output || eDest == SRT_Coroutine ); location: 1568 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Output ); location: 1569 cross_layer: 4 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1570 cross_layer: 4 file: select.c
if ( eDest == SRT_Output )  location: 1571 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pDest -> iSdst , nColumn ); location: 1572 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1574 cross_layer: 4 file: select.c
if ( regRowid )  location: 1579 cross_layer: 4 file: select.c
if ( eDest == SRT_Set )  location: 1580 cross_layer: 4 file: select.c
sqlite3ReleaseTempRange ( pParse , regRow , nColumn ); location: 1581 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRow ); location: 1583 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , regRowid ); location: 1585 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrContinue ); location: 1589 cross_layer: 4 file: select.c
if ( pSort -> sortFlags & SORTFLAG_UseSorter )  location: 1590 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , iTab , addr ); location: 1591 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1591 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , iTab , addr ); location: 1593 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 1593 cross_layer: 4 file: select.c
if ( pSort -> regReturn )  location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , pSort -> regReturn ); location: 1595 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , addrBreak ); location: 1596 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 3 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 3 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 3 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 3 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 3 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 3 file: select.c
return rc ; location: 6731 cross_layer: 3 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 4 file: select.c
testcase ( rc != SQLITE_OK ); location: 2695 cross_layer: 4 file: select.c
if ( rc )  location: 2757 cross_layer: 4 file: select.c
testcase ( rc != SQLITE_OK ); location: 2773 cross_layer: 4 file: select.c
return rc ; location: 2866 cross_layer: 4 file: select.c
------------------------------
31 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
sqlite3Select ( pParse , pPrior , & destA ); location: 3281 cross_layer: 3 file: select.c
sqlite3VdbeEndCoroutine ( v , regAddrA ); location: 3282 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 3283 cross_layer: 3 file: select.c
addrSelectB = sqlite3VdbeCurrentAddr ( v ) + 1; location: 3288 cross_layer: 3 file: select.c
addr1 = sqlite3VdbeAddOp3 ( v , OP_InitCoroutine , regAddrB , 0 , addrSelectB ); location: 3289 cross_layer: 3 file: select.c
VdbeComment ( ( v , "right SELECT" ) ); location: 3290 cross_layer: 3 file: select.c
savedLimit = p -> iLimit; location: 3291 cross_layer: 3 file: select.c
savedOffset = p -> iOffset; location: 3292 cross_layer: 3 file: select.c
p -> iLimit = regLimitB; location: 3293 cross_layer: 3 file: select.c
p -> iOffset = 0; location: 3294 cross_layer: 3 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "RIGHT" ) ); location: 3295 cross_layer: 3 file: select.c
sqlite3Select ( pParse , p , & destB ); location: 3296 cross_layer: 3 file: select.c
p -> iLimit = savedLimit; location: 3297 cross_layer: 3 file: select.c
p -> iOffset = savedOffset; location: 3298 cross_layer: 3 file: select.c
sqlite3VdbeEndCoroutine ( v , regAddrB ); location: 3299 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "Output routine for A" ) ); location: 3304 cross_layer: 3 file: select.c
addrOutA = generateOutputSubroutine ( pParse , p , & destA , pDest , regOutA , regPrev , pKeyDup , labelEnd ); location: 3305 cross_layer: 3 file: select.c
static int generateOutputSubroutine(
Parse *pParse,          /* Parsing context */
Select *p,              /* The SELECT statement */
SelectDest *pIn,        /* Coroutine supplying data */
SelectDest *pDest,      /* Where to send the data */
int regReturn,          /* The return address register */
int regPrev,            /* Previous result register.  No uniqueness if 0 */
KeyInfo *pKeyInfo,      /* For comparing with previous entry */
int iBreak              /* Jump here if we hit the LIMIT */
) location: 2912 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 2913 cross_layer: 4 file: select.c
addr = sqlite3VdbeCurrentAddr ( v ); location: 2917 cross_layer: 4 file: select.c
iContinue = sqlite3VdbeMakeLabel ( pParse ); location: 2918 cross_layer: 4 file: select.c
if ( regPrev )  location: 2922 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeAddOp1 ( v , OP_IfNot , regPrev ); location: 2924 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2924 cross_layer: 4 file: select.c
addr2 = sqlite3VdbeAddOp4 ( v , OP_Compare , pIn -> iSdst , regPrev + 1 , pIn -> nSdst , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 2925 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr2 + 2 , iContinue , addr2 + 2 ); location: 2927 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2927 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 2928 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , pIn -> iSdst , regPrev + 1 , pIn -> nSdst - 1 ); location: 2929 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regPrev ); location: 2930 cross_layer: 4 file: select.c
if ( pParse -> db -> mallocFailed )  location: 2932 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 2936 cross_layer: 4 file: select.c
assert ( pDest -> eDest != SRT_Exists ); location: 2938 cross_layer: 4 file: select.c
assert ( pDest -> eDest != SRT_Table ); location: 2939 cross_layer: 4 file: select.c
switch ( pDest -> eDest )  location: 2940 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 2944 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 2945 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 ); location: 2946 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , pDest -> iSDParm , r2 ); location: 2947 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , pDest -> iSDParm , r1 , r2 ); location: 2948 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 2949 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 2950 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2951 cross_layer: 4 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2960 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 2961 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 , pDest -> zAffSdst , pIn -> nSdst ); location: 2962 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , pDest -> iSDParm , r1 , pIn -> iSdst , pIn -> nSdst ); location: 2964 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2966 cross_layer: 4 file: select.c
if ( pParse -> nErr == 0 )  location: 2976 cross_layer: 4 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2977 cross_layer: 4 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSDParm , pIn -> nSdst ); location: 2978 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 2989 cross_layer: 4 file: select.c
pDest -> iSdst = sqlite3GetTempRange ( pParse , pIn -> nSdst ); location: 2990 cross_layer: 4 file: select.c
pDest -> nSdst = pIn -> nSdst; location: 2991 cross_layer: 4 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSdst , pIn -> nSdst ); location: 2993 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 2994 cross_layer: 4 file: select.c
assert ( pDest -> eDest == SRT_Output ); location: 3007 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pIn -> iSdst , pIn -> nSdst ); location: 3008 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 3015 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 3016 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3016 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iContinue ); location: 3021 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReturn ); location: 3022 cross_layer: 4 file: select.c
return addr ; location: 3024 cross_layer: 4 file: select.c
VdbeNoopComment ( ( v , "Output routine for B" ) ); location: 3313 cross_layer: 3 file: select.c
addrOutB = generateOutputSubroutine ( pParse , p , & destB , pDest , regOutB , regPrev , pKeyDup , labelEnd ); location: 3314 cross_layer: 3 file: select.c
static int generateOutputSubroutine(
Parse *pParse,          /* Parsing context */
Select *p,              /* The SELECT statement */
SelectDest *pIn,        /* Coroutine supplying data */
SelectDest *pDest,      /* Where to send the data */
int regReturn,          /* The return address register */
int regPrev,            /* Previous result register.  No uniqueness if 0 */
KeyInfo *pKeyInfo,      /* For comparing with previous entry */
int iBreak              /* Jump here if we hit the LIMIT */
) location: 2912 cross_layer: 4 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 2913 cross_layer: 4 file: select.c
addr = sqlite3VdbeCurrentAddr ( v ); location: 2917 cross_layer: 4 file: select.c
iContinue = sqlite3VdbeMakeLabel ( pParse ); location: 2918 cross_layer: 4 file: select.c
if ( regPrev )  location: 2922 cross_layer: 4 file: select.c
addr1 = sqlite3VdbeAddOp1 ( v , OP_IfNot , regPrev ); location: 2924 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2924 cross_layer: 4 file: select.c
addr2 = sqlite3VdbeAddOp4 ( v , OP_Compare , pIn -> iSdst , regPrev + 1 , pIn -> nSdst , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 2925 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr2 + 2 , iContinue , addr2 + 2 ); location: 2927 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2927 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 2928 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , pIn -> iSdst , regPrev + 1 , pIn -> nSdst - 1 ); location: 2929 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regPrev ); location: 2930 cross_layer: 4 file: select.c
if ( pParse -> db -> mallocFailed )  location: 2932 cross_layer: 4 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 2936 cross_layer: 4 file: select.c
assert ( pDest -> eDest != SRT_Exists ); location: 2938 cross_layer: 4 file: select.c
assert ( pDest -> eDest != SRT_Table ); location: 2939 cross_layer: 4 file: select.c
switch ( pDest -> eDest )  location: 2940 cross_layer: 4 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 2944 cross_layer: 4 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 2945 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 ); location: 2946 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , pDest -> iSDParm , r2 ); location: 2947 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , pDest -> iSDParm , r1 , r2 ); location: 2948 cross_layer: 4 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 2949 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 2950 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2951 cross_layer: 4 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2960 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 2961 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , pIn -> iSdst , pIn -> nSdst , r1 , pDest -> zAffSdst , pIn -> nSdst ); location: 2962 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , pDest -> iSDParm , r1 , pIn -> iSdst , pIn -> nSdst ); location: 2964 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2966 cross_layer: 4 file: select.c
if ( pParse -> nErr == 0 )  location: 2976 cross_layer: 4 file: select.c
testcase ( pIn -> nSdst > 1 ); location: 2977 cross_layer: 4 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSDParm , pIn -> nSdst ); location: 2978 cross_layer: 4 file: select.c
if ( pDest -> iSdst == 0 )  location: 2989 cross_layer: 4 file: select.c
pDest -> iSdst = sqlite3GetTempRange ( pParse , pIn -> nSdst ); location: 2990 cross_layer: 4 file: select.c
pDest -> nSdst = pIn -> nSdst; location: 2991 cross_layer: 4 file: select.c
sqlite3ExprCodeMove ( pParse , pIn -> iSdst , pDest -> iSdst , pIn -> nSdst ); location: 2993 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 2994 cross_layer: 4 file: select.c
assert ( pDest -> eDest == SRT_Output ); location: 3007 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , pIn -> iSdst , pIn -> nSdst ); location: 3008 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 3015 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 3016 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 3016 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iContinue ); location: 3021 cross_layer: 4 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReturn ); location: 3022 cross_layer: 4 file: select.c
return addr ; location: 3024 cross_layer: 4 file: select.c
sqlite3KeyInfoUnref ( pKeyDup ); location: 3318 cross_layer: 3 file: select.c
void sqlite3KeyInfoUnref(KeyInfo *p) location: 1296 cross_layer: 4 file: select.c
if ( p )  location: 1297 cross_layer: 4 file: select.c
assert ( p -> nRef > 0 ); location: 1298 cross_layer: 4 file: select.c
p -> nRef --; location: 1299 cross_layer: 4 file: select.c
if ( p -> nRef == 0 )  location: 1300 cross_layer: 4 file: select.c
sqlite3DbFreeNN ( p -> db , p ); location: 1300 cross_layer: 4 file: select.c
addrEofA_noB = addrEofA = labelEnd; location: 3324 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "eof-A subroutine" ) ); location: 3326 cross_layer: 3 file: select.c
addrEofA = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutB , addrOutB ); location: 3327 cross_layer: 3 file: select.c
addrEofA_noB = sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , labelEnd ); location: 3328 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 3329 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEofA ); location: 3330 cross_layer: 3 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 3331 cross_layer: 3 file: select.c
addrEofB = addrEofA; location: 3338 cross_layer: 3 file: select.c
if ( p -> nSelectRow > pPrior -> nSelectRow )  location: 3339 cross_layer: 3 file: select.c
p -> nSelectRow = pPrior -> nSelectRow; location: 3339 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "eof-B subroutine" ) ); location: 3341 cross_layer: 3 file: select.c
addrEofB = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutA , addrOutA ); location: 3342 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , labelEnd ); location: 3343 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 3343 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , addrEofB ); location: 3344 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "A-lt-B subroutine" ) ); location: 3349 cross_layer: 3 file: select.c
addrAltB = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutA , addrOutA ); location: 3350 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA ); location: 3351 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 3351 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3352 cross_layer: 3 file: select.c
addrAeqB = addrAltB; location: 3357 cross_layer: 3 file: select.c
addrAeqB = addrAltB; location: 3359 cross_layer: 3 file: select.c
addrAltB ++; location: 3360 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "A-eq-B subroutine" ) ); location: 3362 cross_layer: 3 file: select.c
addrAeqB = sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA ); location: 3363 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 3364 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3365 cross_layer: 3 file: select.c
VdbeNoopComment ( ( v , "A-gt-B subroutine" ) ); location: 3370 cross_layer: 3 file: select.c
addrAgtB = sqlite3VdbeCurrentAddr ( v ); location: 3371 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutB , addrOutB ); location: 3373 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , addrEofB ); location: 3375 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 3375 cross_layer: 3 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3376 cross_layer: 3 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 3380 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA_noB ); location: 3381 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 3381 cross_layer: 3 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , addrEofB ); location: 3382 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 3382 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , labelCmpr ); location: 3386 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Permutation , 0 , 0 , 0 , ( char * ) aPermute , P4_INTARRAY ); location: 3387 cross_layer: 3 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , destA . iSdst , destB . iSdst , nOrderBy , ( char * ) pKeyMerge , P4_KEYINFO ); location: 3388 cross_layer: 3 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_PERMUTE ); location: 3390 cross_layer: 3 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addrAltB , addrAeqB , addrAgtB ); location: 3391 cross_layer: 3 file: select.c
VdbeCoverage ( v ); location: 3391 cross_layer: 3 file: select.c
sqlite3VdbeResolveLabel ( v , labelEnd ); location: 3395 cross_layer: 3 file: select.c
if ( p -> pPrior )  location: 3399 cross_layer: 3 file: select.c
sqlite3SelectDelete ( db , p -> pPrior ); location: 3400 cross_layer: 3 file: select.c
void sqlite3SelectDelete(sqlite3 *db, Select *p) location: 187 cross_layer: 4 file: select.c
if ( OK_IF_ALWAYS_TRUE ( p ) )  location: 188 cross_layer: 4 file: select.c
clearSelect ( db , p , 1 ); location: 188 cross_layer: 4 file: select.c
p -> pPrior = pPrior; location: 3402 cross_layer: 3 file: select.c
pPrior -> pNext = p; location: 3403 cross_layer: 3 file: select.c
ExplainQueryPlanPop ( pParse ); location: 3407 cross_layer: 3 file: select.c
return pParse -> nErr != 0 ; location: 3408 cross_layer: 3 file: select.c
return multiSelectOrderBy ( pParse , p , pDest ) ; location: 2587 cross_layer: 4 file: select.c
------------------------------
32 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
rc = sqlite3Select ( pParse , p , & intersectdest ); location: 2772 cross_layer: 3 file: select.c
testcase ( rc != SQLITE_OK ); location: 2773 cross_layer: 3 file: select.c
return rc ; location: 2866 cross_layer: 3 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 4 file: select.c
return rc ; location: 5852 cross_layer: 4 file: select.c
------------------------------
33 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
rc = sqlite3Select ( pParse , pSetup , & destQueue ); location: 2389 cross_layer: 3 file: select.c
if ( rc )  location: 2391 cross_layer: 3 file: select.c
generateWithRecursiveQuery ( pParse , p , & dest ); location: 2580 cross_layer: 4 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 4 file: select.c
return multiSelectOrderBy ( pParse , p , pDest ) ; location: 2587 cross_layer: 4 file: select.c
static int multiSelectOrderBy(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 3117 cross_layer: 5 file: select.c
assert ( p -> pOrderBy != 0 ); location: 3153 cross_layer: 5 file: select.c
db = pParse -> db; location: 3155 cross_layer: 5 file: select.c
v = pParse -> pVdbe; location: 3156 cross_layer: 5 file: select.c
assert ( v != 0 ); location: 3157 cross_layer: 5 file: select.c
labelEnd = sqlite3VdbeMakeLabel ( pParse ); location: 3158 cross_layer: 5 file: select.c
labelCmpr = sqlite3VdbeMakeLabel ( pParse ); location: 3159 cross_layer: 5 file: select.c
op = p -> op; location: 3164 cross_layer: 5 file: select.c
pPrior = p -> pPrior; location: 3165 cross_layer: 5 file: select.c
assert ( pPrior -> pOrderBy == 0 ); location: 3166 cross_layer: 5 file: select.c
pOrderBy = p -> pOrderBy; location: 3167 cross_layer: 5 file: select.c
assert ( pOrderBy ); location: 3168 cross_layer: 5 file: select.c
nOrderBy = pOrderBy -> nExpr; location: 3169 cross_layer: 5 file: select.c
if ( op != TK_ALL )  location: 3175 cross_layer: 5 file: select.c
for(i=1; db->mallocFailed==0 && i<=p->pEList->nExpr; i++) location: 3176 cross_layer: 5 file: select.c
for(j=0, pItem=pOrderBy->a; j<nOrderBy; j++, pItem++) location: 3178 cross_layer: 5 file: select.c
assert ( pItem -> u . x . iOrderByCol > 0 ); location: 3179 cross_layer: 5 file: select.c
if ( pItem -> u . x . iOrderByCol == i )  location: 3180 cross_layer: 5 file: select.c
if ( j == nOrderBy )  location: 3182 cross_layer: 5 file: select.c
Expr * pNew = sqlite3Expr ( db , TK_INTEGER , 0 ) ; location: 3183 cross_layer: 5 file: select.c
if ( pNew == 0 )  location: 3184 cross_layer: 5 file: select.c
pNew -> flags |= EP_IntValue; location: 3185 cross_layer: 5 file: select.c
pNew -> u . iValue = i; location: 3186 cross_layer: 5 file: select.c
p -> pOrderBy = pOrderBy = sqlite3ExprListAppend ( pParse , pOrderBy , pNew ); location: 3187 cross_layer: 5 file: select.c
if ( pOrderBy )  location: 3188 cross_layer: 5 file: select.c
pOrderBy -> a [ nOrderBy ++ ] . u . x . iOrderByCol = ( u16 ) i; location: 3188 cross_layer: 5 file: select.c
aPermute = sqlite3DbMallocRawNN ( db , sizeof ( int ) * ( nOrderBy + 1 ) ); location: 3200 cross_layer: 5 file: select.c
if ( aPermute )  location: 3201 cross_layer: 5 file: select.c
aPermute [ 0 ] = nOrderBy; location: 3203 cross_layer: 5 file: select.c
for(i=1, pItem=pOrderBy->a; i<=nOrderBy; i++, pItem++) location: 3204 cross_layer: 5 file: select.c
assert ( pItem -> u . x . iOrderByCol > 0 ); location: 3205 cross_layer: 5 file: select.c
assert ( pItem -> u . x . iOrderByCol <= p -> pEList -> nExpr ); location: 3206 cross_layer: 5 file: select.c
aPermute [ i ] = pItem -> u . x . iOrderByCol - 1; location: 3207 cross_layer: 5 file: select.c
pKeyMerge = multiSelectOrderByKeyInfo ( pParse , p , 1 ); location: 3209 cross_layer: 5 file: select.c
p -> pOrderBy = pOrderBy; location: 3216 cross_layer: 5 file: select.c
pPrior -> pOrderBy = sqlite3ExprListDup ( pParse -> db , pOrderBy , 0 ); location: 3217 cross_layer: 5 file: select.c
if ( op == TK_ALL )  location: 3223 cross_layer: 5 file: select.c
int nExpr = p -> pEList -> nExpr ; location: 3226 cross_layer: 5 file: select.c
assert ( nOrderBy >= nExpr || db -> mallocFailed ); location: 3227 cross_layer: 5 file: select.c
regPrev = pParse -> nMem + 1; location: 3228 cross_layer: 5 file: select.c
pParse -> nMem += nExpr + 1; location: 3229 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regPrev ); location: 3230 cross_layer: 5 file: select.c
pKeyDup = sqlite3KeyInfoAlloc ( db , nExpr , 1 ); location: 3231 cross_layer: 5 file: select.c
if ( pKeyDup )  location: 3232 cross_layer: 5 file: select.c
assert ( sqlite3KeyInfoIsWriteable ( pKeyDup ) ); location: 3233 cross_layer: 5 file: select.c
for(i=0; i<nExpr; i++) location: 3234 cross_layer: 5 file: select.c
pKeyDup -> aColl [ i ] = multiSelectCollSeq ( pParse , p , i ); location: 3235 cross_layer: 5 file: select.c
pKeyDup -> aSortFlags [ i ] = 0; location: 3236 cross_layer: 5 file: select.c
p -> pPrior = 0; location: 3243 cross_layer: 5 file: select.c
pPrior -> pNext = 0; location: 3244 cross_layer: 5 file: select.c
sqlite3ResolveOrderGroupBy ( pParse , p , p -> pOrderBy , "ORDER" ); location: 3245 cross_layer: 5 file: select.c
if ( pPrior -> pPrior == 0 )  location: 3246 cross_layer: 5 file: select.c
sqlite3ResolveOrderGroupBy ( pParse , pPrior , pPrior -> pOrderBy , "ORDER" ); location: 3247 cross_layer: 5 file: select.c
computeLimitRegisters ( pParse , p , labelEnd ); location: 3251 cross_layer: 5 file: select.c
if ( p -> iLimit && op == TK_ALL )  location: 3252 cross_layer: 5 file: select.c
regLimitA = ++ pParse -> nMem; location: 3253 cross_layer: 5 file: select.c
regLimitB = ++ pParse -> nMem; location: 3254 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , p -> iOffset ? p -> iOffset + 1 : p -> iLimit , regLimitA ); location: 3255 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Copy , regLimitA , regLimitB ); location: 3257 cross_layer: 5 file: select.c
sqlite3ExprDelete ( db , p -> pLimit ); location: 3261 cross_layer: 5 file: select.c
p -> pLimit = 0; location: 3262 cross_layer: 5 file: select.c
regAddrA = ++ pParse -> nMem; location: 3264 cross_layer: 5 file: select.c
regAddrB = ++ pParse -> nMem; location: 3265 cross_layer: 5 file: select.c
regOutA = ++ pParse -> nMem; location: 3266 cross_layer: 5 file: select.c
regOutB = ++ pParse -> nMem; location: 3267 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & destA , SRT_Coroutine , regAddrA ); location: 3268 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & destB , SRT_Coroutine , regAddrB ); location: 3269 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MERGE (%s)" , selectOpName ( p -> op ) ) ); location: 3271 cross_layer: 5 file: select.c
addrSelectA = sqlite3VdbeCurrentAddr ( v ) + 1; location: 3276 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeAddOp3 ( v , OP_InitCoroutine , regAddrA , 0 , addrSelectA ); location: 3277 cross_layer: 5 file: select.c
VdbeComment ( ( v , "left SELECT" ) ); location: 3278 cross_layer: 5 file: select.c
pPrior -> iLimit = regLimitA; location: 3279 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "LEFT" ) ); location: 3280 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pPrior , & destA ); location: 3281 cross_layer: 5 file: select.c
sqlite3VdbeEndCoroutine ( v , regAddrA ); location: 3282 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 3283 cross_layer: 5 file: select.c
addrSelectB = sqlite3VdbeCurrentAddr ( v ) + 1; location: 3288 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeAddOp3 ( v , OP_InitCoroutine , regAddrB , 0 , addrSelectB ); location: 3289 cross_layer: 5 file: select.c
VdbeComment ( ( v , "right SELECT" ) ); location: 3290 cross_layer: 5 file: select.c
savedLimit = p -> iLimit; location: 3291 cross_layer: 5 file: select.c
savedOffset = p -> iOffset; location: 3292 cross_layer: 5 file: select.c
p -> iLimit = regLimitB; location: 3293 cross_layer: 5 file: select.c
p -> iOffset = 0; location: 3294 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "RIGHT" ) ); location: 3295 cross_layer: 5 file: select.c
sqlite3Select ( pParse , p , & destB ); location: 3296 cross_layer: 5 file: select.c
p -> iLimit = savedLimit; location: 3297 cross_layer: 5 file: select.c
p -> iOffset = savedOffset; location: 3298 cross_layer: 5 file: select.c
sqlite3VdbeEndCoroutine ( v , regAddrB ); location: 3299 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "Output routine for A" ) ); location: 3304 cross_layer: 5 file: select.c
addrOutA = generateOutputSubroutine ( pParse , p , & destA , pDest , regOutA , regPrev , pKeyDup , labelEnd ); location: 3305 cross_layer: 5 file: select.c
if ( op == TK_ALL || op == TK_UNION )  location: 3312 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "Output routine for B" ) ); location: 3313 cross_layer: 5 file: select.c
addrOutB = generateOutputSubroutine ( pParse , p , & destB , pDest , regOutB , regPrev , pKeyDup , labelEnd ); location: 3314 cross_layer: 5 file: select.c
sqlite3KeyInfoUnref ( pKeyDup ); location: 3318 cross_layer: 5 file: select.c
if ( op == TK_EXCEPT || op == TK_INTERSECT )  location: 3323 cross_layer: 5 file: select.c
addrEofA_noB = addrEofA = labelEnd; location: 3324 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "eof-A subroutine" ) ); location: 3326 cross_layer: 5 file: select.c
addrEofA = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutB , addrOutB ); location: 3327 cross_layer: 5 file: select.c
addrEofA_noB = sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , labelEnd ); location: 3328 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3329 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , addrEofA ); location: 3330 cross_layer: 5 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 3331 cross_layer: 5 file: select.c
if ( op == TK_INTERSECT )  location: 3337 cross_layer: 5 file: select.c
addrEofB = addrEofA; location: 3338 cross_layer: 5 file: select.c
if ( p -> nSelectRow > pPrior -> nSelectRow )  location: 3339 cross_layer: 5 file: select.c
p -> nSelectRow = pPrior -> nSelectRow; location: 3339 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "eof-B subroutine" ) ); location: 3341 cross_layer: 5 file: select.c
addrEofB = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutA , addrOutA ); location: 3342 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , labelEnd ); location: 3343 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3343 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , addrEofB ); location: 3344 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "A-lt-B subroutine" ) ); location: 3349 cross_layer: 5 file: select.c
addrAltB = sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutA , addrOutA ); location: 3350 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA ); location: 3351 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3351 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3352 cross_layer: 5 file: select.c
if ( op == TK_ALL )  location: 3356 cross_layer: 5 file: select.c
addrAeqB = addrAltB; location: 3357 cross_layer: 5 file: select.c
if ( op == TK_INTERSECT )  location: 3358 cross_layer: 5 file: select.c
addrAeqB = addrAltB; location: 3359 cross_layer: 5 file: select.c
addrAltB ++; location: 3360 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "A-eq-B subroutine" ) ); location: 3362 cross_layer: 5 file: select.c
addrAeqB = sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA ); location: 3363 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3364 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3365 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "A-gt-B subroutine" ) ); location: 3370 cross_layer: 5 file: select.c
addrAgtB = sqlite3VdbeCurrentAddr ( v ); location: 3371 cross_layer: 5 file: select.c
if ( op == TK_ALL || op == TK_UNION )  location: 3372 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutB , addrOutB ); location: 3373 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , addrEofB ); location: 3375 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3375 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , labelCmpr ); location: 3376 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 3380 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrA , addrEofA_noB ); location: 3381 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3381 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Yield , regAddrB , addrEofB ); location: 3382 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3382 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , labelCmpr ); location: 3386 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Permutation , 0 , 0 , 0 , ( char * ) aPermute , P4_INTARRAY ); location: 3387 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , destA . iSdst , destB . iSdst , nOrderBy , ( char * ) pKeyMerge , P4_KEYINFO ); location: 3388 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_PERMUTE ); location: 3390 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addrAltB , addrAeqB , addrAgtB ); location: 3391 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 3391 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , labelEnd ); location: 3395 cross_layer: 5 file: select.c
if ( p -> pPrior )  location: 3399 cross_layer: 5 file: select.c
sqlite3SelectDelete ( db , p -> pPrior ); location: 3400 cross_layer: 5 file: select.c
p -> pPrior = pPrior; location: 3402 cross_layer: 5 file: select.c
pPrior -> pNext = p; location: 3403 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 3407 cross_layer: 5 file: select.c
return pParse -> nErr != 0 ; location: 3408 cross_layer: 5 file: select.c
if ( pPrior -> pPrior == 0 )  location: 2591 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "COMPOUND QUERY" ) ); location: 2592 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "LEFT-MOST SUBQUERY" ) ); location: 2593 cross_layer: 4 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 4 file: select.c
assert ( ! pPrior -> pLimit ); location: 2603 cross_layer: 4 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 4 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 4 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 4 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 4 file: select.c
int sqlite3Select(
Parse *pParse,         /* The parser context */
Select *p,             /* The SELECT statement being coded. */
SelectDest *pDest      /* What to do with the query results */
) location: 5676 cross_layer: 5 file: select.c
db = pParse -> db; location: 5695 cross_layer: 5 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 5696 cross_layer: 5 file: select.c
if ( p == 0 || db -> mallocFailed || pParse -> nErr )  location: 5697 cross_layer: 5 file: select.c
if ( sqlite3AuthCheck ( pParse , SQLITE_SELECT , 0 , 0 , 0 ) )  location: 5700 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "begin processing:\n" , pParse -> addrExplain ) ); location: 5703 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5705 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistFifo ); location: 5709 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Fifo ); location: 5710 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistQueue ); location: 5711 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Queue ); location: 5712 cross_layer: 5 file: select.c
if ( IgnorableOrderby ( pDest ) )  location: 5713 cross_layer: 5 file: select.c
assert ( pDest -> eDest == SRT_Exists || pDest -> eDest == SRT_Union || pDest -> eDest == SRT_Except || pDest -> eDest == SRT_Discard || pDest -> eDest == SRT_Queue || pDest -> eDest == SRT_DistFifo || pDest -> eDest == SRT_DistQueue || pDest -> eDest == SRT_Fifo ); location: 5714 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , p -> pOrderBy ); location: 5720 cross_layer: 5 file: select.c
p -> pOrderBy = 0; location: 5721 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 5722 cross_layer: 5 file: select.c
sqlite3SelectPrep ( pParse , p , 0 ); location: 5724 cross_layer: 5 file: select.c
if ( pParse -> nErr || db -> mallocFailed )  location: 5725 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 5728 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after name resolution:\n" ) ); location: 5731 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5732 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_Output )  location: 5736 cross_layer: 5 file: select.c
generateColumnNames ( pParse , p ); location: 5737 cross_layer: 5 file: select.c
if ( sqlite3WindowRewrite ( pParse , p ) )  location: 5741 cross_layer: 5 file: select.c
if ( p -> pWin && ( sqlite3SelectTrace & 0x108 ) != 0 )  location: 5745 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after window rewrite:\n" ) ); location: 5746 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5747 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5751 cross_layer: 5 file: select.c
isAgg = ( p -> selFlags & SF_Aggregate ) != 0; location: 5752 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5754 cross_layer: 5 file: select.c
for(i=0; !p->pPrior && i<pTabList->nSrc; i++) location: 5760 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5761 cross_layer: 5 file: select.c
Select * pSub = pItem -> pSelect ; location: 5762 cross_layer: 5 file: select.c
Table * pTab = pItem -> pTab ; location: 5763 cross_layer: 5 file: select.c
if ( ( pItem -> fg . jointype & JT_LEFT ) != 0 && sqlite3ExprImpliesNonNullRow ( p -> pWhere , pItem -> iCursor ) && OptimizationEnabled ( db , SQLITE_SimplifyJoin ) )  location: 5768 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "LEFT-JOIN simplifies to JOIN on term %d\n" , i ) ); location: 5772 cross_layer: 5 file: select.c
pItem -> fg . jointype &= ~ ( JT_LEFT | JT_OUTER ); location: 5774 cross_layer: 5 file: select.c
unsetJoinExpr ( p -> pWhere , pItem -> iCursor ); location: 5775 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5779 cross_layer: 5 file: select.c
if ( pTab -> nCol != pSub -> pEList -> nExpr )  location: 5783 cross_layer: 5 file: select.c
sqlite3ErrorMsg ( pParse , "expected %d columns for '%s' but got %d" , pTab -> nCol , pTab -> zName , pSub -> pEList -> nExpr ); location: 5784 cross_layer: 5 file: select.c
if ( ( pSub -> selFlags & SF_Aggregate ) != 0 )  location: 5796 cross_layer: 5 file: select.c
assert ( pSub -> pGroupBy == 0 ); location: 5797 cross_layer: 5 file: select.c
if ( pSub -> pOrderBy != 0 && i == 0 && ( p -> selFlags & SF_ComplexResult ) != 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5817 cross_layer: 5 file: select.c
if ( flattenSubquery ( pParse , p , i , isAgg ) )  location: 5826 cross_layer: 5 file: select.c
if ( pParse -> nErr )  location: 5827 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5831 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5832 cross_layer: 5 file: select.c
if ( ! IgnorableOrderby ( pDest ) )  location: 5833 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5834 cross_layer: 5 file: select.c
if ( p -> pPrior )  location: 5843 cross_layer: 5 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end compound-select processing\n" ) ); location: 5846 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 5847 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5848 cross_layer: 5 file: select.c
if ( p -> pNext == 0 )  location: 5851 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 5851 cross_layer: 5 file: select.c
return rc ; location: 5852 cross_layer: 5 file: select.c
if ( pTabList -> nSrc > 1 && OptimizationEnabled ( db , SQLITE_PropagateConst ) && propagateConstants ( pParse , p ) )  location: 5861 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After constant propagation:\n" ) ); location: 5867 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5868 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Constant propagation not helpful\n" ) ); location: 5872 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_QueryFlattener | SQLITE_CountOfView ) && countOfViewOptimization ( pParse , p ) )  location: 5876 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5879 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 5880 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5881 cross_layer: 5 file: select.c
for(i=0; i<pTabList->nSrc; i++) location: 5889 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5890 cross_layer: 5 file: select.c
if ( pItem -> colUsed == 0 && pItem -> zName != 0 )  location: 5913 cross_layer: 5 file: select.c
sqlite3AuthCheck ( pParse , SQLITE_READ , pItem -> zName , "" , pItem -> zDatabase ); location: 5914 cross_layer: 5 file: select.c
pSub = pItem -> pSelect; location: 5920 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5921 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub != 0 ); location: 5935 cross_layer: 5 file: select.c
pParse -> nHeight += sqlite3SelectExprHeight ( p ); location: 5944 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_PushDown ) && pushDownWhereTerms ( pParse , pSub , p -> pWhere , pItem -> iCursor , ( pItem -> fg . jointype & JT_OUTER ) != 0 ) )  location: 5949 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After WHERE-clause push-down into subquery %d:\n" , pSub -> selId ) ); location: 5955 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5957 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Push-down not possible\n" ) ); location: 5961 cross_layer: 5 file: select.c
zSavedAuthContext = pParse -> zAuthContext; location: 5964 cross_layer: 5 file: select.c
pParse -> zAuthContext = pItem -> zName; location: 5965 cross_layer: 5 file: select.c
if ( i == 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5976 cross_layer: 5 file: select.c
int addrTop = sqlite3VdbeCurrentAddr ( v ) + 1 ; location: 5983 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 5985 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_InitCoroutine , pItem -> regReturn , 0 , addrTop ); location: 5986 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , pItem -> pTab -> zName ) ); location: 5987 cross_layer: 5 file: select.c
pItem -> addrFillSub = addrTop; location: 5988 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_Coroutine , pItem -> regReturn ); location: 5989 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "CO-ROUTINE %u" , pSub -> selId ) ); location: 5990 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 5 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 5 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 5 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 5 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 5 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 5 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 5 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 5 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 5 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 5 file: select.c
if ( pPrior )  location: 6023 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 5 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 5 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 5 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 5 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 5 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 5 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 5 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 6047 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6048 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy; location: 6049 cross_layer: 5 file: select.c
pHaving = p -> pHaving; location: 6050 cross_layer: 5 file: select.c
sDistinct . isTnct = ( p -> selFlags & SF_Distinct ) != 0; location: 6051 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6056 cross_layer: 5 file: select.c
if ( ( p -> selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct && sqlite3ExprListCompare ( sSort . pOrderBy , pEList , - 1 ) == 0 && p -> pWin == 0 )  location: 6075 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 6079 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 5 file: select.c
assert ( sDistinct . isTnct ); location: 6084 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6102 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 5 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 5 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 5 file: select.c
sSort . addrSortIndex = - 1; location: 6113 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_EphemTab )  location: 6118 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 5 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 5 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 5 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 5 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 5 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 5 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 5 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 5 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 5 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 5 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_NOOP; location: 6145 cross_layer: 5 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 5 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 5 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 5 file: select.c
if ( pWin )  location: 6154 cross_layer: 5 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 5 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 5 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 5 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 5 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 5 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 5 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 5 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 5 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 5 file: select.c
if ( pWin )  location: 6190 cross_layer: 5 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 5 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 5 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 5 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 5 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 5 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 5 file: select.c
for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++) location: 6242 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 5 file: select.c
for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++) location: 6245 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 5 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 5 file: select.c
p -> nSelectRow = 66; location: 6249 cross_layer: 5 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 5 file: select.c
for(ii=0; ii<pGroupBy->nExpr; ii++) location: 6266 cross_layer: 5 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 5 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 5 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 5 file: select.c
p -> nSelectRow = 0; location: 6276 cross_layer: 5 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 5 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 5 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 5 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 5 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 5 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 5 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 5 file: select.c
if ( pHaving )  location: 6296 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 5 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 5 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 5 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 5 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 5 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 5 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 5 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 5 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6312 cross_layer: 5 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 5 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 5 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 5 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 5 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6331 cross_layer: 5 file: select.c
for(ii=0; ii<sAggInfo.nColumn; ii++) location: 6332 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 5 file: select.c
for(ii=0; ii<sAggInfo.nFunc; ii++) location: 6337 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 5 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 5 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 5 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 5 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 5 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 5 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 5 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 5 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 5 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 5 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 5 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 5 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 5 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 5 file: select.c
j = nGroupBy; location: 6422 cross_layer: 5 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6423 cross_layer: 5 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 5 file: select.c
nCol ++; location: 6425 cross_layer: 5 file: select.c
j ++; location: 6426 cross_layer: 5 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 5 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 5 file: select.c
j = nGroupBy; location: 6431 cross_layer: 5 file: select.c
for(i=0; i<sAggInfo.nColumn; i++) location: 6432 cross_layer: 5 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 5 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 5 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 5 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 5 file: select.c
j ++; location: 6438 cross_layer: 5 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 5 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 5 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 5 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 5 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 5 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 5 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 5 file: select.c
for(j=0; j<pGroupBy->nExpr; j++) location: 6479 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 5 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 5 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 5 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 5 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 5 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 5 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 5 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 5 file: select.c
if ( ( pTab = isSimpleCount ( p , & sAggInfo ) ) != 0 )  location: 6573 cross_layer: 5 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 5 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 5 file: select.c
int iRoot = pTab -> tnum ; location: 6592 cross_layer: 5 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 5 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 5 file: select.c
if ( ! HasRowid ( pTab ) )  location: 6606 cross_layer: 5 file: select.c
pBest = sqlite3PrimaryKeyIndex ( pTab ); location: 6606 cross_layer: 5 file: select.c
for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext) location: 6607 cross_layer: 5 file: select.c
if ( pIdx -> bUnordered == 0 && pIdx -> szIdxRow < pTab -> szTabRow && pIdx -> pPartIdxWhere == 0 && ( ! pBest || pIdx -> szIdxRow < pBest -> szIdxRow ) )  location: 6608 cross_layer: 5 file: select.c
pBest = pIdx; location: 6613 cross_layer: 5 file: select.c
if ( pBest )  location: 6616 cross_layer: 5 file: select.c
iRoot = pBest -> tnum; location: 6617 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 5 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 5 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 5 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 5 file: select.c
for(i=0; i<sAggInfo.nFunc; i++) location: 6644 cross_layer: 5 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 5 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 5 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 5 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 5 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 5 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 5 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 5 file: select.c
if ( regAcc )  location: 6676 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 5 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 5 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 5 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 5 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 5 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6727 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 5 file: select.c
return rc ; location: 6731 cross_layer: 5 file: select.c
p -> pLimit = 0; location: 2608 cross_layer: 4 file: select.c
if ( rc )  location: 2609 cross_layer: 4 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 4 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 4 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 4 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 4 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2616 cross_layer: 4 file: select.c
VdbeComment ( ( v , "Jump ahead if LIMIT reached" ) ); location: 2617 cross_layer: 4 file: select.c
if ( p -> iOffset )  location: 2618 cross_layer: 4 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , p -> iLimit , p -> iOffset + 1 , p -> iOffset ); location: 2619 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "UNION ALL" ) ); location: 2623 cross_layer: 4 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 4 file: select.c
int sqlite3Select(
Parse *pParse,         /* The parser context */
Select *p,             /* The SELECT statement being coded. */
SelectDest *pDest      /* What to do with the query results */
) location: 5676 cross_layer: 5 file: select.c
db = pParse -> db; location: 5695 cross_layer: 5 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 5696 cross_layer: 5 file: select.c
if ( p == 0 || db -> mallocFailed || pParse -> nErr )  location: 5697 cross_layer: 5 file: select.c
if ( sqlite3AuthCheck ( pParse , SQLITE_SELECT , 0 , 0 , 0 ) )  location: 5700 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "begin processing:\n" , pParse -> addrExplain ) ); location: 5703 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5705 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistFifo ); location: 5709 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Fifo ); location: 5710 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistQueue ); location: 5711 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Queue ); location: 5712 cross_layer: 5 file: select.c
if ( IgnorableOrderby ( pDest ) )  location: 5713 cross_layer: 5 file: select.c
assert ( pDest -> eDest == SRT_Exists || pDest -> eDest == SRT_Union || pDest -> eDest == SRT_Except || pDest -> eDest == SRT_Discard || pDest -> eDest == SRT_Queue || pDest -> eDest == SRT_DistFifo || pDest -> eDest == SRT_DistQueue || pDest -> eDest == SRT_Fifo ); location: 5714 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , p -> pOrderBy ); location: 5720 cross_layer: 5 file: select.c
p -> pOrderBy = 0; location: 5721 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 5722 cross_layer: 5 file: select.c
sqlite3SelectPrep ( pParse , p , 0 ); location: 5724 cross_layer: 5 file: select.c
if ( pParse -> nErr || db -> mallocFailed )  location: 5725 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 5728 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after name resolution:\n" ) ); location: 5731 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5732 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_Output )  location: 5736 cross_layer: 5 file: select.c
generateColumnNames ( pParse , p ); location: 5737 cross_layer: 5 file: select.c
if ( sqlite3WindowRewrite ( pParse , p ) )  location: 5741 cross_layer: 5 file: select.c
if ( p -> pWin && ( sqlite3SelectTrace & 0x108 ) != 0 )  location: 5745 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after window rewrite:\n" ) ); location: 5746 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5747 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5751 cross_layer: 5 file: select.c
isAgg = ( p -> selFlags & SF_Aggregate ) != 0; location: 5752 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5754 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5761 cross_layer: 5 file: select.c
Select * pSub = pItem -> pSelect ; location: 5762 cross_layer: 5 file: select.c
Table * pTab = pItem -> pTab ; location: 5763 cross_layer: 5 file: select.c
if ( ( pItem -> fg . jointype & JT_LEFT ) != 0 && sqlite3ExprImpliesNonNullRow ( p -> pWhere , pItem -> iCursor ) && OptimizationEnabled ( db , SQLITE_SimplifyJoin ) )  location: 5768 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "LEFT-JOIN simplifies to JOIN on term %d\n" , i ) ); location: 5772 cross_layer: 5 file: select.c
pItem -> fg . jointype &= ~ ( JT_LEFT | JT_OUTER ); location: 5774 cross_layer: 5 file: select.c
unsetJoinExpr ( p -> pWhere , pItem -> iCursor ); location: 5775 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5779 cross_layer: 5 file: select.c
if ( pTab -> nCol != pSub -> pEList -> nExpr )  location: 5783 cross_layer: 5 file: select.c
sqlite3ErrorMsg ( pParse , "expected %d columns for '%s' but got %d" , pTab -> nCol , pTab -> zName , pSub -> pEList -> nExpr ); location: 5784 cross_layer: 5 file: select.c
if ( ( pSub -> selFlags & SF_Aggregate ) != 0 )  location: 5796 cross_layer: 5 file: select.c
assert ( pSub -> pGroupBy == 0 ); location: 5797 cross_layer: 5 file: select.c
if ( pSub -> pOrderBy != 0 && i == 0 && ( p -> selFlags & SF_ComplexResult ) != 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5817 cross_layer: 5 file: select.c
if ( flattenSubquery ( pParse , p , i , isAgg ) )  location: 5826 cross_layer: 5 file: select.c
if ( pParse -> nErr )  location: 5827 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5831 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5832 cross_layer: 5 file: select.c
if ( ! IgnorableOrderby ( pDest ) )  location: 5833 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5834 cross_layer: 5 file: select.c
if ( p -> pPrior )  location: 5843 cross_layer: 5 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end compound-select processing\n" ) ); location: 5846 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 5847 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5848 cross_layer: 5 file: select.c
if ( p -> pNext == 0 )  location: 5851 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 5851 cross_layer: 5 file: select.c
return rc ; location: 5852 cross_layer: 5 file: select.c
if ( pTabList -> nSrc > 1 && OptimizationEnabled ( db , SQLITE_PropagateConst ) && propagateConstants ( pParse , p ) )  location: 5861 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After constant propagation:\n" ) ); location: 5867 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5868 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Constant propagation not helpful\n" ) ); location: 5872 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_QueryFlattener | SQLITE_CountOfView ) && countOfViewOptimization ( pParse , p ) )  location: 5876 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5879 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 5880 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5881 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5890 cross_layer: 5 file: select.c
if ( pItem -> colUsed == 0 && pItem -> zName != 0 )  location: 5913 cross_layer: 5 file: select.c
sqlite3AuthCheck ( pParse , SQLITE_READ , pItem -> zName , "" , pItem -> zDatabase ); location: 5914 cross_layer: 5 file: select.c
pSub = pItem -> pSelect; location: 5920 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5921 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub != 0 ); location: 5935 cross_layer: 5 file: select.c
pParse -> nHeight += sqlite3SelectExprHeight ( p ); location: 5944 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_PushDown ) && pushDownWhereTerms ( pParse , pSub , p -> pWhere , pItem -> iCursor , ( pItem -> fg . jointype & JT_OUTER ) != 0 ) )  location: 5949 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After WHERE-clause push-down into subquery %d:\n" , pSub -> selId ) ); location: 5955 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5957 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Push-down not possible\n" ) ); location: 5961 cross_layer: 5 file: select.c
zSavedAuthContext = pParse -> zAuthContext; location: 5964 cross_layer: 5 file: select.c
pParse -> zAuthContext = pItem -> zName; location: 5965 cross_layer: 5 file: select.c
if ( i == 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5976 cross_layer: 5 file: select.c
int addrTop = sqlite3VdbeCurrentAddr ( v ) + 1 ; location: 5983 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 5985 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_InitCoroutine , pItem -> regReturn , 0 , addrTop ); location: 5986 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , pItem -> pTab -> zName ) ); location: 5987 cross_layer: 5 file: select.c
pItem -> addrFillSub = addrTop; location: 5988 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_Coroutine , pItem -> regReturn ); location: 5989 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "CO-ROUTINE %u" , pSub -> selId ) ); location: 5990 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 5 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 5 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 5 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 5 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 5 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 5 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 5 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 5 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 5 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 5 file: select.c
if ( pPrior )  location: 6023 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 5 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 5 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 5 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 5 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 5 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 5 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 5 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 6047 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6048 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy; location: 6049 cross_layer: 5 file: select.c
pHaving = p -> pHaving; location: 6050 cross_layer: 5 file: select.c
sDistinct . isTnct = ( p -> selFlags & SF_Distinct ) != 0; location: 6051 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6056 cross_layer: 5 file: select.c
if ( ( p -> selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct && sqlite3ExprListCompare ( sSort . pOrderBy , pEList , - 1 ) == 0 && p -> pWin == 0 )  location: 6075 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 6079 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 5 file: select.c
assert ( sDistinct . isTnct ); location: 6084 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6102 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 5 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 5 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 5 file: select.c
sSort . addrSortIndex = - 1; location: 6113 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_EphemTab )  location: 6118 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 5 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 5 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 5 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 5 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 5 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 5 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 5 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 5 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 5 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 5 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_NOOP; location: 6145 cross_layer: 5 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 5 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 5 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 5 file: select.c
if ( pWin )  location: 6154 cross_layer: 5 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 5 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 5 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 5 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 5 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 5 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 5 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 5 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 5 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 5 file: select.c
if ( pWin )  location: 6190 cross_layer: 5 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 5 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 5 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 5 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 5 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 5 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 5 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 5 file: select.c
p -> nSelectRow = 66; location: 6249 cross_layer: 5 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 5 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 5 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 5 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 5 file: select.c
p -> nSelectRow = 0; location: 6276 cross_layer: 5 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 5 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 5 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 5 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 5 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 5 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 5 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 5 file: select.c
if ( pHaving )  location: 6296 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 5 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 5 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 5 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 5 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 5 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 5 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 5 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 5 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 5 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 5 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 5 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 5 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6331 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 5 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 5 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 5 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 5 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 5 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 5 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 5 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 5 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 5 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 5 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 5 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 5 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 5 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 5 file: select.c
j = nGroupBy; location: 6422 cross_layer: 5 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 5 file: select.c
nCol ++; location: 6425 cross_layer: 5 file: select.c
j ++; location: 6426 cross_layer: 5 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 5 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 5 file: select.c
j = nGroupBy; location: 6431 cross_layer: 5 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 5 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 5 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 5 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 5 file: select.c
j ++; location: 6438 cross_layer: 5 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 5 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 5 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 5 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 5 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 5 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 5 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 5 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 5 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 5 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 5 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 5 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 5 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 5 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 5 file: select.c
if ( ( pTab = isSimpleCount ( p , & sAggInfo ) ) != 0 )  location: 6573 cross_layer: 5 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 5 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 5 file: select.c
int iRoot = pTab -> tnum ; location: 6592 cross_layer: 5 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 5 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 5 file: select.c
if ( ! HasRowid ( pTab ) )  location: 6606 cross_layer: 5 file: select.c
pBest = sqlite3PrimaryKeyIndex ( pTab ); location: 6606 cross_layer: 5 file: select.c
if ( pIdx -> bUnordered == 0 && pIdx -> szIdxRow < pTab -> szTabRow && pIdx -> pPartIdxWhere == 0 && ( ! pBest || pIdx -> szIdxRow < pBest -> szIdxRow ) )  location: 6608 cross_layer: 5 file: select.c
pBest = pIdx; location: 6613 cross_layer: 5 file: select.c
if ( pBest )  location: 6616 cross_layer: 5 file: select.c
iRoot = pBest -> tnum; location: 6617 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 5 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 5 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 5 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 5 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 5 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 5 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 5 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 5 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 5 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 5 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 5 file: select.c
if ( regAcc )  location: 6676 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 5 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 5 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 5 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 5 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 5 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6727 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 5 file: select.c
return rc ; location: 6731 cross_layer: 5 file: select.c
testcase ( rc != SQLITE_OK ); location: 2625 cross_layer: 4 file: select.c
pDelete = p -> pPrior; location: 2626 cross_layer: 4 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 4 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 4 file: select.c
if ( addr )  location: 2635 cross_layer: 4 file: select.c
sqlite3VdbeJumpHere ( v , addr ); location: 2636 cross_layer: 4 file: select.c
testcase ( p -> op == TK_EXCEPT ); location: 2649 cross_layer: 4 file: select.c
testcase ( p -> op == TK_UNION ); location: 2650 cross_layer: 4 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 4 file: select.c
assert ( p -> pLimit == 0 ); location: 2656 cross_layer: 4 file: select.c
unionTab = dest . iSDParm; location: 2657 cross_layer: 4 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 4 file: select.c
assert ( p -> pOrderBy == 0 ); location: 2663 cross_layer: 4 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 4 file: select.c
assert ( p -> addrOpenEphm [ 0 ] == - 1 ); location: 2665 cross_layer: 4 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 4 file: select.c
findRightmost ( p ) -> selFlags |= SF_UsesEphemeral; location: 2667 cross_layer: 4 file: select.c
static Select *findRightmost(Select *p) location: 194 cross_layer: 5 file: select.c
while ( p -> pNext )  location: 195 cross_layer: 5 file: select.c
p = p -> pNext; location: 195 cross_layer: 5 file: select.c
return p ; location: 196 cross_layer: 5 file: select.c
assert ( p -> pEList ); location: 2668 cross_layer: 4 file: select.c
assert ( ! pPrior -> pOrderBy ); location: 2673 cross_layer: 4 file: select.c
sqlite3SelectDestInit ( & uniondest , priorOp , unionTab ); location: 2674 cross_layer: 4 file: select.c
void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm) location: 115 cross_layer: 5 file: select.c
pDest -> eDest = ( u8 ) eDest; location: 116 cross_layer: 5 file: select.c
pDest -> iSDParm = iParm; location: 117 cross_layer: 5 file: select.c
pDest -> zAffSdst = 0; location: 118 cross_layer: 5 file: select.c
pDest -> iSdst = 0; location: 119 cross_layer: 5 file: select.c
pDest -> nSdst = 0; location: 120 cross_layer: 5 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 4 file: select.c
int sqlite3Select(
Parse *pParse,         /* The parser context */
Select *p,             /* The SELECT statement being coded. */
SelectDest *pDest      /* What to do with the query results */
) location: 5676 cross_layer: 5 file: select.c
db = pParse -> db; location: 5695 cross_layer: 5 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 5696 cross_layer: 5 file: select.c
if ( p == 0 || db -> mallocFailed || pParse -> nErr )  location: 5697 cross_layer: 5 file: select.c
if ( sqlite3AuthCheck ( pParse , SQLITE_SELECT , 0 , 0 , 0 ) )  location: 5700 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "begin processing:\n" , pParse -> addrExplain ) ); location: 5703 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5705 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistFifo ); location: 5709 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Fifo ); location: 5710 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistQueue ); location: 5711 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Queue ); location: 5712 cross_layer: 5 file: select.c
if ( IgnorableOrderby ( pDest ) )  location: 5713 cross_layer: 5 file: select.c
assert ( pDest -> eDest == SRT_Exists || pDest -> eDest == SRT_Union || pDest -> eDest == SRT_Except || pDest -> eDest == SRT_Discard || pDest -> eDest == SRT_Queue || pDest -> eDest == SRT_DistFifo || pDest -> eDest == SRT_DistQueue || pDest -> eDest == SRT_Fifo ); location: 5714 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , p -> pOrderBy ); location: 5720 cross_layer: 5 file: select.c
p -> pOrderBy = 0; location: 5721 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 5722 cross_layer: 5 file: select.c
sqlite3SelectPrep ( pParse , p , 0 ); location: 5724 cross_layer: 5 file: select.c
if ( pParse -> nErr || db -> mallocFailed )  location: 5725 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 5728 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after name resolution:\n" ) ); location: 5731 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5732 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_Output )  location: 5736 cross_layer: 5 file: select.c
generateColumnNames ( pParse , p ); location: 5737 cross_layer: 5 file: select.c
if ( sqlite3WindowRewrite ( pParse , p ) )  location: 5741 cross_layer: 5 file: select.c
if ( p -> pWin && ( sqlite3SelectTrace & 0x108 ) != 0 )  location: 5745 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after window rewrite:\n" ) ); location: 5746 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5747 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5751 cross_layer: 5 file: select.c
isAgg = ( p -> selFlags & SF_Aggregate ) != 0; location: 5752 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5754 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5761 cross_layer: 5 file: select.c
Select * pSub = pItem -> pSelect ; location: 5762 cross_layer: 5 file: select.c
Table * pTab = pItem -> pTab ; location: 5763 cross_layer: 5 file: select.c
if ( ( pItem -> fg . jointype & JT_LEFT ) != 0 && sqlite3ExprImpliesNonNullRow ( p -> pWhere , pItem -> iCursor ) && OptimizationEnabled ( db , SQLITE_SimplifyJoin ) )  location: 5768 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "LEFT-JOIN simplifies to JOIN on term %d\n" , i ) ); location: 5772 cross_layer: 5 file: select.c
pItem -> fg . jointype &= ~ ( JT_LEFT | JT_OUTER ); location: 5774 cross_layer: 5 file: select.c
unsetJoinExpr ( p -> pWhere , pItem -> iCursor ); location: 5775 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5779 cross_layer: 5 file: select.c
if ( pTab -> nCol != pSub -> pEList -> nExpr )  location: 5783 cross_layer: 5 file: select.c
sqlite3ErrorMsg ( pParse , "expected %d columns for '%s' but got %d" , pTab -> nCol , pTab -> zName , pSub -> pEList -> nExpr ); location: 5784 cross_layer: 5 file: select.c
if ( ( pSub -> selFlags & SF_Aggregate ) != 0 )  location: 5796 cross_layer: 5 file: select.c
assert ( pSub -> pGroupBy == 0 ); location: 5797 cross_layer: 5 file: select.c
if ( pSub -> pOrderBy != 0 && i == 0 && ( p -> selFlags & SF_ComplexResult ) != 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5817 cross_layer: 5 file: select.c
if ( flattenSubquery ( pParse , p , i , isAgg ) )  location: 5826 cross_layer: 5 file: select.c
if ( pParse -> nErr )  location: 5827 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5831 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5832 cross_layer: 5 file: select.c
if ( ! IgnorableOrderby ( pDest ) )  location: 5833 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5834 cross_layer: 5 file: select.c
if ( p -> pPrior )  location: 5843 cross_layer: 5 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end compound-select processing\n" ) ); location: 5846 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 5847 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5848 cross_layer: 5 file: select.c
if ( p -> pNext == 0 )  location: 5851 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 5851 cross_layer: 5 file: select.c
return rc ; location: 5852 cross_layer: 5 file: select.c
if ( pTabList -> nSrc > 1 && OptimizationEnabled ( db , SQLITE_PropagateConst ) && propagateConstants ( pParse , p ) )  location: 5861 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After constant propagation:\n" ) ); location: 5867 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5868 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Constant propagation not helpful\n" ) ); location: 5872 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_QueryFlattener | SQLITE_CountOfView ) && countOfViewOptimization ( pParse , p ) )  location: 5876 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5879 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 5880 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5881 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5890 cross_layer: 5 file: select.c
if ( pItem -> colUsed == 0 && pItem -> zName != 0 )  location: 5913 cross_layer: 5 file: select.c
sqlite3AuthCheck ( pParse , SQLITE_READ , pItem -> zName , "" , pItem -> zDatabase ); location: 5914 cross_layer: 5 file: select.c
pSub = pItem -> pSelect; location: 5920 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5921 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub != 0 ); location: 5935 cross_layer: 5 file: select.c
pParse -> nHeight += sqlite3SelectExprHeight ( p ); location: 5944 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_PushDown ) && pushDownWhereTerms ( pParse , pSub , p -> pWhere , pItem -> iCursor , ( pItem -> fg . jointype & JT_OUTER ) != 0 ) )  location: 5949 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After WHERE-clause push-down into subquery %d:\n" , pSub -> selId ) ); location: 5955 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5957 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Push-down not possible\n" ) ); location: 5961 cross_layer: 5 file: select.c
zSavedAuthContext = pParse -> zAuthContext; location: 5964 cross_layer: 5 file: select.c
pParse -> zAuthContext = pItem -> zName; location: 5965 cross_layer: 5 file: select.c
if ( i == 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5976 cross_layer: 5 file: select.c
int addrTop = sqlite3VdbeCurrentAddr ( v ) + 1 ; location: 5983 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 5985 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_InitCoroutine , pItem -> regReturn , 0 , addrTop ); location: 5986 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , pItem -> pTab -> zName ) ); location: 5987 cross_layer: 5 file: select.c
pItem -> addrFillSub = addrTop; location: 5988 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_Coroutine , pItem -> regReturn ); location: 5989 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "CO-ROUTINE %u" , pSub -> selId ) ); location: 5990 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 5 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 5 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 5 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 5 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 5 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 5 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 5 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 5 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 5 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 5 file: select.c
if ( pPrior )  location: 6023 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 5 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 5 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 5 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 5 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 5 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 5 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 5 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 6047 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6048 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy; location: 6049 cross_layer: 5 file: select.c
pHaving = p -> pHaving; location: 6050 cross_layer: 5 file: select.c
sDistinct . isTnct = ( p -> selFlags & SF_Distinct ) != 0; location: 6051 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6056 cross_layer: 5 file: select.c
if ( ( p -> selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct && sqlite3ExprListCompare ( sSort . pOrderBy , pEList , - 1 ) == 0 && p -> pWin == 0 )  location: 6075 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 6079 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 5 file: select.c
assert ( sDistinct . isTnct ); location: 6084 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6102 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 5 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 5 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 5 file: select.c
sSort . addrSortIndex = - 1; location: 6113 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_EphemTab )  location: 6118 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 5 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 5 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 5 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 5 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 5 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 5 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 5 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 5 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 5 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 5 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_NOOP; location: 6145 cross_layer: 5 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 5 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 5 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 5 file: select.c
if ( pWin )  location: 6154 cross_layer: 5 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 5 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 5 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 5 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 5 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 5 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 5 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 5 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 5 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 5 file: select.c
if ( pWin )  location: 6190 cross_layer: 5 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 5 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 5 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 5 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 5 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 5 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 5 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 5 file: select.c
p -> nSelectRow = 66; location: 6249 cross_layer: 5 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 5 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 5 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 5 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 5 file: select.c
p -> nSelectRow = 0; location: 6276 cross_layer: 5 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 5 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 5 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 5 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 5 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 5 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 5 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 5 file: select.c
if ( pHaving )  location: 6296 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 5 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 5 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 5 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 5 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 5 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 5 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 5 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 5 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 5 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 5 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 5 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 5 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6331 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 5 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 5 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 5 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 5 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 5 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 5 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 5 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 5 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 5 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 5 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 5 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 5 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 5 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 5 file: select.c
j = nGroupBy; location: 6422 cross_layer: 5 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 5 file: select.c
nCol ++; location: 6425 cross_layer: 5 file: select.c
j ++; location: 6426 cross_layer: 5 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 5 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 5 file: select.c
j = nGroupBy; location: 6431 cross_layer: 5 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 5 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 5 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 5 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 5 file: select.c
j ++; location: 6438 cross_layer: 5 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 5 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 5 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 5 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 5 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 5 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 5 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 5 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 5 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 5 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 5 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 5 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 5 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 5 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 5 file: select.c
if ( ( pTab = isSimpleCount ( p , & sAggInfo ) ) != 0 )  location: 6573 cross_layer: 5 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 5 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 5 file: select.c
int iRoot = pTab -> tnum ; location: 6592 cross_layer: 5 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 5 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 5 file: select.c
if ( ! HasRowid ( pTab ) )  location: 6606 cross_layer: 5 file: select.c
pBest = sqlite3PrimaryKeyIndex ( pTab ); location: 6606 cross_layer: 5 file: select.c
if ( pIdx -> bUnordered == 0 && pIdx -> szIdxRow < pTab -> szTabRow && pIdx -> pPartIdxWhere == 0 && ( ! pBest || pIdx -> szIdxRow < pBest -> szIdxRow ) )  location: 6608 cross_layer: 5 file: select.c
pBest = pIdx; location: 6613 cross_layer: 5 file: select.c
if ( pBest )  location: 6616 cross_layer: 5 file: select.c
iRoot = pBest -> tnum; location: 6617 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 5 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 5 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 5 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 5 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 5 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 5 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 5 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 5 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 5 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 5 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 5 file: select.c
if ( regAcc )  location: 6676 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 5 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 5 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 5 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 5 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 5 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6727 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 5 file: select.c
return rc ; location: 6731 cross_layer: 5 file: select.c
if ( rc )  location: 2676 cross_layer: 4 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 4 file: select.c
assert ( p -> op == TK_UNION ); location: 2685 cross_layer: 4 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 4 file: select.c
pLimit = p -> pLimit; location: 2689 cross_layer: 4 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "%s USING TEMP B-TREE" , selectOpName ( p -> op ) ) ); location: 2692 cross_layer: 4 file: select.c
static const char *selectOpName(int id) location: 1366 cross_layer: 5 file: select.c
switch ( id )  location: 1368 cross_layer: 5 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 4 file: select.c
int sqlite3Select(
Parse *pParse,         /* The parser context */
Select *p,             /* The SELECT statement being coded. */
SelectDest *pDest      /* What to do with the query results */
) location: 5676 cross_layer: 5 file: select.c
db = pParse -> db; location: 5695 cross_layer: 5 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 5696 cross_layer: 5 file: select.c
if ( p == 0 || db -> mallocFailed || pParse -> nErr )  location: 5697 cross_layer: 5 file: select.c
if ( sqlite3AuthCheck ( pParse , SQLITE_SELECT , 0 , 0 , 0 ) )  location: 5700 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "begin processing:\n" , pParse -> addrExplain ) ); location: 5703 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5705 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistFifo ); location: 5709 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Fifo ); location: 5710 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistQueue ); location: 5711 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Queue ); location: 5712 cross_layer: 5 file: select.c
if ( IgnorableOrderby ( pDest ) )  location: 5713 cross_layer: 5 file: select.c
assert ( pDest -> eDest == SRT_Exists || pDest -> eDest == SRT_Union || pDest -> eDest == SRT_Except || pDest -> eDest == SRT_Discard || pDest -> eDest == SRT_Queue || pDest -> eDest == SRT_DistFifo || pDest -> eDest == SRT_DistQueue || pDest -> eDest == SRT_Fifo ); location: 5714 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , p -> pOrderBy ); location: 5720 cross_layer: 5 file: select.c
p -> pOrderBy = 0; location: 5721 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 5722 cross_layer: 5 file: select.c
sqlite3SelectPrep ( pParse , p , 0 ); location: 5724 cross_layer: 5 file: select.c
if ( pParse -> nErr || db -> mallocFailed )  location: 5725 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 5728 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after name resolution:\n" ) ); location: 5731 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5732 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_Output )  location: 5736 cross_layer: 5 file: select.c
generateColumnNames ( pParse , p ); location: 5737 cross_layer: 5 file: select.c
if ( sqlite3WindowRewrite ( pParse , p ) )  location: 5741 cross_layer: 5 file: select.c
if ( p -> pWin && ( sqlite3SelectTrace & 0x108 ) != 0 )  location: 5745 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after window rewrite:\n" ) ); location: 5746 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5747 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5751 cross_layer: 5 file: select.c
isAgg = ( p -> selFlags & SF_Aggregate ) != 0; location: 5752 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5754 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5761 cross_layer: 5 file: select.c
Select * pSub = pItem -> pSelect ; location: 5762 cross_layer: 5 file: select.c
Table * pTab = pItem -> pTab ; location: 5763 cross_layer: 5 file: select.c
if ( ( pItem -> fg . jointype & JT_LEFT ) != 0 && sqlite3ExprImpliesNonNullRow ( p -> pWhere , pItem -> iCursor ) && OptimizationEnabled ( db , SQLITE_SimplifyJoin ) )  location: 5768 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "LEFT-JOIN simplifies to JOIN on term %d\n" , i ) ); location: 5772 cross_layer: 5 file: select.c
pItem -> fg . jointype &= ~ ( JT_LEFT | JT_OUTER ); location: 5774 cross_layer: 5 file: select.c
unsetJoinExpr ( p -> pWhere , pItem -> iCursor ); location: 5775 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5779 cross_layer: 5 file: select.c
if ( pTab -> nCol != pSub -> pEList -> nExpr )  location: 5783 cross_layer: 5 file: select.c
sqlite3ErrorMsg ( pParse , "expected %d columns for '%s' but got %d" , pTab -> nCol , pTab -> zName , pSub -> pEList -> nExpr ); location: 5784 cross_layer: 5 file: select.c
if ( ( pSub -> selFlags & SF_Aggregate ) != 0 )  location: 5796 cross_layer: 5 file: select.c
assert ( pSub -> pGroupBy == 0 ); location: 5797 cross_layer: 5 file: select.c
if ( pSub -> pOrderBy != 0 && i == 0 && ( p -> selFlags & SF_ComplexResult ) != 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5817 cross_layer: 5 file: select.c
if ( flattenSubquery ( pParse , p , i , isAgg ) )  location: 5826 cross_layer: 5 file: select.c
if ( pParse -> nErr )  location: 5827 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5831 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5832 cross_layer: 5 file: select.c
if ( ! IgnorableOrderby ( pDest ) )  location: 5833 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5834 cross_layer: 5 file: select.c
if ( p -> pPrior )  location: 5843 cross_layer: 5 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end compound-select processing\n" ) ); location: 5846 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 5847 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5848 cross_layer: 5 file: select.c
if ( p -> pNext == 0 )  location: 5851 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 5851 cross_layer: 5 file: select.c
return rc ; location: 5852 cross_layer: 5 file: select.c
if ( pTabList -> nSrc > 1 && OptimizationEnabled ( db , SQLITE_PropagateConst ) && propagateConstants ( pParse , p ) )  location: 5861 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After constant propagation:\n" ) ); location: 5867 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5868 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Constant propagation not helpful\n" ) ); location: 5872 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_QueryFlattener | SQLITE_CountOfView ) && countOfViewOptimization ( pParse , p ) )  location: 5876 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5879 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 5880 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5881 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5890 cross_layer: 5 file: select.c
if ( pItem -> colUsed == 0 && pItem -> zName != 0 )  location: 5913 cross_layer: 5 file: select.c
sqlite3AuthCheck ( pParse , SQLITE_READ , pItem -> zName , "" , pItem -> zDatabase ); location: 5914 cross_layer: 5 file: select.c
pSub = pItem -> pSelect; location: 5920 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5921 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub != 0 ); location: 5935 cross_layer: 5 file: select.c
pParse -> nHeight += sqlite3SelectExprHeight ( p ); location: 5944 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_PushDown ) && pushDownWhereTerms ( pParse , pSub , p -> pWhere , pItem -> iCursor , ( pItem -> fg . jointype & JT_OUTER ) != 0 ) )  location: 5949 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After WHERE-clause push-down into subquery %d:\n" , pSub -> selId ) ); location: 5955 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5957 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Push-down not possible\n" ) ); location: 5961 cross_layer: 5 file: select.c
zSavedAuthContext = pParse -> zAuthContext; location: 5964 cross_layer: 5 file: select.c
pParse -> zAuthContext = pItem -> zName; location: 5965 cross_layer: 5 file: select.c
if ( i == 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5976 cross_layer: 5 file: select.c
int addrTop = sqlite3VdbeCurrentAddr ( v ) + 1 ; location: 5983 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 5985 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_InitCoroutine , pItem -> regReturn , 0 , addrTop ); location: 5986 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , pItem -> pTab -> zName ) ); location: 5987 cross_layer: 5 file: select.c
pItem -> addrFillSub = addrTop; location: 5988 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_Coroutine , pItem -> regReturn ); location: 5989 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "CO-ROUTINE %u" , pSub -> selId ) ); location: 5990 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 5 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 5 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 5 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 5 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 5 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 5 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 5 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 5 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 5 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 5 file: select.c
if ( pPrior )  location: 6023 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 5 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 5 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 5 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 5 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 5 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 5 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 5 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 6047 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6048 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy; location: 6049 cross_layer: 5 file: select.c
pHaving = p -> pHaving; location: 6050 cross_layer: 5 file: select.c
sDistinct . isTnct = ( p -> selFlags & SF_Distinct ) != 0; location: 6051 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6056 cross_layer: 5 file: select.c
if ( ( p -> selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct && sqlite3ExprListCompare ( sSort . pOrderBy , pEList , - 1 ) == 0 && p -> pWin == 0 )  location: 6075 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 6079 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 5 file: select.c
assert ( sDistinct . isTnct ); location: 6084 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6102 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 5 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 5 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 5 file: select.c
sSort . addrSortIndex = - 1; location: 6113 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_EphemTab )  location: 6118 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 5 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 5 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 5 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 5 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 5 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 5 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 5 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 5 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 5 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 5 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_NOOP; location: 6145 cross_layer: 5 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 5 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 5 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 5 file: select.c
if ( pWin )  location: 6154 cross_layer: 5 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 5 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 5 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 5 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 5 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 5 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 5 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 5 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 5 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 5 file: select.c
if ( pWin )  location: 6190 cross_layer: 5 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 5 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 5 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 5 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 5 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 5 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 5 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 5 file: select.c
p -> nSelectRow = 66; location: 6249 cross_layer: 5 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 5 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 5 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 5 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 5 file: select.c
p -> nSelectRow = 0; location: 6276 cross_layer: 5 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 5 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 5 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 5 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 5 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 5 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 5 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 5 file: select.c
if ( pHaving )  location: 6296 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 5 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 5 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 5 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 5 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 5 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 5 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 5 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 5 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 5 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 5 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 5 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 5 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6331 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 5 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 5 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 5 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 5 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 5 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 5 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 5 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 5 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 5 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 5 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 5 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 5 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 5 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 5 file: select.c
j = nGroupBy; location: 6422 cross_layer: 5 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 5 file: select.c
nCol ++; location: 6425 cross_layer: 5 file: select.c
j ++; location: 6426 cross_layer: 5 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 5 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 5 file: select.c
j = nGroupBy; location: 6431 cross_layer: 5 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 5 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 5 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 5 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 5 file: select.c
j ++; location: 6438 cross_layer: 5 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 5 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 5 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 5 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 5 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 5 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 5 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 5 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 5 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 5 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 5 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 5 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 5 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 5 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 5 file: select.c
if ( ( pTab = isSimpleCount ( p , & sAggInfo ) ) != 0 )  location: 6573 cross_layer: 5 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 5 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 5 file: select.c
int iRoot = pTab -> tnum ; location: 6592 cross_layer: 5 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 5 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 5 file: select.c
if ( ! HasRowid ( pTab ) )  location: 6606 cross_layer: 5 file: select.c
pBest = sqlite3PrimaryKeyIndex ( pTab ); location: 6606 cross_layer: 5 file: select.c
if ( pIdx -> bUnordered == 0 && pIdx -> szIdxRow < pTab -> szTabRow && pIdx -> pPartIdxWhere == 0 && ( ! pBest || pIdx -> szIdxRow < pBest -> szIdxRow ) )  location: 6608 cross_layer: 5 file: select.c
pBest = pIdx; location: 6613 cross_layer: 5 file: select.c
if ( pBest )  location: 6616 cross_layer: 5 file: select.c
iRoot = pBest -> tnum; location: 6617 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 5 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 5 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 5 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 5 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 5 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 5 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 5 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 5 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 5 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 5 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 5 file: select.c
if ( regAcc )  location: 6676 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 5 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 5 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 5 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 5 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 5 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6727 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 5 file: select.c
return rc ; location: 6731 cross_layer: 5 file: select.c
testcase ( rc != SQLITE_OK ); location: 2695 cross_layer: 4 file: select.c
sqlite3ExprListDelete ( db , p -> pOrderBy ); location: 2698 cross_layer: 4 file: select.c
pDelete = p -> pPrior; location: 2699 cross_layer: 4 file: select.c
p -> pPrior = pPrior; location: 2700 cross_layer: 4 file: select.c
p -> pOrderBy = 0; location: 2701 cross_layer: 4 file: select.c
if ( p -> op == TK_UNION )  location: 2702 cross_layer: 4 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2703 cross_layer: 4 file: select.c
sqlite3ExprDelete ( db , p -> pLimit ); location: 2705 cross_layer: 4 file: select.c
p -> pLimit = pLimit; location: 2706 cross_layer: 4 file: select.c
p -> iLimit = 0; location: 2707 cross_layer: 4 file: select.c
p -> iOffset = 0; location: 2708 cross_layer: 4 file: select.c
assert ( unionTab == dest . iSDParm || dest . eDest != priorOp ); location: 2713 cross_layer: 4 file: select.c
if ( dest . eDest != priorOp )  location: 2714 cross_layer: 4 file: select.c
assert ( p -> pEList ); location: 2716 cross_layer: 4 file: select.c
iBreak = sqlite3VdbeMakeLabel ( pParse ); location: 2717 cross_layer: 4 file: select.c
iCont = sqlite3VdbeMakeLabel ( pParse ); location: 2718 cross_layer: 4 file: select.c
computeLimitRegisters ( pParse , p , iBreak ); location: 2719 cross_layer: 4 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 5 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 5 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 5 file: select.c
if ( pLimit )  location: 2168 cross_layer: 5 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 5 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 5 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 5 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 5 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 5 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 5 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 5 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 5 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 5 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 5 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 5 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 5 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Rewind , unionTab , iBreak ); location: 2720 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2720 cross_layer: 4 file: select.c
iStart = sqlite3VdbeCurrentAddr ( v ); location: 2721 cross_layer: 4 file: select.c
selectInnerLoop ( pParse , p , unionTab , 0 , 0 , & dest , iCont , iBreak ); location: 2722 cross_layer: 4 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 5 file: select.c
assert ( v ); location: 887 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 5 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 5 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 5 file: select.c
pSort = 0; location: 890 cross_layer: 5 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 5 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 5 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 5 file: select.c
if ( pSort )  location: 901 cross_layer: 5 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 5 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 5 file: select.c
nPrefixReg ++; location: 903 cross_layer: 5 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 5 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 5 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 5 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 5 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 5 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 5 file: select.c
for(i=0; i<nResultCol; i++) location: 919 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 5 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 5 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 5 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 5 file: select.c
for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++) location: 946 cross_layer: 5 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 5 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 5 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 5 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 5 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 5 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 5 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 5 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 5 file: select.c
for(i=0; i<pEList->nExpr; i++) location: 970 cross_layer: 5 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 5 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 5 file: select.c
nResultCol --; location: 976 cross_layer: 5 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 5 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 5 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 5 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 5 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 5 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 5 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 5 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 5 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 5 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 5 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 5 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 5 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 5 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 5 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 5 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 5 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 5 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 5 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 5 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 5 file: select.c
for(i=0; i<nResultCol; i++) location: 1038 cross_layer: 5 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 5 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 5 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 5 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 5 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 5 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 5 file: select.c
switch ( eDest )  location: 1072 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 5 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 5 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 5 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 5 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 5 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 5 file: select.c
if ( pSort )  location: 1122 cross_layer: 5 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 5 file: select.c
if ( pSort )  location: 1142 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 5 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 5 file: select.c
if ( pSort )  location: 1173 cross_layer: 5 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 5 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 5 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 5 file: select.c
if ( pSort )  location: 1190 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 5 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 5 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 5 file: select.c
assert ( pSO ); location: 1215 cross_layer: 5 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 5 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 5 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 5 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 5 file: select.c
for(i=0; i<nKey; i++) location: 1233 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 5 file: select.c
if ( addrTest )  location: 1241 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 5 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 5 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 2724 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , unionTab , iStart ); location: 2725 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2725 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 2726 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Close , unionTab , 0 ); location: 2727 cross_layer: 4 file: select.c
assert ( p -> op == TK_INTERSECT ); location: 2731 cross_layer: 4 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 4 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 4 file: select.c
assert ( p -> pOrderBy == 0 ); location: 2745 cross_layer: 4 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , tab1 , 0 ); location: 2747 cross_layer: 4 file: select.c
assert ( p -> addrOpenEphm [ 0 ] == - 1 ); location: 2748 cross_layer: 4 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2749 cross_layer: 4 file: select.c
findRightmost ( p ) -> selFlags |= SF_UsesEphemeral; location: 2750 cross_layer: 4 file: select.c
static Select *findRightmost(Select *p) location: 194 cross_layer: 5 file: select.c
while ( p -> pNext )  location: 195 cross_layer: 5 file: select.c
p = p -> pNext; location: 195 cross_layer: 5 file: select.c
return p ; location: 196 cross_layer: 5 file: select.c
assert ( p -> pEList ); location: 2751 cross_layer: 4 file: select.c
sqlite3SelectDestInit ( & intersectdest , SRT_Union , tab1 ); location: 2755 cross_layer: 4 file: select.c
void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm) location: 115 cross_layer: 5 file: select.c
pDest -> eDest = ( u8 ) eDest; location: 116 cross_layer: 5 file: select.c
pDest -> iSDParm = iParm; location: 117 cross_layer: 5 file: select.c
pDest -> zAffSdst = 0; location: 118 cross_layer: 5 file: select.c
pDest -> iSdst = 0; location: 119 cross_layer: 5 file: select.c
pDest -> nSdst = 0; location: 120 cross_layer: 5 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 4 file: select.c
int sqlite3Select(
Parse *pParse,         /* The parser context */
Select *p,             /* The SELECT statement being coded. */
SelectDest *pDest      /* What to do with the query results */
) location: 5676 cross_layer: 5 file: select.c
db = pParse -> db; location: 5695 cross_layer: 5 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 5696 cross_layer: 5 file: select.c
if ( p == 0 || db -> mallocFailed || pParse -> nErr )  location: 5697 cross_layer: 5 file: select.c
if ( sqlite3AuthCheck ( pParse , SQLITE_SELECT , 0 , 0 , 0 ) )  location: 5700 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "begin processing:\n" , pParse -> addrExplain ) ); location: 5703 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5705 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistFifo ); location: 5709 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Fifo ); location: 5710 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistQueue ); location: 5711 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Queue ); location: 5712 cross_layer: 5 file: select.c
if ( IgnorableOrderby ( pDest ) )  location: 5713 cross_layer: 5 file: select.c
assert ( pDest -> eDest == SRT_Exists || pDest -> eDest == SRT_Union || pDest -> eDest == SRT_Except || pDest -> eDest == SRT_Discard || pDest -> eDest == SRT_Queue || pDest -> eDest == SRT_DistFifo || pDest -> eDest == SRT_DistQueue || pDest -> eDest == SRT_Fifo ); location: 5714 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , p -> pOrderBy ); location: 5720 cross_layer: 5 file: select.c
p -> pOrderBy = 0; location: 5721 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 5722 cross_layer: 5 file: select.c
sqlite3SelectPrep ( pParse , p , 0 ); location: 5724 cross_layer: 5 file: select.c
if ( pParse -> nErr || db -> mallocFailed )  location: 5725 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 5728 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after name resolution:\n" ) ); location: 5731 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5732 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_Output )  location: 5736 cross_layer: 5 file: select.c
generateColumnNames ( pParse , p ); location: 5737 cross_layer: 5 file: select.c
if ( sqlite3WindowRewrite ( pParse , p ) )  location: 5741 cross_layer: 5 file: select.c
if ( p -> pWin && ( sqlite3SelectTrace & 0x108 ) != 0 )  location: 5745 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after window rewrite:\n" ) ); location: 5746 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5747 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5751 cross_layer: 5 file: select.c
isAgg = ( p -> selFlags & SF_Aggregate ) != 0; location: 5752 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5754 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5761 cross_layer: 5 file: select.c
Select * pSub = pItem -> pSelect ; location: 5762 cross_layer: 5 file: select.c
Table * pTab = pItem -> pTab ; location: 5763 cross_layer: 5 file: select.c
if ( ( pItem -> fg . jointype & JT_LEFT ) != 0 && sqlite3ExprImpliesNonNullRow ( p -> pWhere , pItem -> iCursor ) && OptimizationEnabled ( db , SQLITE_SimplifyJoin ) )  location: 5768 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "LEFT-JOIN simplifies to JOIN on term %d\n" , i ) ); location: 5772 cross_layer: 5 file: select.c
pItem -> fg . jointype &= ~ ( JT_LEFT | JT_OUTER ); location: 5774 cross_layer: 5 file: select.c
unsetJoinExpr ( p -> pWhere , pItem -> iCursor ); location: 5775 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5779 cross_layer: 5 file: select.c
if ( pTab -> nCol != pSub -> pEList -> nExpr )  location: 5783 cross_layer: 5 file: select.c
sqlite3ErrorMsg ( pParse , "expected %d columns for '%s' but got %d" , pTab -> nCol , pTab -> zName , pSub -> pEList -> nExpr ); location: 5784 cross_layer: 5 file: select.c
if ( ( pSub -> selFlags & SF_Aggregate ) != 0 )  location: 5796 cross_layer: 5 file: select.c
assert ( pSub -> pGroupBy == 0 ); location: 5797 cross_layer: 5 file: select.c
if ( pSub -> pOrderBy != 0 && i == 0 && ( p -> selFlags & SF_ComplexResult ) != 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5817 cross_layer: 5 file: select.c
if ( flattenSubquery ( pParse , p , i , isAgg ) )  location: 5826 cross_layer: 5 file: select.c
if ( pParse -> nErr )  location: 5827 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5831 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5832 cross_layer: 5 file: select.c
if ( ! IgnorableOrderby ( pDest ) )  location: 5833 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5834 cross_layer: 5 file: select.c
if ( p -> pPrior )  location: 5843 cross_layer: 5 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end compound-select processing\n" ) ); location: 5846 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 5847 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5848 cross_layer: 5 file: select.c
if ( p -> pNext == 0 )  location: 5851 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 5851 cross_layer: 5 file: select.c
return rc ; location: 5852 cross_layer: 5 file: select.c
if ( pTabList -> nSrc > 1 && OptimizationEnabled ( db , SQLITE_PropagateConst ) && propagateConstants ( pParse , p ) )  location: 5861 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After constant propagation:\n" ) ); location: 5867 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5868 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Constant propagation not helpful\n" ) ); location: 5872 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_QueryFlattener | SQLITE_CountOfView ) && countOfViewOptimization ( pParse , p ) )  location: 5876 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5879 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 5880 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5881 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5890 cross_layer: 5 file: select.c
if ( pItem -> colUsed == 0 && pItem -> zName != 0 )  location: 5913 cross_layer: 5 file: select.c
sqlite3AuthCheck ( pParse , SQLITE_READ , pItem -> zName , "" , pItem -> zDatabase ); location: 5914 cross_layer: 5 file: select.c
pSub = pItem -> pSelect; location: 5920 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5921 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub != 0 ); location: 5935 cross_layer: 5 file: select.c
pParse -> nHeight += sqlite3SelectExprHeight ( p ); location: 5944 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_PushDown ) && pushDownWhereTerms ( pParse , pSub , p -> pWhere , pItem -> iCursor , ( pItem -> fg . jointype & JT_OUTER ) != 0 ) )  location: 5949 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After WHERE-clause push-down into subquery %d:\n" , pSub -> selId ) ); location: 5955 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5957 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Push-down not possible\n" ) ); location: 5961 cross_layer: 5 file: select.c
zSavedAuthContext = pParse -> zAuthContext; location: 5964 cross_layer: 5 file: select.c
pParse -> zAuthContext = pItem -> zName; location: 5965 cross_layer: 5 file: select.c
if ( i == 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5976 cross_layer: 5 file: select.c
int addrTop = sqlite3VdbeCurrentAddr ( v ) + 1 ; location: 5983 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 5985 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_InitCoroutine , pItem -> regReturn , 0 , addrTop ); location: 5986 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , pItem -> pTab -> zName ) ); location: 5987 cross_layer: 5 file: select.c
pItem -> addrFillSub = addrTop; location: 5988 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_Coroutine , pItem -> regReturn ); location: 5989 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "CO-ROUTINE %u" , pSub -> selId ) ); location: 5990 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 5 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 5 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 5 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 5 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 5 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 5 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 5 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 5 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 5 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 5 file: select.c
if ( pPrior )  location: 6023 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 5 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 5 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 5 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 5 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 5 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 5 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 5 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 6047 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6048 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy; location: 6049 cross_layer: 5 file: select.c
pHaving = p -> pHaving; location: 6050 cross_layer: 5 file: select.c
sDistinct . isTnct = ( p -> selFlags & SF_Distinct ) != 0; location: 6051 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6056 cross_layer: 5 file: select.c
if ( ( p -> selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct && sqlite3ExprListCompare ( sSort . pOrderBy , pEList , - 1 ) == 0 && p -> pWin == 0 )  location: 6075 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 6079 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 5 file: select.c
assert ( sDistinct . isTnct ); location: 6084 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6102 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 5 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 5 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 5 file: select.c
sSort . addrSortIndex = - 1; location: 6113 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_EphemTab )  location: 6118 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 5 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 5 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 5 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 5 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 5 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 5 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 5 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 5 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 5 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 5 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_NOOP; location: 6145 cross_layer: 5 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 5 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 5 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 5 file: select.c
if ( pWin )  location: 6154 cross_layer: 5 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 5 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 5 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 5 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 5 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 5 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 5 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 5 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 5 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 5 file: select.c
if ( pWin )  location: 6190 cross_layer: 5 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 5 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 5 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 5 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 5 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 5 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 5 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 5 file: select.c
p -> nSelectRow = 66; location: 6249 cross_layer: 5 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 5 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 5 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 5 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 5 file: select.c
p -> nSelectRow = 0; location: 6276 cross_layer: 5 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 5 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 5 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 5 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 5 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 5 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 5 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 5 file: select.c
if ( pHaving )  location: 6296 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 5 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 5 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 5 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 5 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 5 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 5 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 5 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 5 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 5 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 5 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 5 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 5 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6331 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 5 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 5 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 5 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 5 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 5 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 5 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 5 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 5 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 5 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 5 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 5 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 5 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 5 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 5 file: select.c
j = nGroupBy; location: 6422 cross_layer: 5 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 5 file: select.c
nCol ++; location: 6425 cross_layer: 5 file: select.c
j ++; location: 6426 cross_layer: 5 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 5 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 5 file: select.c
j = nGroupBy; location: 6431 cross_layer: 5 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 5 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 5 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 5 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 5 file: select.c
j ++; location: 6438 cross_layer: 5 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 5 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 5 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 5 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 5 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 5 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 5 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 5 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 5 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 5 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 5 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 5 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 5 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 5 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 5 file: select.c
if ( ( pTab = isSimpleCount ( p , & sAggInfo ) ) != 0 )  location: 6573 cross_layer: 5 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 5 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 5 file: select.c
int iRoot = pTab -> tnum ; location: 6592 cross_layer: 5 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 5 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 5 file: select.c
if ( ! HasRowid ( pTab ) )  location: 6606 cross_layer: 5 file: select.c
pBest = sqlite3PrimaryKeyIndex ( pTab ); location: 6606 cross_layer: 5 file: select.c
if ( pIdx -> bUnordered == 0 && pIdx -> szIdxRow < pTab -> szTabRow && pIdx -> pPartIdxWhere == 0 && ( ! pBest || pIdx -> szIdxRow < pBest -> szIdxRow ) )  location: 6608 cross_layer: 5 file: select.c
pBest = pIdx; location: 6613 cross_layer: 5 file: select.c
if ( pBest )  location: 6616 cross_layer: 5 file: select.c
iRoot = pBest -> tnum; location: 6617 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 5 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 5 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 5 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 5 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 5 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 5 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 5 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 5 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 5 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 5 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 5 file: select.c
if ( regAcc )  location: 6676 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 5 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 5 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 5 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 5 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 5 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6727 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 5 file: select.c
return rc ; location: 6731 cross_layer: 5 file: select.c
if ( rc )  location: 2757 cross_layer: 4 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , tab2 , 0 ); location: 2763 cross_layer: 4 file: select.c
assert ( p -> addrOpenEphm [ 1 ] == - 1 ); location: 2764 cross_layer: 4 file: select.c
p -> addrOpenEphm [ 1 ] = addr; location: 2765 cross_layer: 4 file: select.c
p -> pPrior = 0; location: 2766 cross_layer: 4 file: select.c
pLimit = p -> pLimit; location: 2767 cross_layer: 4 file: select.c
p -> pLimit = 0; location: 2768 cross_layer: 4 file: select.c
intersectdest . iSDParm = tab2; location: 2769 cross_layer: 4 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "%s USING TEMP B-TREE" , selectOpName ( p -> op ) ) ); location: 2770 cross_layer: 4 file: select.c
static const char *selectOpName(int id) location: 1366 cross_layer: 5 file: select.c
switch ( id )  location: 1368 cross_layer: 5 file: select.c
rc = sqlite3Select ( pParse , p , & intersectdest ); location: 2772 cross_layer: 4 file: select.c
int sqlite3Select(
Parse *pParse,         /* The parser context */
Select *p,             /* The SELECT statement being coded. */
SelectDest *pDest      /* What to do with the query results */
) location: 5676 cross_layer: 5 file: select.c
db = pParse -> db; location: 5695 cross_layer: 5 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 5696 cross_layer: 5 file: select.c
if ( p == 0 || db -> mallocFailed || pParse -> nErr )  location: 5697 cross_layer: 5 file: select.c
if ( sqlite3AuthCheck ( pParse , SQLITE_SELECT , 0 , 0 , 0 ) )  location: 5700 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "begin processing:\n" , pParse -> addrExplain ) ); location: 5703 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5705 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistFifo ); location: 5709 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Fifo ); location: 5710 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistQueue ); location: 5711 cross_layer: 5 file: select.c
assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Queue ); location: 5712 cross_layer: 5 file: select.c
if ( IgnorableOrderby ( pDest ) )  location: 5713 cross_layer: 5 file: select.c
assert ( pDest -> eDest == SRT_Exists || pDest -> eDest == SRT_Union || pDest -> eDest == SRT_Except || pDest -> eDest == SRT_Discard || pDest -> eDest == SRT_Queue || pDest -> eDest == SRT_DistFifo || pDest -> eDest == SRT_DistQueue || pDest -> eDest == SRT_Fifo ); location: 5714 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , p -> pOrderBy ); location: 5720 cross_layer: 5 file: select.c
p -> pOrderBy = 0; location: 5721 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 5722 cross_layer: 5 file: select.c
sqlite3SelectPrep ( pParse , p , 0 ); location: 5724 cross_layer: 5 file: select.c
if ( pParse -> nErr || db -> mallocFailed )  location: 5725 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 5728 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after name resolution:\n" ) ); location: 5731 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5732 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_Output )  location: 5736 cross_layer: 5 file: select.c
generateColumnNames ( pParse , p ); location: 5737 cross_layer: 5 file: select.c
if ( sqlite3WindowRewrite ( pParse , p ) )  location: 5741 cross_layer: 5 file: select.c
if ( p -> pWin && ( sqlite3SelectTrace & 0x108 ) != 0 )  location: 5745 cross_layer: 5 file: select.c
SELECTTRACE ( 0x104 , pParse , p , ( "after window rewrite:\n" ) ); location: 5746 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5747 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5751 cross_layer: 5 file: select.c
isAgg = ( p -> selFlags & SF_Aggregate ) != 0; location: 5752 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5754 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5761 cross_layer: 5 file: select.c
Select * pSub = pItem -> pSelect ; location: 5762 cross_layer: 5 file: select.c
Table * pTab = pItem -> pTab ; location: 5763 cross_layer: 5 file: select.c
if ( ( pItem -> fg . jointype & JT_LEFT ) != 0 && sqlite3ExprImpliesNonNullRow ( p -> pWhere , pItem -> iCursor ) && OptimizationEnabled ( db , SQLITE_SimplifyJoin ) )  location: 5768 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "LEFT-JOIN simplifies to JOIN on term %d\n" , i ) ); location: 5772 cross_layer: 5 file: select.c
pItem -> fg . jointype &= ~ ( JT_LEFT | JT_OUTER ); location: 5774 cross_layer: 5 file: select.c
unsetJoinExpr ( p -> pWhere , pItem -> iCursor ); location: 5775 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5779 cross_layer: 5 file: select.c
if ( pTab -> nCol != pSub -> pEList -> nExpr )  location: 5783 cross_layer: 5 file: select.c
sqlite3ErrorMsg ( pParse , "expected %d columns for '%s' but got %d" , pTab -> nCol , pTab -> zName , pSub -> pEList -> nExpr ); location: 5784 cross_layer: 5 file: select.c
if ( ( pSub -> selFlags & SF_Aggregate ) != 0 )  location: 5796 cross_layer: 5 file: select.c
assert ( pSub -> pGroupBy == 0 ); location: 5797 cross_layer: 5 file: select.c
if ( pSub -> pOrderBy != 0 && i == 0 && ( p -> selFlags & SF_ComplexResult ) != 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5817 cross_layer: 5 file: select.c
if ( flattenSubquery ( pParse , p , i , isAgg ) )  location: 5826 cross_layer: 5 file: select.c
if ( pParse -> nErr )  location: 5827 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5831 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5832 cross_layer: 5 file: select.c
if ( ! IgnorableOrderby ( pDest ) )  location: 5833 cross_layer: 5 file: select.c
sSort . pOrderBy = p -> pOrderBy; location: 5834 cross_layer: 5 file: select.c
if ( p -> pPrior )  location: 5843 cross_layer: 5 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end compound-select processing\n" ) ); location: 5846 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 5847 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5848 cross_layer: 5 file: select.c
if ( p -> pNext == 0 )  location: 5851 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 5851 cross_layer: 5 file: select.c
return rc ; location: 5852 cross_layer: 5 file: select.c
if ( pTabList -> nSrc > 1 && OptimizationEnabled ( db , SQLITE_PropagateConst ) && propagateConstants ( pParse , p ) )  location: 5861 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After constant propagation:\n" ) ); location: 5867 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5868 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Constant propagation not helpful\n" ) ); location: 5872 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_QueryFlattener | SQLITE_CountOfView ) && countOfViewOptimization ( pParse , p ) )  location: 5876 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 5879 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 5880 cross_layer: 5 file: select.c
pTabList = p -> pSrc; location: 5881 cross_layer: 5 file: select.c
struct SrcList_item * pItem = & pTabList -> a [ i ] ; location: 5890 cross_layer: 5 file: select.c
if ( pItem -> colUsed == 0 && pItem -> zName != 0 )  location: 5913 cross_layer: 5 file: select.c
sqlite3AuthCheck ( pParse , SQLITE_READ , pItem -> zName , "" , pItem -> zDatabase ); location: 5914 cross_layer: 5 file: select.c
pSub = pItem -> pSelect; location: 5920 cross_layer: 5 file: select.c
if ( pSub == 0 )  location: 5921 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub != 0 ); location: 5935 cross_layer: 5 file: select.c
pParse -> nHeight += sqlite3SelectExprHeight ( p ); location: 5944 cross_layer: 5 file: select.c
if ( OptimizationEnabled ( db , SQLITE_PushDown ) && pushDownWhereTerms ( pParse , pSub , p -> pWhere , pItem -> iCursor , ( pItem -> fg . jointype & JT_OUTER ) != 0 ) )  location: 5949 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "After WHERE-clause push-down into subquery %d:\n" , pSub -> selId ) ); location: 5955 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 5957 cross_layer: 5 file: select.c
SELECTTRACE ( 0x100 , pParse , p , ( "Push-down not possible\n" ) ); location: 5961 cross_layer: 5 file: select.c
zSavedAuthContext = pParse -> zAuthContext; location: 5964 cross_layer: 5 file: select.c
pParse -> zAuthContext = pItem -> zName; location: 5965 cross_layer: 5 file: select.c
if ( i == 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) )  location: 5976 cross_layer: 5 file: select.c
int addrTop = sqlite3VdbeCurrentAddr ( v ) + 1 ; location: 5983 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 5985 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_InitCoroutine , pItem -> regReturn , 0 , addrTop ); location: 5986 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , pItem -> pTab -> zName ) ); location: 5987 cross_layer: 5 file: select.c
pItem -> addrFillSub = addrTop; location: 5988 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_Coroutine , pItem -> regReturn ); location: 5989 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "CO-ROUTINE %u" , pSub -> selId ) ); location: 5990 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 5991 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 5992 cross_layer: 5 file: select.c
pItem -> fg . viaCoroutine = 1; location: 5993 cross_layer: 5 file: select.c
pItem -> regResult = dest . iSdst; location: 5994 cross_layer: 5 file: select.c
sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ); location: 5995 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTop - 1 ); location: 5996 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 5997 cross_layer: 5 file: select.c
testcase ( pItem -> addrFillSub == 0 ); location: 6009 cross_layer: 5 file: select.c
pItem -> regReturn = ++ pParse -> nMem; location: 6010 cross_layer: 5 file: select.c
topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ); location: 6011 cross_layer: 5 file: select.c
pItem -> addrFillSub = topAddr + 1; location: 6012 cross_layer: 5 file: select.c
if ( pItem -> fg . isCorrelated == 0 )  location: 6013 cross_layer: 5 file: select.c
onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ); location: 6017 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6017 cross_layer: 5 file: select.c
VdbeComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6018 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "materialize \"%s\"" , pItem -> pTab -> zName ) ); location: 6020 cross_layer: 5 file: select.c
pPrior = isSelfJoinView ( pTabList , pItem ); location: 6022 cross_layer: 5 file: select.c
if ( pPrior )  location: 6023 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ); location: 6024 cross_layer: 5 file: select.c
assert ( pPrior -> pSelect != 0 ); location: 6025 cross_layer: 5 file: select.c
pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow; location: 6026 cross_layer: 5 file: select.c
sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ); location: 6028 cross_layer: 5 file: select.c
ExplainQueryPlan ( ( pParse , 1 , "MATERIALIZE %u" , pSub -> selId ) ); location: 6029 cross_layer: 5 file: select.c
sqlite3Select ( pParse , pSub , & dest ); location: 6030 cross_layer: 5 file: select.c
pItem -> pTab -> nRowLogEst = pSub -> nSelectRow; location: 6032 cross_layer: 5 file: select.c
if ( onceAddr )  location: 6033 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , onceAddr ); location: 6033 cross_layer: 5 file: select.c
retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ); location: 6034 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end %s" , pItem -> pTab -> zName ) ); location: 6035 cross_layer: 5 file: select.c
sqlite3VdbeChangeP1 ( v , topAddr , retAddr ); location: 6036 cross_layer: 5 file: select.c
sqlite3ClearTempRegCache ( pParse ); location: 6037 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6039 cross_layer: 5 file: select.c
pParse -> nHeight -= sqlite3SelectExprHeight ( p ); location: 6040 cross_layer: 5 file: select.c
pParse -> zAuthContext = zSavedAuthContext; location: 6041 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 6047 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6048 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy; location: 6049 cross_layer: 5 file: select.c
pHaving = p -> pHaving; location: 6050 cross_layer: 5 file: select.c
sDistinct . isTnct = ( p -> selFlags & SF_Distinct ) != 0; location: 6051 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After all FROM-clause analysis:\n" ) ); location: 6055 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6056 cross_layer: 5 file: select.c
if ( ( p -> selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct && sqlite3ExprListCompare ( sSort . pOrderBy , pEList , - 1 ) == 0 && p -> pWin == 0 )  location: 6075 cross_layer: 5 file: select.c
p -> selFlags &= ~SF_Distinct; location: 6079 cross_layer: 5 file: select.c
pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ); location: 6080 cross_layer: 5 file: select.c
assert ( sDistinct . isTnct ); location: 6084 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "Transform DISTINCT into GROUP BY:\n" ) ); location: 6088 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6089 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6102 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ); location: 6104 cross_layer: 5 file: select.c
sSort . iECursor = pParse -> nTab ++; location: 6106 cross_layer: 5 file: select.c
sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6107 cross_layer: 5 file: select.c
sSort . addrSortIndex = - 1; location: 6113 cross_layer: 5 file: select.c
if ( pDest -> eDest == SRT_EphemTab )  location: 6118 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ); location: 6119 cross_layer: 5 file: select.c
iEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6124 cross_layer: 5 file: select.c
if ( ( p -> selFlags & SF_FixedLimit ) == 0 )  location: 6125 cross_layer: 5 file: select.c
p -> nSelectRow = 320; location: 6126 cross_layer: 5 file: select.c
computeLimitRegisters ( pParse , p , iEnd ); location: 6128 cross_layer: 5 file: select.c
if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 )  location: 6129 cross_layer: 5 file: select.c
sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ); location: 6130 cross_layer: 5 file: select.c
sSort . sortFlags |= SORTFLAG_UseSorter; location: 6131 cross_layer: 5 file: select.c
if ( p -> selFlags & SF_Distinct )  location: 6136 cross_layer: 5 file: select.c
sDistinct . tabTnct = pParse -> nTab ++; location: 6137 cross_layer: 5 file: select.c
sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ); location: 6138 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ); location: 6142 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED; location: 6143 cross_layer: 5 file: select.c
sDistinct . eTnctType = WHERE_DISTINCT_NOOP; location: 6145 cross_layer: 5 file: select.c
if ( ! isAgg && pGroupBy == 0 )  location: 6148 cross_layer: 5 file: select.c
u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; location: 6150 cross_layer: 5 file: select.c
Window * pWin = p -> pWin ; location: 6153 cross_layer: 5 file: select.c
if ( pWin )  location: 6154 cross_layer: 5 file: select.c
sqlite3WindowCodeInit ( pParse , pWin ); location: 6155 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6162 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ); location: 6163 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6165 cross_layer: 5 file: select.c
if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow )  location: 6166 cross_layer: 5 file: select.c
p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ); location: 6167 cross_layer: 5 file: select.c
if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) )  location: 6169 cross_layer: 5 file: select.c
sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ); location: 6170 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6172 cross_layer: 5 file: select.c
sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ); location: 6173 cross_layer: 5 file: select.c
sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ); location: 6174 cross_layer: 5 file: select.c
if ( sSort . nOBSat == sSort . pOrderBy -> nExpr )  location: 6175 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6176 cross_layer: 5 file: select.c
if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 )  location: 6184 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6185 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6188 cross_layer: 5 file: select.c
if ( pWin )  location: 6190 cross_layer: 5 file: select.c
int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; location: 6191 cross_layer: 5 file: select.c
int iCont = sqlite3VdbeMakeLabel ( pParse ) ; location: 6192 cross_layer: 5 file: select.c
int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; location: 6193 cross_layer: 5 file: select.c
int regGosub = ++ pParse -> nMem ; location: 6194 cross_layer: 5 file: select.c
sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ); location: 6196 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ); location: 6198 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrGosub ); location: 6199 cross_layer: 5 file: select.c
VdbeNoopComment ( ( v , "inner-loop subroutine" ) ); location: 6200 cross_layer: 5 file: select.c
sSort . labelOBLopt = 0; location: 6201 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ); location: 6202 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 6203 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ); location: 6204 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end inner-loop subroutine" ) ); location: 6205 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 6206 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6211 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6217 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6238 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6243 cross_layer: 5 file: select.c
pItem -> u . x . iAlias = 0; location: 6246 cross_layer: 5 file: select.c
if ( p -> nSelectRow > 66 )  location: 6249 cross_layer: 5 file: select.c
p -> nSelectRow = 66; location: 6249 cross_layer: 5 file: select.c
if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr )  location: 6259 cross_layer: 5 file: select.c
u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; location: 6267 cross_layer: 5 file: select.c
pGroupBy -> a [ ii ] . sortFlags = sortFlags; location: 6268 cross_layer: 5 file: select.c
if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 )  location: 6270 cross_layer: 5 file: select.c
p -> nSelectRow = 0; location: 6276 cross_layer: 5 file: select.c
addrEnd = sqlite3VdbeMakeLabel ( pParse ); location: 6280 cross_layer: 5 file: select.c
sNC . pParse = pParse; location: 6287 cross_layer: 5 file: select.c
sNC . pSrcList = pTabList; location: 6288 cross_layer: 5 file: select.c
sNC . uNC . pAggInfo = & sAggInfo; location: 6289 cross_layer: 5 file: select.c
sAggInfo . mnReg = pParse -> nMem + 1; location: 6291 cross_layer: 5 file: select.c
sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0; location: 6292 cross_layer: 5 file: select.c
sAggInfo . pGroupBy = pGroupBy; location: 6293 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pEList ); location: 6294 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ); location: 6295 cross_layer: 5 file: select.c
if ( pHaving )  location: 6296 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6297 cross_layer: 5 file: select.c
assert ( pWhere == p -> pWhere ); location: 6298 cross_layer: 5 file: select.c
assert ( pHaving == p -> pHaving ); location: 6299 cross_layer: 5 file: select.c
assert ( pGroupBy == p -> pGroupBy ); location: 6300 cross_layer: 5 file: select.c
havingToWhere ( pParse , p ); location: 6301 cross_layer: 5 file: select.c
pWhere = p -> pWhere; location: 6302 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ); location: 6304 cross_layer: 5 file: select.c
sAggInfo . nAccumulator = sAggInfo . nColumn; location: 6306 cross_layer: 5 file: select.c
if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 )  location: 6307 cross_layer: 5 file: select.c
minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ); location: 6308 cross_layer: 5 file: select.c
Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; location: 6313 cross_layer: 5 file: select.c
assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ); location: 6314 cross_layer: 5 file: select.c
sNC . ncFlags |= NC_InAggFunc; location: 6315 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ); location: 6316 cross_layer: 5 file: select.c
assert ( ! IsWindowFunc ( pExpr ) ); location: 6318 cross_layer: 5 file: select.c
if ( ExprHasProperty ( pExpr , EP_WinFunc ) )  location: 6319 cross_layer: 5 file: select.c
sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ); location: 6320 cross_layer: 5 file: select.c
sNC . ncFlags &= ~NC_InAggFunc; location: 6323 cross_layer: 5 file: select.c
sAggInfo . mxReg = pParse -> nMem; location: 6325 cross_layer: 5 file: select.c
if ( db -> mallocFailed )  location: 6326 cross_layer: 5 file: select.c
SELECTTRACE ( 0x400 , pParse , p , ( "After aggregate analysis:\n" ) ); location: 6330 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6331 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-column[%d] iMem=%d\n" , ii , sAggInfo . aCol [ ii ] . iMem ); location: 6333 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ); location: 6335 cross_layer: 5 file: select.c
sqlite3DebugPrintf ( "agg-func[%d]: iMem=%d\n" , ii , sAggInfo . aFunc [ ii ] . iMem ); location: 6338 cross_layer: 5 file: select.c
sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ); location: 6340 cross_layer: 5 file: select.c
if ( pGroupBy )  location: 6349 cross_layer: 5 file: select.c
sAggInfo . sortingIdx = pParse -> nTab ++; location: 6365 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ); location: 6366 cross_layer: 5 file: select.c
addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6367 cross_layer: 5 file: select.c
iUseFlag = ++ pParse -> nMem; location: 6373 cross_layer: 5 file: select.c
iAbortFlag = ++ pParse -> nMem; location: 6374 cross_layer: 5 file: select.c
regOutputRow = ++ pParse -> nMem; location: 6375 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeMakeLabel ( pParse ); location: 6376 cross_layer: 5 file: select.c
regReset = ++ pParse -> nMem; location: 6377 cross_layer: 5 file: select.c
addrReset = sqlite3VdbeMakeLabel ( pParse ); location: 6378 cross_layer: 5 file: select.c
iAMem = pParse -> nMem + 1; location: 6379 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6380 cross_layer: 5 file: select.c
iBMem = pParse -> nMem + 1; location: 6381 cross_layer: 5 file: select.c
pParse -> nMem += pGroupBy -> nExpr; location: 6382 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ); location: 6383 cross_layer: 5 file: select.c
VdbeComment ( ( v , "clear abort flag" ) ); location: 6384 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ); location: 6385 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6392 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6393 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ); location: 6394 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6397 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr )  location: 6398 cross_layer: 5 file: select.c
explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? "DISTINCT" : "GROUP BY" ); location: 6415 cross_layer: 5 file: select.c
nGroupBy = pGroupBy -> nExpr; location: 6420 cross_layer: 5 file: select.c
nCol = nGroupBy; location: 6421 cross_layer: 5 file: select.c
j = nGroupBy; location: 6422 cross_layer: 5 file: select.c
if ( sAggInfo . aCol [ i ] . iSorterColumn >= j )  location: 6424 cross_layer: 5 file: select.c
nCol ++; location: 6425 cross_layer: 5 file: select.c
j ++; location: 6426 cross_layer: 5 file: select.c
regBase = sqlite3GetTempRange ( pParse , nCol ); location: 6429 cross_layer: 5 file: select.c
sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ); location: 6430 cross_layer: 5 file: select.c
j = nGroupBy; location: 6431 cross_layer: 5 file: select.c
struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; location: 6433 cross_layer: 5 file: select.c
if ( pCol -> iSorterColumn >= j )  location: 6434 cross_layer: 5 file: select.c
int r1 = j + regBase ; location: 6435 cross_layer: 5 file: select.c
sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ); location: 6436 cross_layer: 5 file: select.c
j ++; location: 6438 cross_layer: 5 file: select.c
regRecord = sqlite3GetTempReg ( pParse ); location: 6441 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ); location: 6442 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ); location: 6443 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , regRecord ); location: 6444 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , regBase , nCol ); location: 6445 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6446 cross_layer: 5 file: select.c
sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++; location: 6447 cross_layer: 5 file: select.c
sortOut = sqlite3GetTempReg ( pParse ); location: 6448 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ); location: 6449 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ); location: 6450 cross_layer: 5 file: select.c
VdbeComment ( ( v , "GROUP BY sort" ) ); location: 6451 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6451 cross_layer: 5 file: select.c
sAggInfo . useSortingIdx = 1; location: 6452 cross_layer: 5 file: select.c
if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) )  location: 6462 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6465 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ); location: 6466 cross_layer: 5 file: select.c
addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ); location: 6474 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ); location: 6476 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ); location: 6481 cross_layer: 5 file: select.c
sAggInfo . directMode = 1; location: 6483 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ); location: 6484 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 6487 cross_layer: 5 file: select.c
addr1 = sqlite3VdbeCurrentAddr ( v ); location: 6489 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ); location: 6490 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6490 cross_layer: 5 file: select.c
sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ); location: 6501 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6502 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output one row" ) ); location: 6503 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ); location: 6504 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6504 cross_layer: 5 file: select.c
VdbeComment ( ( v , "check abort flag" ) ); location: 6505 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ); location: 6506 cross_layer: 5 file: select.c
VdbeComment ( ( v , "reset accumulator" ) ); location: 6507 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addr1 ); location: 6512 cross_layer: 5 file: select.c
updateAccumulator ( pParse , iUseFlag , & sAggInfo ); location: 6513 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ); location: 6514 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate data in accumulator" ) ); location: 6515 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ); location: 6520 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6521 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6523 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , addrSortingIdx ); location: 6524 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ); location: 6529 cross_layer: 5 file: select.c
VdbeComment ( ( v , "output final row" ) ); location: 6530 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , addrEnd ); location: 6534 cross_layer: 5 file: select.c
addrSetAbort = sqlite3VdbeCurrentAddr ( v ); location: 6543 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ); location: 6544 cross_layer: 5 file: select.c
VdbeComment ( ( v , "set abort flag" ) ); location: 6545 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6546 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrOutputRow ); location: 6547 cross_layer: 5 file: select.c
addrOutputRow = sqlite3VdbeCurrentAddr ( v ); location: 6548 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ); location: 6549 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 6550 cross_layer: 5 file: select.c
VdbeComment ( ( v , "Groupby result generator entry point" ) ); location: 6551 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6552 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6553 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ); location: 6554 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ); location: 6555 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ); location: 6558 cross_layer: 5 file: select.c
VdbeComment ( ( v , "end groupby result generator" ) ); location: 6559 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrReset ); location: 6563 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6564 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ); location: 6565 cross_layer: 5 file: select.c
VdbeComment ( ( v , "indicate accumulator empty" ) ); location: 6566 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Return , regReset ); location: 6567 cross_layer: 5 file: select.c
if ( ( pTab = isSimpleCount ( p , & sAggInfo ) ) != 0 )  location: 6573 cross_layer: 5 file: select.c
const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; location: 6587 cross_layer: 5 file: select.c
const int iCsr = pParse -> nTab ++ ; location: 6588 cross_layer: 5 file: select.c
int iRoot = pTab -> tnum ; location: 6592 cross_layer: 5 file: select.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 6594 cross_layer: 5 file: select.c
sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ); location: 6595 cross_layer: 5 file: select.c
if ( ! HasRowid ( pTab ) )  location: 6606 cross_layer: 5 file: select.c
pBest = sqlite3PrimaryKeyIndex ( pTab ); location: 6606 cross_layer: 5 file: select.c
if ( pIdx -> bUnordered == 0 && pIdx -> szIdxRow < pTab -> szTabRow && pIdx -> pPartIdxWhere == 0 && ( ! pBest || pIdx -> szIdxRow < pBest -> szIdxRow ) )  location: 6608 cross_layer: 5 file: select.c
pBest = pIdx; location: 6613 cross_layer: 5 file: select.c
if ( pBest )  location: 6616 cross_layer: 5 file: select.c
iRoot = pBest -> tnum; location: 6617 cross_layer: 5 file: select.c
pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ); location: 6618 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ); location: 6622 cross_layer: 5 file: select.c
if ( pKeyInfo )  location: 6623 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ); location: 6624 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ); location: 6626 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ); location: 6627 cross_layer: 5 file: select.c
explainSimpleCount ( pParse , pTab , pBest ); location: 6628 cross_layer: 5 file: select.c
if ( sAggInfo . nAccumulator )  location: 6643 cross_layer: 5 file: select.c
if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) )  location: 6645 cross_layer: 5 file: select.c
if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL )  location: 6646 cross_layer: 5 file: select.c
if ( i == sAggInfo . nFunc )  location: 6648 cross_layer: 5 file: select.c
regAcc = ++ pParse -> nMem; location: 6649 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ); location: 6650 cross_layer: 5 file: select.c
assert ( p -> pGroupBy == 0 ); location: 6658 cross_layer: 5 file: select.c
resetAccumulator ( pParse , & sAggInfo ); location: 6659 cross_layer: 5 file: select.c
assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ); location: 6666 cross_layer: 5 file: select.c
SELECTTRACE ( 1 , pParse , p , ( "WhereBegin\n" ) ); location: 6669 cross_layer: 5 file: select.c
pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ); location: 6670 cross_layer: 5 file: select.c
if ( pWInfo == 0 )  location: 6672 cross_layer: 5 file: select.c
updateAccumulator ( pParse , regAcc , & sAggInfo ); location: 6675 cross_layer: 5 file: select.c
if ( regAcc )  location: 6676 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ); location: 6676 cross_layer: 5 file: select.c
if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 )  location: 6677 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ); location: 6678 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s() by index" , ( minMaxFlag == WHERE_ORDERBY_MIN ? "min" : "max" ) ) ); location: 6679 cross_layer: 5 file: select.c
sqlite3WhereEnd ( pWInfo ); location: 6682 cross_layer: 5 file: select.c
finalizeAggFunctions ( pParse , & sAggInfo ); location: 6683 cross_layer: 5 file: select.c
sSort . pOrderBy = 0; location: 6686 cross_layer: 5 file: select.c
sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ); location: 6687 cross_layer: 5 file: select.c
selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ); location: 6688 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , addrEnd ); location: 6691 cross_layer: 5 file: select.c
if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED )  location: 6695 cross_layer: 5 file: select.c
explainTempTable ( pParse , "DISTINCT" ); location: 6696 cross_layer: 5 file: select.c
if ( sSort . pOrderBy )  location: 6702 cross_layer: 5 file: select.c
explainTempTable ( pParse , sSort . nOBSat > 0 ? "RIGHT PART OF ORDER BY" : "ORDER BY" ); location: 6703 cross_layer: 5 file: select.c
assert ( p -> pEList == pEList ); location: 6705 cross_layer: 5 file: select.c
generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ); location: 6706 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iEnd ); location: 6711 cross_layer: 5 file: select.c
rc = ( pParse -> nErr > 0 ); location: 6715 cross_layer: 5 file: select.c
sqlite3ExprListDelete ( db , pMinMaxOrderBy ); location: 6721 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aCol ); location: 6722 cross_layer: 5 file: select.c
sqlite3DbFree ( db , sAggInfo . aFunc ); location: 6723 cross_layer: 5 file: select.c
SELECTTRACE ( 0x1 , pParse , p , ( "end processing\n" ) ); location: 6725 cross_layer: 5 file: select.c
if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 )  location: 6726 cross_layer: 5 file: select.c
sqlite3TreeViewSelect ( 0 , p , 0 ); location: 6727 cross_layer: 5 file: select.c
ExplainQueryPlanPop ( pParse ); location: 6730 cross_layer: 5 file: select.c
return rc ; location: 6731 cross_layer: 5 file: select.c
testcase ( rc != SQLITE_OK ); location: 2773 cross_layer: 4 file: select.c
pDelete = p -> pPrior; location: 2774 cross_layer: 4 file: select.c
p -> pPrior = pPrior; location: 2775 cross_layer: 4 file: select.c
if ( p -> nSelectRow > pPrior -> nSelectRow )  location: 2776 cross_layer: 4 file: select.c
p -> nSelectRow = pPrior -> nSelectRow; location: 2777 cross_layer: 4 file: select.c
sqlite3ExprDelete ( db , p -> pLimit ); location: 2779 cross_layer: 4 file: select.c
p -> pLimit = pLimit; location: 2780 cross_layer: 4 file: select.c
assert ( p -> pEList ); location: 2785 cross_layer: 4 file: select.c
iBreak = sqlite3VdbeMakeLabel ( pParse ); location: 2786 cross_layer: 4 file: select.c
iCont = sqlite3VdbeMakeLabel ( pParse ); location: 2787 cross_layer: 4 file: select.c
computeLimitRegisters ( pParse , p , iBreak ); location: 2788 cross_layer: 4 file: select.c
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) location: 2153 cross_layer: 5 file: select.c
Expr * pLimit = p -> pLimit ; location: 2158 cross_layer: 5 file: select.c
if ( p -> iLimit )  location: 2160 cross_layer: 5 file: select.c
if ( pLimit )  location: 2168 cross_layer: 5 file: select.c
assert ( pLimit -> op == TK_LIMIT ); location: 2169 cross_layer: 5 file: select.c
assert ( pLimit -> pLeft != 0 ); location: 2170 cross_layer: 5 file: select.c
p -> iLimit = iLimit = ++ pParse -> nMem; location: 2171 cross_layer: 5 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2172 cross_layer: 5 file: select.c
assert ( v != 0 ); location: 2173 cross_layer: 5 file: select.c
if ( sqlite3ExprIsInteger ( pLimit -> pLeft , & n ) )  location: 2174 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , n , iLimit ); location: 2175 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2176 cross_layer: 5 file: select.c
sqlite3VdbeGoto ( v , iBreak ); location: 2178 cross_layer: 5 file: select.c
if ( n >= 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) n ) )  location: 2179 cross_layer: 5 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) n ); location: 2180 cross_layer: 5 file: select.c
p -> selFlags |= SF_FixedLimit; location: 2181 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pLeft , iLimit ); location: 2184 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iLimit ); location: 2185 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2185 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT counter" ) ); location: 2186 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IfNot , iLimit , iBreak ); location: 2187 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2187 cross_layer: 5 file: select.c
if ( pLimit -> pRight )  location: 2189 cross_layer: 5 file: select.c
p -> iOffset = iOffset = ++ pParse -> nMem; location: 2190 cross_layer: 5 file: select.c
pParse -> nMem ++; location: 2191 cross_layer: 5 file: select.c
sqlite3ExprCode ( pParse , pLimit -> pRight , iOffset ); location: 2192 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_MustBeInt , iOffset ); location: 2193 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 2193 cross_layer: 5 file: select.c
VdbeComment ( ( v , "OFFSET counter" ) ); location: 2194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_OffsetLimit , iLimit , iOffset + 1 , iOffset ); location: 2195 cross_layer: 5 file: select.c
VdbeComment ( ( v , "LIMIT+OFFSET" ) ); location: 2196 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Rewind , tab1 , iBreak ); location: 2789 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2789 cross_layer: 4 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 2790 cross_layer: 4 file: select.c
iStart = sqlite3VdbeAddOp2 ( v , OP_RowData , tab1 , r1 ); location: 2791 cross_layer: 4 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_NotFound , tab2 , iCont , r1 , 0 ); location: 2792 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2793 cross_layer: 4 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 2794 cross_layer: 4 file: select.c
selectInnerLoop ( pParse , p , tab1 , 0 , 0 , & dest , iCont , iBreak ); location: 2795 cross_layer: 4 file: select.c
static void selectInnerLoop(
Parse *pParse,          /* The parser context */
Select *p,              /* The complete select statement being coded */
int srcTab,             /* Pull data from this table if non-negative */
SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
SelectDest *pDest,      /* How to dispose of the results */
int iContinue,          /* Jump here to continue with next row */
int iBreak              /* Jump here to break out of the inner loop */
) location: 869 cross_layer: 5 file: select.c
Vdbe * v = pParse -> pVdbe ; location: 870 cross_layer: 5 file: select.c
int eDest = pDest -> eDest ; location: 873 cross_layer: 5 file: select.c
int iParm = pDest -> iSDParm ; location: 874 cross_layer: 5 file: select.c
assert ( v ); location: 887 cross_layer: 5 file: select.c
assert ( p -> pEList != 0 ); location: 888 cross_layer: 5 file: select.c
hasDistinct = pDistinct ? pDistinct -> eTnctType : WHERE_DISTINCT_NOOP; location: 889 cross_layer: 5 file: select.c
if ( pSort && pSort -> pOrderBy == 0 )  location: 890 cross_layer: 5 file: select.c
pSort = 0; location: 890 cross_layer: 5 file: select.c
if ( pSort == 0 && ! hasDistinct )  location: 891 cross_layer: 5 file: select.c
assert ( iContinue != 0 ); location: 892 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 893 cross_layer: 5 file: select.c
nResultCol = p -> pEList -> nExpr; location: 898 cross_layer: 5 file: select.c
if ( pDest -> iSdst == 0 )  location: 900 cross_layer: 5 file: select.c
if ( pSort )  location: 901 cross_layer: 5 file: select.c
nPrefixReg = pSort -> pOrderBy -> nExpr; location: 902 cross_layer: 5 file: select.c
if ( ! ( pSort -> sortFlags & SORTFLAG_UseSorter ) )  location: 903 cross_layer: 5 file: select.c
nPrefixReg ++; location: 903 cross_layer: 5 file: select.c
pParse -> nMem += nPrefixReg; location: 904 cross_layer: 5 file: select.c
pDest -> iSdst = pParse -> nMem + 1; location: 906 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 907 cross_layer: 5 file: select.c
if ( pDest -> iSdst + nResultCol > pParse -> nMem )  location: 908 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 914 cross_layer: 5 file: select.c
pDest -> nSdst = nResultCol; location: 916 cross_layer: 5 file: select.c
regOrig = regResult = pDest -> iSdst; location: 917 cross_layer: 5 file: select.c
if ( srcTab >= 0 )  location: 918 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Column , srcTab , i , regResult + i ); location: 920 cross_layer: 5 file: select.c
VdbeComment ( ( v , "%s" , p -> pEList -> a [ i ] . zName ) ); location: 921 cross_layer: 5 file: select.c
if ( eDest != SRT_Exists )  location: 923 cross_layer: 5 file: select.c
if ( eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine )  location: 932 cross_layer: 5 file: select.c
if ( pSort && hasDistinct == 0 && eDest != SRT_EphemTab && eDest != SRT_Table )  location: 937 cross_layer: 5 file: select.c
if ( ( j = pSort -> pOrderBy -> a [ i ] . u . x . iOrderByCol ) > 0 )  location: 948 cross_layer: 5 file: select.c
p -> pEList -> a [ j - 1 ] . u . x . iOrderByCol = i + 1 - pSort -> nOBSat; location: 949 cross_layer: 5 file: select.c
selectExprDefer ( pParse , pSort , p -> pEList , & pExtra ); location: 953 cross_layer: 5 file: select.c
if ( pExtra && pParse -> db -> mallocFailed == 0 )  location: 954 cross_layer: 5 file: select.c
VdbeOp * pOp = sqlite3VdbeGetOp ( v , pSort -> addrSortIndex ) ; location: 960 cross_layer: 5 file: select.c
pOp -> p2 += ( pExtra -> nExpr - pSort -> nDefer ); location: 961 cross_layer: 5 file: select.c
pOp -> p4 . pKeyInfo -> nAllField += ( pExtra -> nExpr - pSort -> nDefer ); location: 962 cross_layer: 5 file: select.c
pParse -> nMem += pExtra -> nExpr; location: 963 cross_layer: 5 file: select.c
pEList = p -> pEList; location: 969 cross_layer: 5 file: select.c
if ( pEList -> a [ i ] . u . x . iOrderByCol > 0 location: 971 cross_layer: 5 file: select.c
|| pEList -> a [ i ] . bSorterRef location: 973 cross_layer: 5 file: select.c
nResultCol --; location: 976 cross_layer: 5 file: select.c
testcase ( regOrig ); location: 981 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Set ); location: 982 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Mem ); location: 983 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 984 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 985 cross_layer: 5 file: select.c
assert ( eDest == SRT_Set || eDest == SRT_Mem || eDest == SRT_Coroutine || eDest == SRT_Output ); location: 986 cross_layer: 5 file: select.c
sRowLoadInfo . regResult = regResult; location: 989 cross_layer: 5 file: select.c
sRowLoadInfo . ecelFlags = ecelFlags; location: 990 cross_layer: 5 file: select.c
sRowLoadInfo . pExtra = pExtra; location: 992 cross_layer: 5 file: select.c
sRowLoadInfo . regExtraResult = regResult + nResultCol; location: 993 cross_layer: 5 file: select.c
nResultCol += pExtra -> nExpr; location: 994 cross_layer: 5 file: select.c
if ( p -> iLimit && ( ecelFlags & SQLITE_ECEL_OMITREF ) != 0 && nPrefixReg > 0 )  location: 996 cross_layer: 5 file: select.c
assert ( pSort != 0 ); location: 1000 cross_layer: 5 file: select.c
assert ( hasDistinct == 0 ); location: 1001 cross_layer: 5 file: select.c
pSort -> pDeferredRowLoad = & sRowLoadInfo; location: 1002 cross_layer: 5 file: select.c
innerLoopLoadRow ( pParse , p , & sRowLoadInfo ); location: 1005 cross_layer: 5 file: select.c
if ( hasDistinct )  location: 1013 cross_layer: 5 file: select.c
switch ( pDistinct -> eTnctType )  location: 1014 cross_layer: 5 file: select.c
regPrev = pParse -> nMem + 1; location: 1021 cross_layer: 5 file: select.c
pParse -> nMem += nResultCol; location: 1022 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1030 cross_layer: 5 file: select.c
pOp = sqlite3VdbeGetOp ( v , pDistinct -> addrTnct ); location: 1031 cross_layer: 5 file: select.c
pOp -> opcode = OP_Null; location: 1032 cross_layer: 5 file: select.c
pOp -> p1 = 1; location: 1033 cross_layer: 5 file: select.c
pOp -> p2 = regPrev; location: 1034 cross_layer: 5 file: select.c
iJump = sqlite3VdbeCurrentAddr ( v ) + nResultCol; location: 1037 cross_layer: 5 file: select.c
CollSeq * pColl = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ i ] . pExpr ) ; location: 1039 cross_layer: 5 file: select.c
if ( i < nResultCol - 1 )  location: 1040 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Ne , regResult + i , iJump , regPrev + i ); location: 1041 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1042 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Eq , regResult + i , iContinue , regPrev + i ); location: 1044 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1045 cross_layer: 5 file: select.c
sqlite3VdbeChangeP4 ( v , - 1 , ( const char * ) pColl , P4_COLLSEQ ); location: 1047 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , SQLITE_NULLEQ ); location: 1048 cross_layer: 5 file: select.c
assert ( sqlite3VdbeCurrentAddr ( v ) == iJump || pParse -> db -> mallocFailed ); location: 1050 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Copy , regResult , regPrev , nResultCol - 1 ); location: 1051 cross_layer: 5 file: select.c
sqlite3VdbeChangeToNoop ( v , pDistinct -> addrTnct ); location: 1056 cross_layer: 5 file: select.c
assert ( pDistinct -> eTnctType == WHERE_DISTINCT_UNORDERED ); location: 1061 cross_layer: 5 file: select.c
codeDistinct ( pParse , pDistinct -> tabTnct , iContinue , nResultCol , regResult ); location: 1062 cross_layer: 5 file: select.c
if ( pSort == 0 )  location: 1067 cross_layer: 5 file: select.c
codeOffset ( v , p -> iOffset , iContinue ); location: 1068 cross_layer: 5 file: select.c
switch ( eDest )  location: 1072 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1079 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 ); location: 1080 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1081 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1082 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_IdxDelete , iParm , regResult , nResultCol ); location: 1091 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempRange ( pParse , nPrefixReg + 1 ) ; location: 1102 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Table ); location: 1103 cross_layer: 5 file: select.c
testcase ( eDest == SRT_EphemTab ); location: 1104 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Fifo ); location: 1105 cross_layer: 5 file: select.c
testcase ( eDest == SRT_DistFifo ); location: 1106 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r1 + nPrefixReg ); location: 1107 cross_layer: 5 file: select.c
if ( eDest == SRT_DistFifo )  location: 1109 cross_layer: 5 file: select.c
int addr = sqlite3VdbeCurrentAddr ( v ) + 4 ; location: 1115 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , addr , r1 , 0 ); location: 1116 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1117 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm + 1 , r1 , regResult , nResultCol ); location: 1118 cross_layer: 5 file: select.c
assert ( pSort == 0 ); location: 1119 cross_layer: 5 file: select.c
if ( pSort )  location: 1122 cross_layer: 5 file: select.c
assert ( regResult == regOrig ); location: 1123 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , r1 + nPrefixReg , regOrig , 1 , nPrefixReg ); location: 1124 cross_layer: 5 file: select.c
int r2 = sqlite3GetTempReg ( pParse ) ; location: 1126 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_NewRowid , iParm , r2 ); location: 1127 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_Insert , iParm , r1 , r2 ); location: 1128 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_APPEND ); location: 1129 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r2 ); location: 1130 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r1 , nPrefixReg + 1 ); location: 1132 cross_layer: 5 file: select.c
if ( pSort )  location: 1142 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1147 cross_layer: 5 file: select.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 1150 cross_layer: 5 file: select.c
assert ( sqlite3Strlen30 ( pDest -> zAffSdst ) == nResultCol ); location: 1151 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regResult , nResultCol , r1 , pDest -> zAffSdst , nResultCol ); location: 1152 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , regResult , nResultCol ); location: 1154 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1155 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iParm ); location: 1163 cross_layer: 5 file: select.c
if ( pSort )  location: 1173 cross_layer: 5 file: select.c
assert ( nResultCol <= pDest -> nSdst ); location: 1174 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1175 cross_layer: 5 file: select.c
assert ( nResultCol == pDest -> nSdst ); location: 1178 cross_layer: 5 file: select.c
assert ( regResult == iParm ); location: 1179 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Coroutine ); location: 1188 cross_layer: 5 file: select.c
testcase ( eDest == SRT_Output ); location: 1189 cross_layer: 5 file: select.c
if ( pSort )  location: 1190 cross_layer: 5 file: select.c
pushOntoSorter ( pParse , pSort , p , regResult , regOrig , nResultCol , nPrefixReg ); location: 1191 cross_layer: 5 file: select.c
if ( eDest == SRT_Coroutine )  location: 1193 cross_layer: 5 file: select.c
sqlite3VdbeAddOp1 ( v , OP_Yield , pDest -> iSDParm ); location: 1194 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , nResultCol ); location: 1196 cross_layer: 5 file: select.c
pSO = pDest -> pOrderBy; location: 1214 cross_layer: 5 file: select.c
assert ( pSO ); location: 1215 cross_layer: 5 file: select.c
nKey = pSO -> nExpr; location: 1216 cross_layer: 5 file: select.c
r1 = sqlite3GetTempReg ( pParse ); location: 1217 cross_layer: 5 file: select.c
r2 = sqlite3GetTempRange ( pParse , nKey + 2 ); location: 1218 cross_layer: 5 file: select.c
r3 = r2 + nKey + 1; location: 1219 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1220 cross_layer: 5 file: select.c
addrTest = sqlite3VdbeAddOp4Int ( v , OP_Found , iParm + 1 , 0 , regResult , nResultCol ); location: 1224 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1226 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regResult , nResultCol , r3 ); location: 1228 cross_layer: 5 file: select.c
if ( eDest == SRT_DistQueue )  location: 1229 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_IdxInsert , iParm + 1 , r3 ); location: 1230 cross_layer: 5 file: select.c
sqlite3VdbeChangeP5 ( v , OPFLAG_USESEEKRESULT ); location: 1231 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_SCopy , regResult + pSO -> a [ i ] . u . x . iOrderByCol - 1 , r2 + i ); location: 1234 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Sequence , iParm , r2 + nKey ); location: 1238 cross_layer: 5 file: select.c
sqlite3VdbeAddOp3 ( v , OP_MakeRecord , r2 , nKey + 2 , r1 ); location: 1239 cross_layer: 5 file: select.c
sqlite3VdbeAddOp4Int ( v , OP_IdxInsert , iParm , r1 , r2 , nKey + 2 ); location: 1240 cross_layer: 5 file: select.c
if ( addrTest )  location: 1241 cross_layer: 5 file: select.c
sqlite3VdbeJumpHere ( v , addrTest ); location: 1241 cross_layer: 5 file: select.c
sqlite3ReleaseTempReg ( pParse , r1 ); location: 1242 cross_layer: 5 file: select.c
sqlite3ReleaseTempRange ( pParse , r2 , nKey + 2 ); location: 1243 cross_layer: 5 file: select.c
assert ( eDest == SRT_Discard ); location: 1257 cross_layer: 5 file: select.c
if ( pSort == 0 && p -> iLimit )  location: 1267 cross_layer: 5 file: select.c
sqlite3VdbeAddOp2 ( v , OP_DecrJumpZero , p -> iLimit , iBreak ); location: 1268 cross_layer: 5 file: select.c
VdbeCoverage ( v ); location: 1268 cross_layer: 5 file: select.c
sqlite3VdbeResolveLabel ( v , iCont ); location: 2797 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Next , tab1 , iStart ); location: 2798 cross_layer: 4 file: select.c
VdbeCoverage ( v ); location: 2798 cross_layer: 4 file: select.c
sqlite3VdbeResolveLabel ( v , iBreak ); location: 2799 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Close , tab2 , 0 ); location: 2800 cross_layer: 4 file: select.c
sqlite3VdbeAddOp2 ( v , OP_Close , tab1 , 0 ); location: 2801 cross_layer: 4 file: select.c
if ( p -> pNext == 0 )  location: 2807 cross_layer: 4 file: select.c
ExplainQueryPlanPop ( pParse ); location: 2808 cross_layer: 4 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 4 file: select.c
if ( p -> selFlags & SF_UsesEphemeral )  location: 2823 cross_layer: 4 file: select.c
assert ( p -> pNext == 0 ); location: 2830 cross_layer: 4 file: select.c
nCol = p -> pEList -> nExpr; location: 2831 cross_layer: 4 file: select.c
pKeyInfo = sqlite3KeyInfoAlloc ( db , nCol , 1 ); location: 2832 cross_layer: 4 file: select.c
KeyInfo *sqlite3KeyInfoAlloc(sqlite3 *db, int N, int X) location: 1276 cross_layer: 5 file: select.c
int nExtra = ( N + X ) * ( sizeof ( CollSeq * ) + 1 ) - sizeof ( CollSeq * ) ; location: 1277 cross_layer: 5 file: select.c
KeyInfo * p = sqlite3DbMallocRawNN ( db , sizeof ( KeyInfo ) + nExtra ) ; location: 1278 cross_layer: 5 file: select.c
if ( p )  location: 1279 cross_layer: 5 file: select.c
p -> aSortFlags = ( u8 * ) & p -> aColl [ N + X ]; location: 1280 cross_layer: 5 file: select.c
p -> nKeyField = ( u16 ) N; location: 1281 cross_layer: 5 file: select.c
p -> nAllField = ( u16 ) ( N + X ); location: 1282 cross_layer: 5 file: select.c
p -> enc = ENC ( db ); location: 1283 cross_layer: 5 file: select.c
p -> db = db; location: 1284 cross_layer: 5 file: select.c
p -> nRef = 1; location: 1285 cross_layer: 5 file: select.c
memset ( & p [ 1 ] , 0 , nExtra ); location: 1286 cross_layer: 5 file: select.c
sqlite3OomFault ( db ); location: 1288 cross_layer: 5 file: select.c
return p ; location: 1290 cross_layer: 5 file: select.c
if ( ! pKeyInfo )  location: 2833 cross_layer: 4 file: select.c
for(i=0, apColl=pKeyInfo->aColl; i<nCol; i++, apColl++) location: 2837 cross_layer: 4 file: select.c
* apColl = multiSelectCollSeq ( pParse , p , i ); location: 2838 cross_layer: 4 file: select.c
static CollSeq *multiSelectCollSeq(Parse *pParse, Select *p, int iCol) location: 2210 cross_layer: 5 file: select.c
if ( p -> pPrior )  location: 2212 cross_layer: 5 file: select.c
pRet = multiSelectCollSeq ( pParse , p -> pPrior , iCol ); location: 2213 cross_layer: 5 file: select.c
assert ( iCol >= 0 ); location: 2217 cross_layer: 5 file: select.c
if ( pRet == 0 && ALWAYS ( iCol < p -> pEList -> nExpr ) )  location: 2221 cross_layer: 5 file: select.c
pRet = sqlite3ExprCollSeq ( pParse , p -> pEList -> a [ iCol ] . pExpr ); location: 2222 cross_layer: 5 file: select.c
return pRet ; location: 2224 cross_layer: 5 file: select.c
if ( 0 == * apColl )  location: 2839 cross_layer: 4 file: select.c
* apColl = db -> pDfltColl; location: 2840 cross_layer: 4 file: select.c
for(pLoop=p; pLoop; pLoop=pLoop->pPrior) location: 2844 cross_layer: 4 file: select.c
for(i=0; i<2; i++) location: 2845 cross_layer: 4 file: select.c
int addr = pLoop -> addrOpenEphm [ i ] ; location: 2846 cross_layer: 4 file: select.c
if ( addr < 0 )  location: 2847 cross_layer: 4 file: select.c
assert ( pLoop -> addrOpenEphm [ 1 ] < 0 ); location: 2850 cross_layer: 4 file: select.c
sqlite3VdbeChangeP2 ( v , addr , nCol ); location: 2853 cross_layer: 4 file: select.c
sqlite3VdbeChangeP4 ( v , addr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ); location: 2854 cross_layer: 4 file: select.c
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) location: 1307 cross_layer: 5 file: select.c
if ( p )  location: 1308 cross_layer: 5 file: select.c
assert ( p -> nRef > 0 ); location: 1309 cross_layer: 5 file: select.c
p -> nRef ++; location: 1310 cross_layer: 5 file: select.c
return p ; location: 1312 cross_layer: 5 file: select.c
pLoop -> addrOpenEphm [ i ] = - 1; location: 2856 cross_layer: 4 file: select.c
sqlite3KeyInfoUnref ( pKeyInfo ); location: 2859 cross_layer: 4 file: select.c
void sqlite3KeyInfoUnref(KeyInfo *p) location: 1296 cross_layer: 5 file: select.c
if ( p )  location: 1297 cross_layer: 5 file: select.c
assert ( p -> nRef > 0 ); location: 1298 cross_layer: 5 file: select.c
p -> nRef --; location: 1299 cross_layer: 5 file: select.c
if ( p -> nRef == 0 )  location: 1300 cross_layer: 5 file: select.c
sqlite3DbFreeNN ( p -> db , p ); location: 1300 cross_layer: 5 file: select.c
pDest -> iSdst = dest . iSdst; location: 2863 cross_layer: 4 file: select.c
pDest -> nSdst = dest . nSdst; location: 2864 cross_layer: 4 file: select.c
sqlite3SelectDelete ( db , pDelete ); location: 2865 cross_layer: 4 file: select.c
void sqlite3SelectDelete(sqlite3 *db, Select *p) location: 187 cross_layer: 5 file: select.c
if ( OK_IF_ALWAYS_TRUE ( p ) )  location: 188 cross_layer: 5 file: select.c
clearSelect ( db , p , 1 ); location: 188 cross_layer: 5 file: select.c
return rc ; location: 2866 cross_layer: 4 file: select.c
------------------------------
34 @@ testCode/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c_NEW.c @@ multiSelect @@ 2812 @@ ['pParse->nErr'] @@ {pParse, p, pDest, pPrior, v}
static int multiSelect(
Parse *pParse,        /* Parsing context */
Select *p,            /* The right-most of SELECTs to be coded */
SelectDest *pDest     /* What to do with query results */
) location: 2529 cross_layer: 1 file: select.c
Select * pPrior ; location: 2531 cross_layer: 1 file: select.c
Vdbe * v ; location: 2532 cross_layer: 1 file: select.c
SelectDest dest ; location: 2533 cross_layer: 1 file: select.c
pPrior = p -> pPrior; location: 2544 cross_layer: 1 file: select.c
dest = * pDest; location: 2545 cross_layer: 1 file: select.c
if ( pPrior -> pOrderBy || pPrior -> pLimit )  location: 2546 cross_layer: 1 file: select.c
v = sqlite3GetVdbe ( pParse ); location: 2553 cross_layer: 1 file: select.c
if ( dest . eDest == SRT_EphemTab )  location: 2558 cross_layer: 1 file: select.c
dest . eDest = SRT_Table; location: 2561 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_MultiValue )  location: 2566 cross_layer: 1 file: select.c
rc = multiSelectValues ( pParse , p , & dest ); location: 2567 cross_layer: 1 file: select.c
if ( rc >= 0 )  location: 2568 cross_layer: 1 file: select.c
rc = SQLITE_OK; location: 2569 cross_layer: 1 file: select.c
if ( p -> selFlags & SF_Recursive )  location: 2579 cross_layer: 1 file: select.c
if ( p -> pOrderBy )  location: 2586 cross_layer: 1 file: select.c
switch ( p -> op )  location: 2599 cross_layer: 1 file: select.c
int nLimit ; location: 2602 cross_layer: 1 file: select.c
pPrior -> iLimit = p -> iLimit; location: 2604 cross_layer: 1 file: select.c
pPrior -> iOffset = p -> iOffset; location: 2605 cross_layer: 1 file: select.c
pPrior -> pLimit = p -> pLimit; location: 2606 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & dest ); location: 2607 cross_layer: 1 file: select.c
if ( rc )  location: 2609 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2612 cross_layer: 1 file: select.c
p -> iLimit = pPrior -> iLimit; location: 2613 cross_layer: 1 file: select.c
p -> iOffset = pPrior -> iOffset; location: 2614 cross_layer: 1 file: select.c
if ( p -> iLimit )  location: 2615 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp1 ( v , OP_IfNot , p -> iLimit ); location: 2616 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & dest ); location: 2624 cross_layer: 1 file: select.c
p -> pPrior = pPrior; location: 2627 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEstAdd ( p -> nSelectRow , pPrior -> nSelectRow ); location: 2628 cross_layer: 1 file: select.c
if ( pPrior -> pLimit && sqlite3ExprIsInteger ( pPrior -> pLimit -> pLeft , & nLimit ) && nLimit > 0 && p -> nSelectRow > sqlite3LogEst ( ( u64 ) nLimit ) )  location: 2629 cross_layer: 1 file: select.c
p -> nSelectRow = sqlite3LogEst ( ( u64 ) nLimit ); location: 2633 cross_layer: 1 file: select.c
int unionTab ; location: 2642 cross_layer: 1 file: select.c
int priorOp ; location: 2644 cross_layer: 1 file: select.c
int addr ; location: 2646 cross_layer: 1 file: select.c
SelectDest uniondest ; location: 2647 cross_layer: 1 file: select.c
priorOp = SRT_Union; location: 2651 cross_layer: 1 file: select.c
if ( dest . eDest == priorOp )  location: 2652 cross_layer: 1 file: select.c
unionTab = pParse -> nTab ++; location: 2662 cross_layer: 1 file: select.c
addr = sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , unionTab , 0 ); location: 2664 cross_layer: 1 file: select.c
p -> addrOpenEphm [ 0 ] = addr; location: 2666 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & uniondest ); location: 2675 cross_layer: 1 file: select.c
if ( rc )  location: 2676 cross_layer: 1 file: select.c
if ( p -> op == TK_EXCEPT )  location: 2682 cross_layer: 1 file: select.c
op = SRT_Except; location: 2683 cross_layer: 1 file: select.c
op = SRT_Union; location: 2686 cross_layer: 1 file: select.c
p -> pPrior = 0; location: 2688 cross_layer: 1 file: select.c
p -> pLimit = 0; location: 2690 cross_layer: 1 file: select.c
uniondest . eDest = op; location: 2691 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 1 file: select.c
int tab1 , tab2 ; location: 2732 cross_layer: 1 file: select.c
tab1 = pParse -> nTab ++; location: 2743 cross_layer: 1 file: select.c
tab2 = pParse -> nTab ++; location: 2744 cross_layer: 1 file: select.c
rc = sqlite3Select ( pParse , pPrior , & intersectdest ); location: 2756 cross_layer: 1 file: select.c
if ( rc )  location: 2757 cross_layer: 1 file: select.c
if ( pParse -> nErr )  location: 2812 cross_layer: 1 file: select.c
goto multi_select_end ; location: 2812 cross_layer: 1 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 2 file: select.c
return rc ; location: 5852 cross_layer: 2 file: select.c
rc = sqlite3Select ( pParse , p , & uniondest ); location: 2694 cross_layer: 3 file: select.c
testcase ( rc != SQLITE_OK ); location: 2695 cross_layer: 3 file: select.c
if ( rc )  location: 2757 cross_layer: 3 file: select.c
testcase ( rc != SQLITE_OK ); location: 2773 cross_layer: 3 file: select.c
return rc ; location: 2866 cross_layer: 3 file: select.c
rc = multiSelect ( pParse , p , pDest ); location: 5844 cross_layer: 4 file: select.c
return rc ; location: 5852 cross_layer: 4 file: select.c
------------------------------
