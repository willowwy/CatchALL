1 @@ testCode/CVE-2019-19646_CWE-754_ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd_pragma.c_OLD.c @@ sqlite3Pragma @@ 1599 @@ ['v'] @@ {pParse, pId1, pId2, pValue, pId, aFcntl [ 4 ], db, pDb, v, pPragma, pPager, zMode, pBt, pTab, pCol, pPk, pIdx, i, pTab, pIdx, pTab, pIdx, pTab, p, pColl, j, j, pFK, pTab, pFK, pTab, pParent, pIdx, k, aiCols, x, pTbls, aRoot, pTab, pIdx, pTab, pIdx, pTab, pIdx ,, pPk, pCheck}
void sqlite3Pragma(
Parse *pParse,
Token *pId1,        /* First part of [schema.]id field */
Token *pId2,        /* Second part of [schema.]id field, or NULL */
Token *pValue,      /* Token for <value>, or NULL */
int minusFlag       /* True if a '-' sign preceded <value> */
) location: 335 cross_layer: 1 file: pragma.c
Token * pId ; location: 339 cross_layer: 1 file: pragma.c
char * aFcntl [ 4 ] ; location: 340 cross_layer: 1 file: pragma.c
int iDb ; location: 341 cross_layer: 1 file: pragma.c
int rc ; location: 342 cross_layer: 1 file: pragma.c
sqlite3 * db = pParse -> db ; location: 343 cross_layer: 1 file: pragma.c
Db * pDb ; location: 344 cross_layer: 1 file: pragma.c
Vdbe * v = sqlite3GetVdbe ( pParse ) ; location: 345 cross_layer: 1 file: pragma.c
const PragmaName * pPragma ; location: 346 cross_layer: 1 file: pragma.c
if ( v == 0 )  location: 348 cross_layer: 1 file: pragma.c
pParse -> nMem = 2; location: 350 cross_layer: 1 file: pragma.c
iDb = sqlite3TwoPartName ( pParse , pId1 , pId2 , & pId ); location: 354 cross_layer: 1 file: pragma.c
if ( iDb < 0 )  location: 355 cross_layer: 1 file: pragma.c
pDb = & db -> aDb [ iDb ]; location: 356 cross_layer: 1 file: pragma.c
if ( iDb == 1 && sqlite3OpenTempDatabase ( pParse ) )  location: 361 cross_layer: 1 file: pragma.c
zLeft = sqlite3NameFromToken ( db , pId ); location: 365 cross_layer: 1 file: pragma.c
if ( ! zLeft )  location: 366 cross_layer: 1 file: pragma.c
if ( minusFlag )  location: 367 cross_layer: 1 file: pragma.c
zRight = sqlite3MPrintf ( db , "-%T" , pValue ); location: 368 cross_layer: 1 file: pragma.c
zRight = sqlite3NameFromToken ( db , pValue ); location: 370 cross_layer: 1 file: pragma.c
zDb = pId2 -> n > 0 ? pDb -> zDbSName : 0; location: 374 cross_layer: 1 file: pragma.c
if ( sqlite3AuthCheck ( pParse , SQLITE_PRAGMA , zLeft , zRight , zDb ) )  location: 375 cross_layer: 1 file: pragma.c
aFcntl [ 0 ] = 0; location: 394 cross_layer: 1 file: pragma.c
aFcntl [ 1 ] = zLeft; location: 395 cross_layer: 1 file: pragma.c
aFcntl [ 2 ] = zRight; location: 396 cross_layer: 1 file: pragma.c
aFcntl [ 3 ] = 0; location: 397 cross_layer: 1 file: pragma.c
db -> busyHandler . nBusy = 0; location: 398 cross_layer: 1 file: pragma.c
rc = sqlite3_file_control ( db , zDb , SQLITE_FCNTL_PRAGMA , ( void * ) aFcntl ); location: 399 cross_layer: 1 file: pragma.c
if ( rc == SQLITE_OK )  location: 400 cross_layer: 1 file: pragma.c
if ( rc != SQLITE_NOTFOUND )  location: 407 cross_layer: 1 file: pragma.c
pPragma = pragmaLocate ( zLeft ); location: 418 cross_layer: 1 file: pragma.c
if ( pPragma == 0 )  location: 419 cross_layer: 1 file: pragma.c
if ( ( pPragma -> mPragFlg & PragFlg_NeedSchema ) != 0 )  location: 422 cross_layer: 1 file: pragma.c
if ( sqlite3ReadSchema ( pParse ) )  location: 423 cross_layer: 1 file: pragma.c
switch ( pPragma -> ePragTyp )  location: 434 cross_layer: 1 file: pragma.c
if ( ! zRight )  location: 468 cross_layer: 1 file: pragma.c
int size = sqlite3AbsInt32 ( sqlite3Atoi ( zRight ) ) ; location: 477 cross_layer: 1 file: pragma.c
pDb -> pSchema -> cache_size = size; location: 481 cross_layer: 1 file: pragma.c
int b = - 1 ; location: 526 cross_layer: 1 file: pragma.c
if ( zRight )  location: 528 cross_layer: 1 file: pragma.c
if ( sqlite3_stricmp ( zRight , "fast" ) == 0 )  location: 529 cross_layer: 1 file: pragma.c
b = 2; location: 530 cross_layer: 1 file: pragma.c
b = sqlite3GetBoolean ( zRight , 0 ); location: 532 cross_layer: 1 file: pragma.c
if ( pId2 -> n == 0 && b >= 0 )  location: 535 cross_layer: 1 file: pragma.c
int ii ; location: 536 cross_layer: 1 file: pragma.c
int eMode = getLockingMode ( zRight ) ; location: 583 cross_layer: 1 file: pragma.c
if ( pId2 -> n == 0 && eMode == PAGER_LOCKINGMODE_QUERY )  location: 585 cross_layer: 1 file: pragma.c
Pager * pPager ; location: 592 cross_layer: 1 file: pragma.c
if ( pId2 -> n == 0 )  location: 593 cross_layer: 1 file: pragma.c
int ii ; location: 602 cross_layer: 1 file: pragma.c
for(ii=2; ii<db->nDb; ii++) location: 604 cross_layer: 1 file: pragma.c
pPager = sqlite3BtreePager ( db -> aDb [ ii ] . pBt ); location: 605 cross_layer: 1 file: pragma.c
db -> dfltLockMode = ( u8 ) eMode; location: 608 cross_layer: 1 file: pragma.c
pPager = sqlite3BtreePager ( pDb -> pBt ); location: 610 cross_layer: 1 file: pragma.c
eMode = sqlite3PagerLockingMode ( pPager , eMode ); location: 611 cross_layer: 1 file: pragma.c
int eMode ; location: 629 cross_layer: 1 file: pragma.c
if ( zRight == 0 )  location: 632 cross_layer: 1 file: pragma.c
eMode = PAGER_JOURNALMODE_QUERY; location: 635 cross_layer: 1 file: pragma.c
const char * zMode ; location: 637 cross_layer: 1 file: pragma.c
for(eMode=0; (zMode = sqlite3JournalModename(eMode))!=0; eMode++) location: 639 cross_layer: 1 file: pragma.c
if ( ! zMode )  location: 642 cross_layer: 1 file: pragma.c
eMode = PAGER_JOURNALMODE_QUERY; location: 645 cross_layer: 1 file: pragma.c
if ( eMode == PAGER_JOURNALMODE_OFF && ( db -> flags & SQLITE_Defensive ) != 0 )  location: 647 cross_layer: 1 file: pragma.c
eMode = PAGER_JOURNALMODE_QUERY; location: 650 cross_layer: 1 file: pragma.c
if ( eMode == PAGER_JOURNALMODE_QUERY && pId2 -> n == 0 )  location: 653 cross_layer: 1 file: pragma.c
iDb = 0; location: 655 cross_layer: 1 file: pragma.c
pId2 -> n = 1; location: 656 cross_layer: 1 file: pragma.c
Btree * pBt = pDb -> pBt ; location: 697 cross_layer: 1 file: pragma.c
if ( ! zRight )  location: 699 cross_layer: 1 file: pragma.c
int eAuto = getAutoVacuum ( zRight ) ; location: 702 cross_layer: 1 file: pragma.c
rc = sqlite3BtreeSetAutoVacuum ( pBt , eAuto ); location: 710 cross_layer: 1 file: pragma.c
if ( ! zRight )  location: 778 cross_layer: 1 file: pragma.c
int size = sqlite3Atoi ( zRight ) ; location: 781 cross_layer: 1 file: pragma.c
pDb -> pSchema -> cache_size = size; location: 782 cross_layer: 1 file: pragma.c
if ( ! zRight )  location: 812 cross_layer: 1 file: pragma.c
int size = 1 ; location: 817 cross_layer: 1 file: pragma.c
if ( sqlite3GetBoolean ( zRight , size != 0 ) )  location: 821 cross_layer: 1 file: pragma.c
db -> flags &= ~ ( u64 ) SQLITE_CacheSpill; location: 824 cross_layer: 1 file: pragma.c
sqlite3_int64 sz ; location: 846 cross_layer: 1 file: pragma.c
if ( zRight )  location: 849 cross_layer: 1 file: pragma.c
if ( sz < 0 )  location: 852 cross_layer: 1 file: pragma.c
sz = sqlite3GlobalConfig . szMmap; location: 852 cross_layer: 1 file: pragma.c
if ( pId2 -> n == 0 )  location: 853 cross_layer: 1 file: pragma.c
db -> szMmap = sz; location: 853 cross_layer: 1 file: pragma.c
sz = - 1; location: 860 cross_layer: 1 file: pragma.c
rc = sqlite3_file_control ( db , zDb , SQLITE_FCNTL_MMAP_SIZE , & sz ); location: 861 cross_layer: 1 file: pragma.c
if ( rc == SQLITE_OK )  location: 866 cross_layer: 1 file: pragma.c
if ( rc != SQLITE_NOTFOUND )  location: 868 cross_layer: 1 file: pragma.c
pParse -> nErr ++; location: 869 cross_layer: 1 file: pragma.c
pParse -> rc = rc; location: 870 cross_layer: 1 file: pragma.c
if ( ! zRight )  location: 1021 cross_layer: 1 file: pragma.c
if ( ! db -> autoCommit )  location: 1024 cross_layer: 1 file: pragma.c
if ( iDb != 1 )  location: 1027 cross_layer: 1 file: pragma.c
int iLevel = ( getSafetyLevel ( zRight , 0 , 1 ) + 1 ) & PAGER_SYNCHRONOUS_MASK ; location: 1028 cross_layer: 1 file: pragma.c
if ( iLevel == 0 )  location: 1029 cross_layer: 1 file: pragma.c
iLevel = 1; location: 1029 cross_layer: 1 file: pragma.c
pDb -> safety_level = iLevel; location: 1030 cross_layer: 1 file: pragma.c
pDb -> bSyncSet = 1; location: 1031 cross_layer: 1 file: pragma.c
if ( zRight == 0 )  location: 1041 cross_layer: 1 file: pragma.c
u64 mask = pPragma -> iArg ; location: 1045 cross_layer: 1 file: pragma.c
if ( db -> autoCommit == 0 )  location: 1046 cross_layer: 1 file: pragma.c
mask &= ~ ( SQLITE_ForeignKeys ); location: 1049 cross_layer: 1 file: pragma.c
if ( db -> auth . authLevel == UAUTH_User )  location: 1052 cross_layer: 1 file: pragma.c
mask &= ~ ( SQLITE_WriteSchema ); location: 1054 cross_layer: 1 file: pragma.c
if ( sqlite3GetBoolean ( zRight , 0 ) )  location: 1058 cross_layer: 1 file: pragma.c
db -> flags &= ~mask; location: 1061 cross_layer: 1 file: pragma.c
if ( mask == SQLITE_DeferFKs )  location: 1062 cross_layer: 1 file: pragma.c
db -> nDeferredImmCons = 0; location: 1062 cross_layer: 1 file: pragma.c
if ( zRight )  location: 1090 cross_layer: 1 file: pragma.c
Table * pTab ; location: 1091 cross_layer: 1 file: pragma.c
pTab = sqlite3LocateTable ( pParse , LOCATE_NOERR , zRight , zDb ); location: 1092 cross_layer: 1 file: pragma.c
if ( pTab )  location: 1093 cross_layer: 1 file: pragma.c
int i , k ; location: 1095 cross_layer: 1 file: pragma.c
Column * pCol ; location: 1097 cross_layer: 1 file: pragma.c
Index * pPk = sqlite3PrimaryKeyIndex ( pTab ) ; location: 1098 cross_layer: 1 file: pragma.c
pParse -> nMem = 7; location: 1099 cross_layer: 1 file: pragma.c
for(i=0, pCol=pTab->aCol; i<pTab->nCol; i++, pCol++) location: 1102 cross_layer: 1 file: pragma.c
if ( pCol -> colFlags & COLFLAG_NOINSERT )  location: 1104 cross_layer: 1 file: pragma.c
if ( pPragma -> iArg == 0 )  location: 1105 cross_layer: 1 file: pragma.c
if ( ( pCol -> colFlags & COLFLAG_PRIMKEY ) == 0 )  location: 1117 cross_layer: 1 file: pragma.c
if ( pPk == 0 )  location: 1119 cross_layer: 1 file: pragma.c
for(k=1; k<=pTab->nCol && pPk->aiColumn[k-1]!=i; k++) location: 1122 cross_layer: 1 file: pragma.c
Index * pIdx ; location: 1140 cross_layer: 1 file: pragma.c
HashElem * i ; location: 1141 cross_layer: 1 file: pragma.c
pParse -> nMem = 5; location: 1142 cross_layer: 1 file: pragma.c
for(i=sqliteHashFirst(&pDb->pSchema->tblHash); i; i=sqliteHashNext(i)) location: 1144 cross_layer: 1 file: pragma.c
Table * pTab = sqliteHashData ( i ) ; location: 1145 cross_layer: 1 file: pragma.c
for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext) location: 1152 cross_layer: 1 file: pragma.c
if ( zRight )  location: 1165 cross_layer: 1 file: pragma.c
Index * pIdx ; location: 1166 cross_layer: 1 file: pragma.c
Table * pTab ; location: 1167 cross_layer: 1 file: pragma.c
pIdx = sqlite3FindIndex ( db , zRight , zDb ); location: 1168 cross_layer: 1 file: pragma.c
if ( pIdx == 0 )  location: 1169 cross_layer: 1 file: pragma.c
pTab = sqlite3LocateTable ( pParse , LOCATE_NOERR , zRight , zDb ); location: 1173 cross_layer: 1 file: pragma.c
if ( pTab && ! HasRowid ( pTab ) )  location: 1174 cross_layer: 1 file: pragma.c
pIdx = sqlite3PrimaryKeyIndex ( pTab ); location: 1175 cross_layer: 1 file: pragma.c
if ( pIdx )  location: 1178 cross_layer: 1 file: pragma.c
int i ; location: 1180 cross_layer: 1 file: pragma.c
int mx ; location: 1181 cross_layer: 1 file: pragma.c
if ( pPragma -> iArg )  location: 1182 cross_layer: 1 file: pragma.c
mx = pIdx -> nColumn; location: 1184 cross_layer: 1 file: pragma.c
pParse -> nMem = 6; location: 1185 cross_layer: 1 file: pragma.c
mx = pIdx -> nKeyCol; location: 1188 cross_layer: 1 file: pragma.c
pParse -> nMem = 3; location: 1189 cross_layer: 1 file: pragma.c
pTab = pIdx -> pTable; location: 1191 cross_layer: 1 file: pragma.c
for(i=0; i<mx; i++) location: 1194 cross_layer: 1 file: pragma.c
if ( zRight )  location: 1210 cross_layer: 1 file: pragma.c
Index * pIdx ; location: 1211 cross_layer: 1 file: pragma.c
Table * pTab ; location: 1212 cross_layer: 1 file: pragma.c
int i ; location: 1213 cross_layer: 1 file: pragma.c
pTab = sqlite3FindTable ( db , zRight , zDb ); location: 1214 cross_layer: 1 file: pragma.c
if ( pTab )  location: 1215 cross_layer: 1 file: pragma.c
pParse -> nMem = 5; location: 1217 cross_layer: 1 file: pragma.c
for(pIdx=pTab->pIndex, i=0; pIdx; pIdx=pIdx->pNext, i++) location: 1219 cross_layer: 1 file: pragma.c
int i ; location: 1233 cross_layer: 1 file: pragma.c
pParse -> nMem = 3; location: 1234 cross_layer: 1 file: pragma.c
i ++ location: 1235 cross_layer: 1 file: pragma.c
int i = 0 ; location: 1247 cross_layer: 1 file: pragma.c
HashElem * p ; location: 1248 cross_layer: 1 file: pragma.c
pParse -> nMem = 2; location: 1249 cross_layer: 1 file: pragma.c
for(p=sqliteHashFirst(&db->aCollSeq); p; p=sqliteHashNext(p)) location: 1250 cross_layer: 1 file: pragma.c
CollSeq * pColl = ( CollSeq * ) sqliteHashData ( p ) ; location: 1251 cross_layer: 1 file: pragma.c
sqlite3VdbeMultiLoad ( v , 1 , "is" , i ++ , pColl -> zName ); location: 1252 cross_layer: 1 file: pragma.c
int i ; location: 1259 cross_layer: 1 file: pragma.c
HashElem * j ; location: 1260 cross_layer: 1 file: pragma.c
pParse -> nMem = 2; location: 1262 cross_layer: 1 file: pragma.c
for(i=0; i<SQLITE_FUNC_HASH_SZ; i++) location: 1263 cross_layer: 1 file: pragma.c
for(j=sqliteHashFirst(&db->aFunc); j; j=sqliteHashNext(j)) location: 1269 cross_layer: 1 file: pragma.c
HashElem * j ; location: 1278 cross_layer: 1 file: pragma.c
pParse -> nMem = 1; location: 1279 cross_layer: 1 file: pragma.c
for(j=sqliteHashFirst(&db->aModule); j; j=sqliteHashNext(j)) location: 1280 cross_layer: 1 file: pragma.c
int i ; location: 1289 cross_layer: 1 file: pragma.c
for(i=0; i<ArraySize(aPragmaName); i++) location: 1290 cross_layer: 1 file: pragma.c
if ( zRight )  location: 1300 cross_layer: 1 file: pragma.c
FKey * pFK ; location: 1301 cross_layer: 1 file: pragma.c
Table * pTab ; location: 1302 cross_layer: 1 file: pragma.c
pTab = sqlite3FindTable ( db , zRight , zDb ); location: 1303 cross_layer: 1 file: pragma.c
if ( pTab )  location: 1304 cross_layer: 1 file: pragma.c
pFK = pTab -> pFKey; location: 1305 cross_layer: 1 file: pragma.c
if ( pFK )  location: 1306 cross_layer: 1 file: pragma.c
pParse -> nMem = 8; location: 1309 cross_layer: 1 file: pragma.c
while ( pFK )  location: 1311 cross_layer: 1 file: pragma.c
int j ; location: 1312 cross_layer: 1 file: pragma.c
for(j=0; j<pFK->nCol; j++) location: 1313 cross_layer: 1 file: pragma.c
pFK = pFK -> pNextFrom; location: 1325 cross_layer: 1 file: pragma.c
FKey * pFK ; location: 1336 cross_layer: 1 file: pragma.c
Table * pTab ; location: 1337 cross_layer: 1 file: pragma.c
Table * pParent ; location: 1338 cross_layer: 1 file: pragma.c
Index * pIdx ; location: 1339 cross_layer: 1 file: pragma.c
int i ; location: 1340 cross_layer: 1 file: pragma.c
int j ; location: 1341 cross_layer: 1 file: pragma.c
HashElem * k ; location: 1342 cross_layer: 1 file: pragma.c
int x ; location: 1343 cross_layer: 1 file: pragma.c
int regRow ; location: 1346 cross_layer: 1 file: pragma.c
int * aiCols ; location: 1349 cross_layer: 1 file: pragma.c
pParse -> nMem += 4; location: 1352 cross_layer: 1 file: pragma.c
regRow = ++ pParse -> nMem; location: 1354 cross_layer: 1 file: pragma.c
k = sqliteHashFirst ( & db -> aDb [ iDb ] . pSchema -> tblHash ); location: 1355 cross_layer: 1 file: pragma.c
while ( k )  location: 1356 cross_layer: 1 file: pragma.c
if ( zRight )  location: 1358 cross_layer: 1 file: pragma.c
pTab = sqlite3LocateTable ( pParse , 0 , zRight , zDb ); location: 1359 cross_layer: 1 file: pragma.c
k = 0; location: 1360 cross_layer: 1 file: pragma.c
pTab = ( Table * ) sqliteHashData ( k ); location: 1362 cross_layer: 1 file: pragma.c
if ( pTab == 0 || pTab -> pFKey == 0 )  location: 1365 cross_layer: 1 file: pragma.c
if ( pTab -> nCol + regRow > pParse -> nMem )  location: 1369 cross_layer: 1 file: pragma.c
pParse -> nMem = pTab -> nCol + regRow; location: 1369 cross_layer: 1 file: pragma.c
for(i=1, pFK=pTab->pFKey; pFK; i++, pFK=pFK->pNextFrom) location: 1372 cross_layer: 1 file: pragma.c
pParent = sqlite3FindTable ( db , pFK -> zTo , zDb ); location: 1373 cross_layer: 1 file: pragma.c
if ( pParent == 0 )  location: 1374 cross_layer: 1 file: pragma.c
pIdx = 0; location: 1375 cross_layer: 1 file: pragma.c
x = sqlite3FkLocateIndex ( pParse , pParent , pFK , & pIdx , 0 ); location: 1377 cross_layer: 1 file: pragma.c
if ( pFK )  location: 1391 cross_layer: 1 file: pragma.c
if ( pParse -> nTab < i )  location: 1392 cross_layer: 1 file: pragma.c
pParse -> nTab = i; location: 1392 cross_layer: 1 file: pragma.c
for(i=1, pFK=pTab->pFKey; pFK; i++, pFK=pFK->pNextFrom) location: 1394 cross_layer: 1 file: pragma.c
pParent = sqlite3FindTable ( db , pFK -> zTo , zDb ); location: 1395 cross_layer: 1 file: pragma.c
pIdx = 0; location: 1396 cross_layer: 1 file: pragma.c
aiCols = 0; location: 1397 cross_layer: 1 file: pragma.c
if ( pParent )  location: 1398 cross_layer: 1 file: pragma.c
x = sqlite3FkLocateIndex ( pParse , pParent , pFK , & pIdx , & aiCols ); location: 1399 cross_layer: 1 file: pragma.c
for(j=0; j<pFK->nCol; j++) location: 1408 cross_layer: 1 file: pragma.c
int i , j , addr , mxErr ; location: 1477 cross_layer: 1 file: pragma.c
if ( pId2 -> z == 0 )  location: 1492 cross_layer: 1 file: pragma.c
iDb = - 1; location: 1492 cross_layer: 1 file: pragma.c
for(i=0; i<db->nDb; i++) location: 1508 cross_layer: 1 file: pragma.c
HashElem * x ; location: 1509 cross_layer: 1 file: pragma.c
Hash * pTbls ; location: 1510 cross_layer: 1 file: pragma.c
int * aRoot ; location: 1511 cross_layer: 1 file: pragma.c
if ( OMIT_TEMPDB && i == 1 )  location: 1515 cross_layer: 1 file: pragma.c
if ( iDb >= 0 && i != iDb )  location: 1516 cross_layer: 1 file: pragma.c
pTbls = & db -> aDb [ i ] . pSchema -> tblHash; location: 1526 cross_layer: 1 file: pragma.c
for(cnt=0, x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)) location: 1527 cross_layer: 1 file: pragma.c
Table * pTab = sqliteHashData ( x ) ; location: 1528 cross_layer: 1 file: pragma.c
Index * pIdx ; location: 1529 cross_layer: 1 file: pragma.c
int nIdx ; location: 1530 cross_layer: 1 file: pragma.c
if ( HasRowid ( pTab ) )  location: 1531 cross_layer: 1 file: pragma.c
cnt ++; location: 1531 cross_layer: 1 file: pragma.c
for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++) location: 1532 cross_layer: 1 file: pragma.c
aRoot = sqlite3DbMallocRawNN ( db , sizeof ( int ) * ( cnt + 1 ) ); location: 1535 cross_layer: 1 file: pragma.c
if ( aRoot == 0 )  location: 1536 cross_layer: 1 file: pragma.c
for(cnt=0, x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)) location: 1537 cross_layer: 1 file: pragma.c
Table * pTab = sqliteHashData ( x ) ; location: 1538 cross_layer: 1 file: pragma.c
Index * pIdx ; location: 1539 cross_layer: 1 file: pragma.c
for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext) location: 1541 cross_layer: 1 file: pragma.c
for(x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)) location: 1564 cross_layer: 1 file: pragma.c
Table * pTab = sqliteHashData ( x ) ; location: 1565 cross_layer: 1 file: pragma.c
Index * pIdx , * pPk ; location: 1566 cross_layer: 1 file: pragma.c
if ( pTab -> tnum < 1 )  location: 1572 cross_layer: 1 file: pragma.c
for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++) location: 1580 cross_layer: 1 file: pragma.c
for(j=0; j<pTab->nCol; j++) location: 1593 cross_layer: 1 file: pragma.c
if ( j == pTab -> iPKey )  location: 1596 cross_layer: 1 file: pragma.c
if ( pTab -> aCol [ j ] . notNull == 0 )  location: 1597 cross_layer: 1 file: pragma.c
sqlite3VdbeChangeP5 ( v , OPFLAG_TYPEOFARG ); location: 1599 cross_layer: 1 file: pragma.c
jmp2 = sqlite3VdbeAddOp1 ( v , OP_NotNull , 3 ); location: 1600 cross_layer: 1 file: pragma.c
VdbeCoverage ( v ); location: 1600 cross_layer: 1 file: pragma.c
zErr = sqlite3MPrintf ( db , "NULL value in %s.%s" , pTab -> zName , pTab -> aCol [ j ] . zName ); location: 1601 cross_layer: 1 file: pragma.c
sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 3 , 0 , zErr , P4_DYNAMIC ); location: 1603 cross_layer: 1 file: pragma.c
integrityCheckResultRow ( v ); location: 1604 cross_layer: 1 file: pragma.c
static int integrityCheckResultRow(Vdbe *v) location: 305 cross_layer: 2 file: pragma.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , 3 , 1 ); location: 307 cross_layer: 2 file: pragma.c
addr = sqlite3VdbeAddOp3 ( v , OP_IfPos , 1 , sqlite3VdbeCurrentAddr ( v ) + 2 , 1 ); location: 308 cross_layer: 2 file: pragma.c
VdbeCoverage ( v ); location: 309 cross_layer: 2 file: pragma.c
sqlite3VdbeAddOp0 ( v , OP_Halt ); location: 310 cross_layer: 2 file: pragma.c
return addr ; location: 311 cross_layer: 2 file: pragma.c
sqlite3VdbeJumpHere ( v , jmp2 ); location: 1605 cross_layer: 1 file: pragma.c
if ( pTab -> pCheck && ( db -> flags & SQLITE_IgnoreChecks ) == 0 )  location: 1608 cross_layer: 1 file: pragma.c
ExprList * pCheck = sqlite3ExprListDup ( db , pTab -> pCheck , 0 ) ; location: 1609 cross_layer: 1 file: pragma.c
int addrCkFault = sqlite3VdbeMakeLabel ( pParse ) ; location: 1611 cross_layer: 1 file: pragma.c
int addrCkOk = sqlite3VdbeMakeLabel ( pParse ) ; location: 1612 cross_layer: 1 file: pragma.c
pParse -> iSelfTab = iDataCur + 1; location: 1615 cross_layer: 1 file: pragma.c
for(k=pCheck->nExpr-1; k>0; k--) location: 1616 cross_layer: 1 file: pragma.c
sqlite3ExprIfFalse ( pParse , pCheck -> a [ k ] . pExpr , addrCkFault , 0 ); location: 1617 cross_layer: 1 file: pragma.c
sqlite3ExprIfTrue ( pParse , pCheck -> a [ 0 ] . pExpr , addrCkOk , SQLITE_JUMPIFNULL ); location: 1619 cross_layer: 1 file: pragma.c
sqlite3VdbeResolveLabel ( v , addrCkFault ); location: 1621 cross_layer: 1 file: pragma.c
pParse -> iSelfTab = 0; location: 1622 cross_layer: 1 file: pragma.c
zErr = sqlite3MPrintf ( db , "CHECK constraint failed in %s" , pTab -> zName ); location: 1623 cross_layer: 1 file: pragma.c
sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 3 , 0 , zErr , P4_DYNAMIC ); location: 1625 cross_layer: 1 file: pragma.c
integrityCheckResultRow ( v ); location: 1626 cross_layer: 1 file: pragma.c
static int integrityCheckResultRow(Vdbe *v) location: 305 cross_layer: 2 file: pragma.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , 3 , 1 ); location: 307 cross_layer: 2 file: pragma.c
addr = sqlite3VdbeAddOp3 ( v , OP_IfPos , 1 , sqlite3VdbeCurrentAddr ( v ) + 2 , 1 ); location: 308 cross_layer: 2 file: pragma.c
VdbeCoverage ( v ); location: 309 cross_layer: 2 file: pragma.c
sqlite3VdbeAddOp0 ( v , OP_Halt ); location: 310 cross_layer: 2 file: pragma.c
return addr ; location: 311 cross_layer: 2 file: pragma.c
sqlite3VdbeResolveLabel ( v , addrCkOk ); location: 1627 cross_layer: 1 file: pragma.c
sqlite3ExprListDelete ( db , pCheck ); location: 1629 cross_layer: 1 file: pragma.c
for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++) location: 1633 cross_layer: 1 file: pragma.c
int ckUniq = sqlite3VdbeMakeLabel ( pParse ) ; location: 1635 cross_layer: 1 file: pragma.c
if ( pPk == pIdx )  location: 1636 cross_layer: 1 file: pragma.c
r1 = sqlite3GenerateIndexKey ( pParse , pIdx , iDataCur , 0 , 0 , & jmp3 , pPrior , r1 ); location: 1637 cross_layer: 1 file: pragma.c
pPrior = pIdx; location: 1639 cross_layer: 1 file: pragma.c
sqlite3VdbeAddOp2 ( v , OP_AddImm , 8 + j , 1 ); location: 1640 cross_layer: 1 file: pragma.c
jmp2 = sqlite3VdbeAddOp4Int ( v , OP_Found , iIdxCur + j , ckUniq , r1 , pIdx -> nColumn ); location: 1642 cross_layer: 1 file: pragma.c
VdbeCoverage ( v ); location: 1643 cross_layer: 1 file: pragma.c
sqlite3VdbeLoadString ( v , 3 , "row " ); location: 1644 cross_layer: 1 file: pragma.c
sqlite3VdbeAddOp3 ( v , OP_Concat , 7 , 3 , 3 ); location: 1645 cross_layer: 1 file: pragma.c
sqlite3VdbeLoadString ( v , 4 , " missing from index " ); location: 1646 cross_layer: 1 file: pragma.c
sqlite3VdbeAddOp3 ( v , OP_Concat , 4 , 3 , 3 ); location: 1647 cross_layer: 1 file: pragma.c
jmp5 = sqlite3VdbeLoadString ( v , 4 , pIdx -> zName ); location: 1648 cross_layer: 1 file: pragma.c
sqlite3VdbeAddOp3 ( v , OP_Concat , 4 , 3 , 3 ); location: 1649 cross_layer: 1 file: pragma.c
jmp4 = integrityCheckResultRow ( v ); location: 1650 cross_layer: 1 file: pragma.c
static int integrityCheckResultRow(Vdbe *v) location: 305 cross_layer: 2 file: pragma.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , 3 , 1 ); location: 307 cross_layer: 2 file: pragma.c
addr = sqlite3VdbeAddOp3 ( v , OP_IfPos , 1 , sqlite3VdbeCurrentAddr ( v ) + 2 , 1 ); location: 308 cross_layer: 2 file: pragma.c
VdbeCoverage ( v ); location: 309 cross_layer: 2 file: pragma.c
sqlite3VdbeAddOp0 ( v , OP_Halt ); location: 310 cross_layer: 2 file: pragma.c
return addr ; location: 311 cross_layer: 2 file: pragma.c
sqlite3VdbeJumpHere ( v , jmp2 ); location: 1651 cross_layer: 1 file: pragma.c
if ( IsUniqueIndex ( pIdx ) )  location: 1655 cross_layer: 1 file: pragma.c
int uniqOk = sqlite3VdbeMakeLabel ( pParse ) ; location: 1656 cross_layer: 1 file: pragma.c
for(kk=0; kk<pIdx->nKeyCol; kk++) location: 1659 cross_layer: 1 file: pragma.c
int iCol = pIdx -> aiColumn [ kk ] ; location: 1660 cross_layer: 1 file: pragma.c
assert ( iCol != XN_ROWID && iCol < pTab -> nCol ); location: 1661 cross_layer: 1 file: pragma.c
if ( iCol >= 0 && pTab -> aCol [ iCol ] . notNull )  location: 1662 cross_layer: 1 file: pragma.c
sqlite3VdbeAddOp2 ( v , OP_IsNull , r1 + kk , uniqOk ); location: 1663 cross_layer: 1 file: pragma.c
VdbeCoverage ( v ); location: 1664 cross_layer: 1 file: pragma.c
jmp6 = sqlite3VdbeAddOp1 ( v , OP_Next , iIdxCur + j ); location: 1666 cross_layer: 1 file: pragma.c
VdbeCoverage ( v ); location: 1666 cross_layer: 1 file: pragma.c
sqlite3VdbeGoto ( v , uniqOk ); location: 1667 cross_layer: 1 file: pragma.c
sqlite3VdbeJumpHere ( v , jmp6 ); location: 1668 cross_layer: 1 file: pragma.c
sqlite3VdbeAddOp4Int ( v , OP_IdxGT , iIdxCur + j , uniqOk , r1 , pIdx -> nKeyCol ); location: 1669 cross_layer: 1 file: pragma.c
VdbeCoverage ( v ); location: 1670 cross_layer: 1 file: pragma.c
sqlite3VdbeLoadString ( v , 3 , "non-unique entry in index " ); location: 1671 cross_layer: 1 file: pragma.c
sqlite3VdbeGoto ( v , jmp5 ); location: 1672 cross_layer: 1 file: pragma.c
sqlite3VdbeResolveLabel ( v , uniqOk ); location: 1673 cross_layer: 1 file: pragma.c
sqlite3VdbeJumpHere ( v , jmp4 ); location: 1675 cross_layer: 1 file: pragma.c
sqlite3ResolvePartIdxLabel ( pParse , jmp3 ); location: 1676 cross_layer: 1 file: pragma.c
sqlite3VdbeAddOp2 ( v , OP_Next , iDataCur , loopTop ); location: 1679 cross_layer: 1 file: pragma.c
VdbeCoverage ( v ); location: 1679 cross_layer: 1 file: pragma.c
sqlite3VdbeJumpHere ( v , loopTop - 1 ); location: 1680 cross_layer: 1 file: pragma.c
sqlite3VdbeLoadString ( v , 2 , "wrong # of entries in index " ); location: 1683 cross_layer: 1 file: pragma.c
for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++) location: 1684 cross_layer: 1 file: pragma.c
if ( pPk == pIdx )  location: 1685 cross_layer: 1 file: pragma.c
sqlite3VdbeAddOp2 ( v , OP_Count , iIdxCur + j , 3 ); location: 1686 cross_layer: 1 file: pragma.c
addr = sqlite3VdbeAddOp3 ( v , OP_Eq , 8 + j , 0 , 3 ); location: 1687 cross_layer: 1 file: pragma.c
VdbeCoverage ( v ); location: 1687 cross_layer: 1 file: pragma.c
sqlite3VdbeChangeP5 ( v , SQLITE_NOTNULL ); location: 1688 cross_layer: 1 file: pragma.c
sqlite3VdbeLoadString ( v , 4 , pIdx -> zName ); location: 1689 cross_layer: 1 file: pragma.c
sqlite3VdbeAddOp3 ( v , OP_Concat , 4 , 2 , 3 ); location: 1690 cross_layer: 1 file: pragma.c
integrityCheckResultRow ( v ); location: 1691 cross_layer: 1 file: pragma.c
static int integrityCheckResultRow(Vdbe *v) location: 305 cross_layer: 2 file: pragma.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , 3 , 1 ); location: 307 cross_layer: 2 file: pragma.c
addr = sqlite3VdbeAddOp3 ( v , OP_IfPos , 1 , sqlite3VdbeCurrentAddr ( v ) + 2 , 1 ); location: 308 cross_layer: 2 file: pragma.c
VdbeCoverage ( v ); location: 309 cross_layer: 2 file: pragma.c
sqlite3VdbeAddOp0 ( v , OP_Halt ); location: 310 cross_layer: 2 file: pragma.c
return addr ; location: 311 cross_layer: 2 file: pragma.c
sqlite3VdbeJumpHere ( v , addr ); location: 1692 cross_layer: 1 file: pragma.c
aOp = sqlite3VdbeAddOpList ( v , ArraySize ( endCode ) , endCode , iLn ); location: 1711 cross_layer: 1 file: pragma.c
if ( aOp )  location: 1712 cross_layer: 1 file: pragma.c
aOp [ 0 ] . p2 = 1 - mxErr; location: 1713 cross_layer: 1 file: pragma.c
aOp [ 2 ] . p4type = P4_STATIC; location: 1714 cross_layer: 1 file: pragma.c
aOp [ 2 ] . p4 . z = "ok"; location: 1715 cross_layer: 1 file: pragma.c
aOp [ 5 ] . p4type = P4_STATIC; location: 1716 cross_layer: 1 file: pragma.c
aOp [ 5 ] . p4 . z = ( char * ) sqlite3ErrStr ( SQLITE_CORRUPT ); location: 1717 cross_layer: 1 file: pragma.c
sqlite3VdbeChangeP3 ( v , 0 , sqlite3VdbeCurrentAddr ( v ) - 2 ); location: 1719 cross_layer: 1 file: pragma.c
if ( sqlite3ReadSchema ( pParse ) )  location: 1765 cross_layer: 1 file: pragma.c
returnSingleText ( v , encnames [ ENC ( pParse -> db ) ] . zName ); location: 1769 cross_layer: 1 file: pragma.c
static void returnSingleText(
Vdbe *v,                /* Prepared statement under construction */
const char *zValue      /* Value to be returned */
) location: 198 cross_layer: 2 file: pragma.c
if ( zValue )  location: 199 cross_layer: 2 file: pragma.c
sqlite3VdbeLoadString ( v , 1 , ( const char * ) zValue ); location: 200 cross_layer: 2 file: pragma.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 1 ); location: 201 cross_layer: 2 file: pragma.c
sqlite3ErrorMsg ( pParse , "unsupported encoding: %s" , zRight ); location: 1788 cross_layer: 1 file: pragma.c
sqlite3VdbeUsesBtree ( v , iDb ); location: 1831 cross_layer: 1 file: pragma.c
sqlite3VdbeVerifyNoMallocRequired ( v , ArraySize ( setCookie ) ); location: 1839 cross_layer: 1 file: pragma.c
aOp = sqlite3VdbeAddOpList ( v , ArraySize ( setCookie ) , setCookie , 0 ); location: 1840 cross_layer: 1 file: pragma.c
if ( ONLY_IF_REALLOC_STRESS ( aOp == 0 ) )  location: 1841 cross_layer: 1 file: pragma.c
aOp [ 0 ] . p1 = iDb; location: 1842 cross_layer: 1 file: pragma.c
aOp [ 1 ] . p1 = iDb; location: 1843 cross_layer: 1 file: pragma.c
aOp [ 1 ] . p2 = iCookie; location: 1844 cross_layer: 1 file: pragma.c
aOp [ 1 ] . p3 = sqlite3Atoi ( zRight ); location: 1845 cross_layer: 1 file: pragma.c
sqlite3VdbeVerifyNoMallocRequired ( v , ArraySize ( readCookie ) ); location: 1854 cross_layer: 1 file: pragma.c
aOp = sqlite3VdbeAddOpList ( v , ArraySize ( readCookie ) , readCookie , 0 ); location: 1855 cross_layer: 1 file: pragma.c
if ( ONLY_IF_REALLOC_STRESS ( aOp == 0 ) )  location: 1856 cross_layer: 1 file: pragma.c
aOp [ 0 ] . p1 = iDb; location: 1857 cross_layer: 1 file: pragma.c
aOp [ 1 ] . p1 = iDb; location: 1858 cross_layer: 1 file: pragma.c
aOp [ 1 ] . p3 = iCookie; location: 1859 cross_layer: 1 file: pragma.c
sqlite3VdbeReusable ( v ); location: 1860 cross_layer: 1 file: pragma.c
pParse -> nMem = 1; location: 1876 cross_layer: 1 file: pragma.c
while ( ( zOpt = sqlite3_compileoption_get ( i ++ ) ) != 0 )  location: 1877 cross_layer: 1 file: pragma.c
sqlite3VdbeLoadString ( v , 1 , zOpt ); location: 1878 cross_layer: 1 file: pragma.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 1 ); location: 1879 cross_layer: 1 file: pragma.c
sqlite3VdbeReusable ( v ); location: 1881 cross_layer: 1 file: pragma.c
pParse -> nMem = 3; location: 1904 cross_layer: 1 file: pragma.c
sqlite3VdbeAddOp3 ( v , OP_Checkpoint , iBt , eMode , 1 ); location: 1905 cross_layer: 1 file: pragma.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 3 ); location: 1906 cross_layer: 1 file: pragma.c
returnSingleInt ( v , db -> xWalCallback == sqlite3WalDefaultHook ? SQLITE_PTR_TO_INT ( db -> pWalArg ) : 0 ); location: 1922 cross_layer: 1 file: pragma.c
static void returnSingleInt(Vdbe *v, i64 value) location: 187 cross_layer: 2 file: pragma.c
sqlite3VdbeAddOp4Dup8 ( v , OP_Int64 , 0 , 1 , 0 , ( const u8 * ) & value , P4_INT64 ); location: 188 cross_layer: 2 file: pragma.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 1 ); location: 189 cross_layer: 2 file: pragma.c
iTabCur = pParse -> nTab ++; location: 2012 cross_layer: 1 file: pragma.c
sqlite3CodeVerifySchema ( pParse , iDb ); location: 2015 cross_layer: 1 file: pragma.c
for(k=sqliteHashFirst(&pSchema->tblHash); k; k=sqliteHashNext(k)) location: 2017 cross_layer: 1 file: pragma.c
pTab = ( Table * ) sqliteHashData ( k ); location: 2018 cross_layer: 1 file: pragma.c
if ( ( pTab -> tabFlags & TF_StatsUsed ) == 0 )  location: 2023 cross_layer: 1 file: pragma.c
szThreshold = pTab -> nRowLogEst + 46; location: 2026 cross_layer: 1 file: pragma.c
for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext) location: 2027 cross_layer: 1 file: pragma.c
if ( ! pIdx -> hasStat1 )  location: 2028 cross_layer: 1 file: pragma.c
if ( szThreshold )  location: 2033 cross_layer: 1 file: pragma.c
sqlite3OpenTable ( pParse , iTabCur , iDb , pTab , OP_OpenRead ); location: 2034 cross_layer: 1 file: pragma.c
sqlite3VdbeAddOp3 ( v , OP_IfSmaller , iTabCur , sqlite3VdbeCurrentAddr ( v ) + 2 + ( opMask & 1 ) , szThreshold ); location: 2035 cross_layer: 1 file: pragma.c
VdbeCoverage ( v ); location: 2037 cross_layer: 1 file: pragma.c
zSubSql = sqlite3MPrintf ( db , "ANALYZE \"%w\".\"%w\"" , db -> aDb [ iDb ] . zDbSName , pTab -> zName ); location: 2039 cross_layer: 1 file: pragma.c
int r1 = sqlite3GetTempReg ( pParse ) ; location: 2042 cross_layer: 1 file: pragma.c
sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , r1 , 0 , zSubSql , P4_DYNAMIC ); location: 2043 cross_layer: 1 file: pragma.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , r1 , 1 ); location: 2044 cross_layer: 1 file: pragma.c
sqlite3VdbeAddOp4 ( v , OP_SqlExec , 0 , 0 , 0 , zSubSql , P4_DYNAMIC ); location: 2046 cross_layer: 1 file: pragma.c
sqlite3VdbeAddOp0 ( v , OP_Expire ); location: 2050 cross_layer: 1 file: pragma.c
returnSingleInt ( v , db -> busyTimeout ); location: 2068 cross_layer: 1 file: pragma.c
static void returnSingleInt(Vdbe *v, i64 value) location: 187 cross_layer: 2 file: pragma.c
sqlite3VdbeAddOp4Dup8 ( v , OP_Int64 , 0 , 1 , 0 , ( const u8 * ) & value , P4_INT64 ); location: 188 cross_layer: 2 file: pragma.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 1 ); location: 189 cross_layer: 2 file: pragma.c
returnSingleInt ( v , sqlite3_soft_heap_limit64 ( - 1 ) ); location: 2088 cross_layer: 1 file: pragma.c
static void returnSingleInt(Vdbe *v, i64 value) location: 187 cross_layer: 2 file: pragma.c
sqlite3VdbeAddOp4Dup8 ( v , OP_Int64 , 0 , 1 , 0 , ( const u8 * ) & value , P4_INT64 ); location: 188 cross_layer: 2 file: pragma.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 1 ); location: 189 cross_layer: 2 file: pragma.c
returnSingleInt ( v , sqlite3_hard_heap_limit64 ( - 1 ) ); location: 2109 cross_layer: 1 file: pragma.c
static void returnSingleInt(Vdbe *v, i64 value) location: 187 cross_layer: 2 file: pragma.c
sqlite3VdbeAddOp4Dup8 ( v , OP_Int64 , 0 , 1 , 0 , ( const u8 * ) & value , P4_INT64 ); location: 188 cross_layer: 2 file: pragma.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 1 ); location: 189 cross_layer: 2 file: pragma.c
returnSingleInt ( v , sqlite3_limit ( db , SQLITE_LIMIT_WORKER_THREADS , - 1 ) ); location: 2128 cross_layer: 1 file: pragma.c
static void returnSingleInt(Vdbe *v, i64 value) location: 187 cross_layer: 2 file: pragma.c
sqlite3VdbeAddOp4Dup8 ( v , OP_Int64 , 0 , 1 , 0 , ( const u8 * ) & value , P4_INT64 ); location: 188 cross_layer: 2 file: pragma.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 1 ); location: 189 cross_layer: 2 file: pragma.c
pParse -> nMem = 2; location: 2141 cross_layer: 1 file: pragma.c
for(i=0; i<db->nDb; i++) location: 2142 cross_layer: 1 file: pragma.c
if ( db -> aDb [ i ] . zDbSName == 0 )  location: 2146 cross_layer: 1 file: pragma.c
pBt = db -> aDb [ i ] . pBt; location: 2147 cross_layer: 1 file: pragma.c
if ( pBt == 0 || sqlite3BtreePager ( pBt ) == 0 )  location: 2148 cross_layer: 1 file: pragma.c
if ( sqlite3_file_control ( db , i ? db -> aDb [ i ] . zDbSName : 0 , SQLITE_FCNTL_LOCKSTATE , & j ) == SQLITE_OK )  location: 2150 cross_layer: 1 file: pragma.c
zState = azLockName [ j ]; location: 2152 cross_layer: 1 file: pragma.c
sqlite3VdbeMultiLoad ( v , 1 , "ss" , db -> aDb [ i ] . zDbSName , zState ); location: 2154 cross_layer: 1 file: pragma.c
for(i=0, iByte=0; i<sizeof(zBuf)*2 && sqlite3Isxdigit(zRight[i]); i++) location: 2178 cross_layer: 1 file: pragma.c
iByte = ( iByte << 4 ) + sqlite3HexToInt ( zRight [ i ] ); location: 2179 cross_layer: 1 file: pragma.c
if ( ( i & 1 ) != 0 )  location: 2180 cross_layer: 1 file: pragma.c
zBuf [ i / 2 ] = iByte; location: 2180 cross_layer: 1 file: pragma.c
zKey = zBuf; location: 2182 cross_layer: 1 file: pragma.c
n = i / 2; location: 2183 cross_layer: 1 file: pragma.c
rc = sqlite3_key_v2 ( db , zDb , zKey , n ); location: 2188 cross_layer: 1 file: pragma.c
rc = sqlite3_rekey_v2 ( db , zDb , zKey , n ); location: 2190 cross_layer: 1 file: pragma.c
if ( rc == SQLITE_OK && n != 0 )  location: 2192 cross_layer: 1 file: pragma.c
sqlite3VdbeSetNumCols ( v , 1 ); location: 2193 cross_layer: 1 file: pragma.c
sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , "ok" , SQLITE_STATIC ); location: 2194 cross_layer: 1 file: pragma.c
returnSingleText ( v , "ok" ); location: 2195 cross_layer: 1 file: pragma.c
static void returnSingleText(
Vdbe *v,                /* Prepared statement under construction */
const char *zValue      /* Value to be returned */
) location: 198 cross_layer: 2 file: pragma.c
if ( zValue )  location: 199 cross_layer: 2 file: pragma.c
sqlite3VdbeLoadString ( v , 1 , ( const char * ) zValue ); location: 200 cross_layer: 2 file: pragma.c
sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 1 ); location: 201 cross_layer: 2 file: pragma.c
sqlite3VdbeVerifyNoResultRow ( v ); location: 2225 cross_layer: 1 file: pragma.c
------------------------------
