1 @@ testCode/CVE-2017-3735_CWE-119_068b963bb7afc57f5bdd723de0dd15e7795d5822_v3_addr.c_NEW.c @@ length_from_afi @@ 879 @@ ['f->addressFamily->length', 'f->addressFamily->data', 'f', 'f->addressFamily'] @@ {addr}
int X509v3_addr_canonize(IPAddrBlocks *addr) location: 867 cross_layer: 1 file: v3_addr.c
int i ; location: 869 cross_layer: 1 file: v3_addr.c
for (i = 0; i < sk_IPAddressFamily_num(addr); i++) location: 870 cross_layer: 1 file: v3_addr.c
sk_IPAddressFamily_sort ( addr ); location: 879 cross_layer: 1 file: v3_addr.c
OPENSSL_assert ( X509v3_addr_is_canonical ( addr ) ); location: 880 cross_layer: 1 file: v3_addr.c
int X509v3_addr_is_canonical(IPAddrBlocks *addr) location: 683 cross_layer: 2 file: v3_addr.c
if ( addr == NULL )  location: 693 cross_layer: 2 file: v3_addr.c
for (i = 0; i < sk_IPAddressFamily_num(addr) - 1; i++) location: 699 cross_layer: 2 file: v3_addr.c
const IPAddressFamily * a = sk_IPAddressFamily_value ( addr , i ) ; location: 700 cross_layer: 2 file: v3_addr.c
const IPAddressFamily * b = sk_IPAddressFamily_value ( addr , i + 1 ) ; location: 701 cross_layer: 2 file: v3_addr.c
for (i = 0; i < sk_IPAddressFamily_num(addr); i++) location: 709 cross_layer: 2 file: v3_addr.c
IPAddressFamily * f = sk_IPAddressFamily_value ( addr , i ) ; location: 710 cross_layer: 2 file: v3_addr.c
int length = length_from_afi ( X509v3_addr_get_afi ( f ) ) ; location: 711 cross_layer: 2 file: v3_addr.c
unsigned int X509v3_addr_get_afi(const IPAddressFamily *f) location: 85 cross_layer: 3 file: v3_addr.c
if ( f == NULL || f -> addressFamily == NULL || f -> addressFamily -> data == NULL || f -> addressFamily -> length < 2 )  location: 87 cross_layer: 3 file: v3_addr.c
return ( f -> addressFamily -> data [ 0 ] << 8 ) | f -> addressFamily -> data [ 1 ] ; location: 92 cross_layer: 3 file: v3_addr.c
if ( f == NULL || f -> ipAddressChoice == NULL )  location: 717 cross_layer: 2 file: v3_addr.c
switch ( f -> ipAddressChoice -> type )  location: 719 cross_layer: 2 file: v3_addr.c
aors = f -> ipAddressChoice -> u . addressesOrRanges; location: 731 cross_layer: 2 file: v3_addr.c
if ( sk_IPAddressOrRange_num ( aors ) == 0 )  location: 732 cross_layer: 2 file: v3_addr.c
for (j = 0; j < sk_IPAddressOrRange_num(aors) - 1; j++) location: 734 cross_layer: 2 file: v3_addr.c
IPAddressOrRange * a = sk_IPAddressOrRange_value ( aors , j ) ; location: 735 cross_layer: 2 file: v3_addr.c
IPAddressOrRange * b = sk_IPAddressOrRange_value ( aors , j + 1 ) ; location: 736 cross_layer: 2 file: v3_addr.c
if ( ! extract_min_max ( a , a_min , a_max , length ) || ! extract_min_max ( b , b_min , b_max , length ) )  location: 738 cross_layer: 2 file: v3_addr.c
static int extract_min_max(IPAddressOrRange *aor,
unsigned char *min, unsigned char *max, int length) location: 626 cross_layer: 3 file: v3_addr.c
if ( aor == NULL || min == NULL || max == NULL )  location: 628 cross_layer: 3 file: v3_addr.c
switch ( aor -> type )  location: 630 cross_layer: 3 file: v3_addr.c
return ( addr_expand ( min , aor -> u . addressPrefix , length , 0x00 ) && addr_expand ( max , aor -> u . addressPrefix , length , 0xFF ) ) ; location: 632 cross_layer: 3 file: v3_addr.c
return ( addr_expand ( min , aor -> u . addressRange -> min , length , 0x00 ) && addr_expand ( max , aor -> u . addressRange -> max , length , 0xFF ) ) ; location: 635 cross_layer: 3 file: v3_addr.c
static int extract_min_max(IPAddressOrRange *aor,
unsigned char *min, unsigned char *max, int length) location: 626 cross_layer: 3 file: v3_addr.c
if ( aor == NULL || min == NULL || max == NULL )  location: 628 cross_layer: 3 file: v3_addr.c
switch ( aor -> type )  location: 630 cross_layer: 3 file: v3_addr.c
return ( addr_expand ( min , aor -> u . addressPrefix , length , 0x00 ) && addr_expand ( max , aor -> u . addressPrefix , length , 0xFF ) ) ; location: 632 cross_layer: 3 file: v3_addr.c
return ( addr_expand ( min , aor -> u . addressRange -> min , length , 0x00 ) && addr_expand ( max , aor -> u . addressRange -> max , length , 0xFF ) ) ; location: 635 cross_layer: 3 file: v3_addr.c
if ( memcmp ( a_min , b_min , length ) >= 0 || memcmp ( a_min , a_max , length ) > 0 || memcmp ( b_min , b_max , length ) > 0 )  location: 745 cross_layer: 2 file: v3_addr.c
for (k = length - 1; k >= 0 && b_min[k]-- == 0x00; k--) ; location: 754 cross_layer: 2 file: v3_addr.c
if ( memcmp ( a_max , b_min , length ) >= 0 )  location: 755 cross_layer: 2 file: v3_addr.c
if ( a -> type == IPAddressOrRange_addressRange && range_should_be_prefix ( a_min , a_max , length ) >= 0 )  location: 761 cross_layer: 2 file: v3_addr.c
static int range_should_be_prefix(const unsigned char *min,
const unsigned char *max, const int length) location: 340 cross_layer: 3 file: v3_addr.c
OPENSSL_assert ( memcmp ( min , max , length ) <= 0 ); location: 345 cross_layer: 3 file: v3_addr.c
for (i = 0; i < length && min[i] == max[i]; i++) ; location: 346 cross_layer: 3 file: v3_addr.c
for (j = length - 1; j >= 0 && min[j] == 0x00 && max[j] == 0xFF; j--) ; location: 347 cross_layer: 3 file: v3_addr.c
if ( i < j )  location: 348 cross_layer: 3 file: v3_addr.c
if ( i > j )  location: 350 cross_layer: 3 file: v3_addr.c
mask = min [ i ] ^ max [ i ]; location: 352 cross_layer: 3 file: v3_addr.c
switch ( mask )  location: 353 cross_layer: 3 file: v3_addr.c
if ( ( min [ i ] & mask ) != 0 || ( max [ i ] & mask ) != mask )  location: 378 cross_layer: 3 file: v3_addr.c
return i * 8 + j ; location: 381 cross_layer: 3 file: v3_addr.c
j = sk_IPAddressOrRange_num ( aors ) - 1; location: 770 cross_layer: 2 file: v3_addr.c
IPAddressOrRange * a = sk_IPAddressOrRange_value ( aors , j ) ; location: 772 cross_layer: 2 file: v3_addr.c
if ( a != NULL && a -> type == IPAddressOrRange_addressRange )  location: 773 cross_layer: 2 file: v3_addr.c
if ( ! extract_min_max ( a , a_min , a_max , length ) )  location: 774 cross_layer: 2 file: v3_addr.c
static int extract_min_max(IPAddressOrRange *aor,
unsigned char *min, unsigned char *max, int length) location: 626 cross_layer: 3 file: v3_addr.c
if ( aor == NULL || min == NULL || max == NULL )  location: 628 cross_layer: 3 file: v3_addr.c
switch ( aor -> type )  location: 630 cross_layer: 3 file: v3_addr.c
return ( addr_expand ( min , aor -> u . addressPrefix , length , 0x00 ) && addr_expand ( max , aor -> u . addressPrefix , length , 0xFF ) ) ; location: 632 cross_layer: 3 file: v3_addr.c
return ( addr_expand ( min , aor -> u . addressRange -> min , length , 0x00 ) && addr_expand ( max , aor -> u . addressRange -> max , length , 0xFF ) ) ; location: 635 cross_layer: 3 file: v3_addr.c
if ( memcmp ( a_min , a_max , length ) > 0 || range_should_be_prefix ( a_min , a_max , length ) >= 0 )  location: 776 cross_layer: 2 file: v3_addr.c
static int range_should_be_prefix(const unsigned char *min,
const unsigned char *max, const int length) location: 340 cross_layer: 3 file: v3_addr.c
OPENSSL_assert ( memcmp ( min , max , length ) <= 0 ); location: 345 cross_layer: 3 file: v3_addr.c
if ( i < j )  location: 348 cross_layer: 3 file: v3_addr.c
if ( i > j )  location: 350 cross_layer: 3 file: v3_addr.c
mask = min [ i ] ^ max [ i ]; location: 352 cross_layer: 3 file: v3_addr.c
switch ( mask )  location: 353 cross_layer: 3 file: v3_addr.c
if ( ( min [ i ] & mask ) != 0 || ( max [ i ] & mask ) != mask )  location: 378 cross_layer: 3 file: v3_addr.c
return i * 8 + j ; location: 381 cross_layer: 3 file: v3_addr.c
------------------------------
