1 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3475 @@ ['*end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8884 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
ret = xmlParseQName ( ctxt , & prefix2 ); location: 8975 cross_layer: 4 file: parser.c
if ( ( ret == name ) && ( prefix == prefix2 ) )  location: 8976 cross_layer: 4 file: parser.c
return ret ; location: 8978 cross_layer: 4 file: parser.c
------------------------------
2 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3475 @@ ['*end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8884 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
localname = xmlParseQName ( ctxt , & prefix ); location: 9390 cross_layer: 4 file: parser.c
if ( localname == NULL )  location: 9391 cross_layer: 4 file: parser.c
attname = xmlParseAttribute2 ( ctxt , prefix , localname , & aprefix , & attvalue , & len , & alloc ); location: 9415 cross_layer: 4 file: parser.c
static const xmlChar *
xmlParseAttribute2(xmlParserCtxtPtr ctxt,
const xmlChar * pref, const xmlChar * elem,
const xmlChar ** prefix, xmlChar ** value,
int *len, int *alloc) location: 9221 cross_layer: 5 file: parser.c
* value = NULL; location: 9227 cross_layer: 5 file: parser.c
name = xmlParseQName ( ctxt , prefix ); location: 9229 cross_layer: 5 file: parser.c
if ( name == NULL )  location: 9230 cross_layer: 5 file: parser.c
xmlFatalErrMsg ( ctxt , XML_ERR_NAME_REQUIRED , "error parsing attribute name\n" ); location: 9231 cross_layer: 5 file: parser.c
if ( ctxt -> attsSpecial != NULL )  location: 9239 cross_layer: 5 file: parser.c
type = ( int ) ( long ) xmlHashQLookup2 ( ctxt -> attsSpecial , pref , elem , * prefix , name ); location: 9242 cross_layer: 5 file: parser.c
if ( type != 0 )  location: 9244 cross_layer: 5 file: parser.c
val = xmlParseAttValueInternal ( ctxt , len , alloc , normalize ); location: 9255 cross_layer: 5 file: parser.c
if ( * alloc )  location: 9263 cross_layer: 5 file: parser.c
val2 = xmlAttrNormalizeSpace2 ( ctxt , val , len ); location: 9266 cross_layer: 5 file: parser.c
if ( ( val2 != NULL ) && ( val2 != val ) )  location: 9267 cross_layer: 5 file: parser.c
xmlFree ( val ); location: 9268 cross_layer: 5 file: parser.c
val = ( xmlChar * ) val2; location: 9269 cross_layer: 5 file: parser.c
ctxt -> instate = XML_PARSER_CONTENT; location: 9273 cross_layer: 5 file: parser.c
xmlFatalErrMsgStr ( ctxt , XML_ERR_ATTRIBUTE_WITHOUT_VALUE , "Specification mandate value for attribute %s\n" , name ); location: 9275 cross_layer: 5 file: parser.c
if ( * prefix == ctxt -> str_xml )  location: 9281 cross_layer: 5 file: parser.c
if ( ( ctxt -> pedantic ) && ( xmlStrEqual ( name , BAD_CAST "lang" ) ) ) location: 9287 cross_layer: 5 file: parser.c
internal_val = xmlStrndup ( val , * len ); location: 9288 cross_layer: 5 file: parser.c
if ( ! xmlCheckLanguageID ( internal_val ) )  location: 9289 cross_layer: 5 file: parser.c
xmlWarningMsg ( ctxt , XML_WAR_LANG_VALUE , "Malformed value for xml:lang : %s\n" , internal_val , NULL ); location: 9290 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( name , BAD_CAST "space" ) ) location: 9299 cross_layer: 5 file: parser.c
internal_val = xmlStrndup ( val , * len ); location: 9300 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( internal_val , BAD_CAST "default" ) ) location: 9301 cross_layer: 5 file: parser.c
* ( ctxt -> space ) = 0; location: 9302 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( internal_val , BAD_CAST "preserve" ) ) location: 9303 cross_layer: 5 file: parser.c
* ( ctxt -> space ) = 1; location: 9304 cross_layer: 5 file: parser.c
xmlWarningMsg ( ctxt , XML_WAR_SPACE_VALUE , "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n" , internal_val , NULL ); location: 9306 cross_layer: 5 file: parser.c
if ( internal_val )  location: 9311 cross_layer: 5 file: parser.c
xmlFree ( internal_val ); location: 9312 cross_layer: 5 file: parser.c
* value = val; location: 9316 cross_layer: 5 file: parser.c
return ( name ) ; location: 9317 cross_layer: 5 file: parser.c
if ( ( attname != NULL ) && ( attvalue != NULL ) )  location: 9423 cross_layer: 4 file: parser.c
if ( ( attname == ctxt -> str_xmlns ) && ( aprefix == NULL ) )  location: 9425 cross_layer: 4 file: parser.c
if ( attname != ctxt -> str_xml )  location: 9450 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , NULL , attname ); location: 9473 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( attname == ctxt -> str_xml )  location: 9492 cross_layer: 4 file: parser.c
if ( attname != ctxt -> str_xml )  location: 9504 cross_layer: 4 file: parser.c
if ( attname == ctxt -> str_xmlns )  location: 9511 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_XML_NAMESPACE , "xmlns:%s: Empty XML namespace is not allowed\n" , attname , NULL , NULL ); location: 9526 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
xmlNsErr ( ctxt , XML_WAR_NS_URI , "xmlns:%s: '%s' is not a valid URI\n" , attname , URL , NULL ); location: 9533 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
xmlNsWarn ( ctxt , XML_WAR_NS_URI_RELATIVE , "xmlns:%s: URI %s is not absolute\n" , attname , URL , NULL ); location: 9538 cross_layer: 4 file: parser.c
static void
xmlNsWarn(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 813 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 815 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_WARNING , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 818 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ ctxt -> nsNr - 2 * j ] == attname )  location: 9550 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , aprefix , attname ); location: 9553 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( nsPush ( ctxt , attname , URL ) > 0 )  location: 9555 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
for (i = ctxt->nsNr - 2;i >= 0;i -= 2) location: 1589 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = attname; location: 9584 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = aprefix; location: 9585 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = NULL; location: 9586 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = attvalue; location: 9587 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = attvalue; location: 9589 cross_layer: 4 file: parser.c
if ( ( cons == ctxt -> input -> consumed ) && ( q == CUR_PTR ) && ( attname == NULL ) && ( attvalue == NULL ) )  location: 9614 cross_layer: 4 file: parser.c
defaults = xmlHashLookup2 ( ctxt -> attsDefault , localname , prefix ); location: 9631 cross_layer: 4 file: parser.c
if ( defaults != NULL )  location: 9632 cross_layer: 4 file: parser.c
for (i = 0;i < defaults->nbAttrs;i++) location: 9633 cross_layer: 4 file: parser.c
attname = defaults -> values [ 5 * i ]; location: 9634 cross_layer: 4 file: parser.c
aprefix = defaults -> values [ 5 * i + 1 ]; location: 9635 cross_layer: 4 file: parser.c
if ( ( attname == ctxt -> str_xmlns ) && ( aprefix == NULL ) )  location: 9640 cross_layer: 4 file: parser.c
if ( nsname != defaults -> values [ 5 * i + 2 ] )  location: 9650 cross_layer: 4 file: parser.c
if ( nsPush ( ctxt , NULL , defaults -> values [ 5 * i + 2 ] ) > 0 )  location: 9651 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
if ( aprefix == ctxt -> str_xmlns )  location: 9655 cross_layer: 4 file: parser.c
if ( ctxt -> nsTab [ ctxt -> nsNr - 2 * j ] == attname )  location: 9660 cross_layer: 4 file: parser.c
nsname = xmlGetNamespace ( ctxt , attname ); location: 9664 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
for (i = ctxt->nsNr - 2;i >= 0;i-=2) location: 8839 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
if ( nsname != defaults -> values [ 2 ] )  location: 9665 cross_layer: 4 file: parser.c
if ( nsPush ( ctxt , attname , defaults -> values [ 5 * i + 2 ] ) > 0 )  location: 9666 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
for (j = 0;j < nbatts;j+=5) location: 9674 cross_layer: 4 file: parser.c
if ( ( attname == atts [ j ] ) && ( aprefix == atts [ j + 1 ] ) )  location: 9675 cross_layer: 4 file: parser.c
if ( j < nbatts )  location: 9678 cross_layer: 4 file: parser.c
if ( ( atts == NULL ) || ( nbatts + 5 > maxatts ) )  location: 9680 cross_layer: 4 file: parser.c
if ( xmlCtxtGrowAttrs ( ctxt , nbatts + 5 ) < 0 )  location: 9681 cross_layer: 4 file: parser.c
static int
xmlCtxtGrowAttrs(xmlParserCtxtPtr ctxt, int nr) location: 1656 cross_layer: 5 file: parser.c
if ( ctxt -> atts == NULL )  location: 1661 cross_layer: 5 file: parser.c
ctxt -> atts = atts; location: 1666 cross_layer: 5 file: parser.c
ctxt -> attallocs = attallocs; location: 1669 cross_layer: 5 file: parser.c
ctxt -> maxatts = maxatts; location: 1670 cross_layer: 5 file: parser.c
if ( nr + 5 > ctxt -> maxatts )  location: 1671 cross_layer: 5 file: parser.c
maxatts = ( nr + 5 ) * 2; location: 1672 cross_layer: 5 file: parser.c
atts = ( const xmlChar * * ) xmlRealloc ( ( void * ) ctxt -> atts , maxatts * sizeof ( const xmlChar * ) ); location: 1673 cross_layer: 5 file: parser.c
if ( atts == NULL )  location: 1675 cross_layer: 5 file: parser.c
ctxt -> atts = atts; location: 1676 cross_layer: 5 file: parser.c
attallocs = ( int * ) xmlRealloc ( ( void * ) ctxt -> attallocs , ( maxatts / 5 ) * sizeof ( int ) ); location: 1677 cross_layer: 5 file: parser.c
if ( attallocs == NULL )  location: 1679 cross_layer: 5 file: parser.c
ctxt -> attallocs = attallocs; location: 1680 cross_layer: 5 file: parser.c
ctxt -> maxatts = maxatts; location: 1681 cross_layer: 5 file: parser.c
return ( ctxt -> maxatts ) ; location: 1683 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1685 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = attname; location: 9687 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = aprefix; location: 9688 cross_layer: 4 file: parser.c
if ( aprefix == NULL )  location: 9689 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = NULL; location: 9690 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = xmlGetNamespace ( ctxt , aprefix ); location: 9692 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = defaults -> values [ 5 * i + 2 ]; location: 9693 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = defaults -> values [ 5 * i + 3 ]; location: 9694 cross_layer: 4 file: parser.c
if ( ( ctxt -> standalone == 1 ) && ( defaults -> values [ 5 * i + 4 ] != NULL ) )  location: 9695 cross_layer: 4 file: parser.c
xmlValidityError ( ctxt , XML_DTD_STANDALONE_DEFAULTED , "standalone: attribute %s on %s defaulted from external subset\n" , attname , localname ); location: 9697 cross_layer: 4 file: parser.c
static void
xmlValidityError(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg, const xmlChar *str1, const xmlChar *str2) location: 628 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 632 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 635 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 636 cross_layer: 5 file: parser.c
if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> initialized == XML_SAX2_MAGIC ) )  location: 637 cross_layer: 5 file: parser.c
schannel = ctxt -> sax -> serror; location: 638 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 640 cross_layer: 5 file: parser.c
__xmlRaiseError ( schannel , ctxt -> vctxt . error , ctxt -> vctxt . userData , ctxt , NULL , XML_FROM_DTD , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) str1 , ( const char * ) str2 , NULL , 0 , 0 , msg , ( const char * ) str1 , ( const char * ) str2 ); location: 641 cross_layer: 5 file: parser.c
ctxt -> valid = 0; location: 647 cross_layer: 5 file: parser.c
__xmlRaiseError ( schannel , NULL , NULL , ctxt , NULL , XML_FROM_DTD , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) str1 , ( const char * ) str2 , NULL , 0 , 0 , msg , ( const char * ) str1 , ( const char * ) str2 ); location: 649 cross_layer: 5 file: parser.c
for (i = 0; i < nbatts;i += 5) location: 9710 cross_layer: 4 file: parser.c
if ( atts [ i + 1 ] != NULL )  location: 9714 cross_layer: 4 file: parser.c
nsname = xmlGetNamespace ( ctxt , atts [ i + 1 ] ); location: 9715 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
if ( nsname == NULL )  location: 9716 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_UNDEFINED_NAMESPACE , "Namespace prefix %s for %s on %s is not defined\n" , atts [ i + 1 ] , atts [ i ] , localname ); location: 9717 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
atts [ i + 2 ] = nsname; location: 9721 cross_layer: 4 file: parser.c
for (j = 0; j < i;j += 5) location: 9730 cross_layer: 4 file: parser.c
if ( atts [ i ] == atts [ j ] )  location: 9731 cross_layer: 4 file: parser.c
if ( atts [ i + 1 ] == atts [ j + 1 ] )  location: 9732 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , atts [ i + 1 ] , atts [ i ] ); location: 9733 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( ( nsname != NULL ) && ( atts [ j + 2 ] == nsname ) )  location: 9736 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_ATTRIBUTE_REDEFINED , "Namespaced Attribute %s in '%s' redefined\n" , atts [ i ] , nsname , NULL ); location: 9737 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
if ( ( prefix != NULL ) && ( nsname == NULL ) )  location: 9747 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_UNDEFINED_NAMESPACE , "Namespace prefix %s on %s is not defined\n" , prefix , localname , NULL ); location: 9748 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
* URI = nsname; location: 9753 cross_layer: 4 file: parser.c
ctxt -> sax -> startElementNs ( ctxt -> userData , localname , prefix , nsname , nbNs , & ctxt -> nsTab [ ctxt -> nsNr - 2 * nbNs ] , nbatts / 5 , nbdef , atts ); location: 9761 cross_layer: 4 file: parser.c
ctxt -> sax -> startElementNs ( ctxt -> userData , localname , prefix , nsname , 0 , NULL , nbatts / 5 , nbdef , atts ); location: 9765 cross_layer: 4 file: parser.c
for (i = 3,j = 0; j < nratts;i += 5,j++) location: 9773 cross_layer: 4 file: parser.c
if ( ( ctxt -> attallocs [ j ] != 0 ) && ( atts [ i ] != NULL ) )  location: 9774 cross_layer: 4 file: parser.c
xmlFree ( ( xmlChar * ) atts [ i ] ); location: 9775 cross_layer: 4 file: parser.c
return ( localname ) ; location: 9778 cross_layer: 4 file: parser.c
if ( ( ctxt -> attallocs [ j ] != 0 ) && ( atts [ i ] != NULL ) )  location: 9786 cross_layer: 4 file: parser.c
xmlFree ( ( xmlChar * ) atts [ i ] ); location: 9787 cross_layer: 4 file: parser.c
------------------------------
3 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3475 @@ ['*end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8884 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
name = xmlParseQName ( ctxt , prefix ); location: 9229 cross_layer: 4 file: parser.c
if ( name == NULL )  location: 9230 cross_layer: 4 file: parser.c
type = ( int ) ( long ) xmlHashQLookup2 ( ctxt -> attsSpecial , pref , elem , * prefix , name ); location: 9242 cross_layer: 4 file: parser.c
if ( type != 0 )  location: 9244 cross_layer: 4 file: parser.c
xmlFatalErrMsgStr ( ctxt , XML_ERR_ATTRIBUTE_WITHOUT_VALUE , "Specification mandate value for attribute %s\n" , name ); location: 9275 cross_layer: 4 file: parser.c
static void
xmlFatalErrMsgStr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg, const xmlChar * val) location: 728 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 730 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 733 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 734 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , error , XML_ERR_FATAL , NULL , 0 , ( const char * ) val , NULL , NULL , 0 , 0 , msg , val ); location: 735 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 739 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 740 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 741 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 742 cross_layer: 5 file: parser.c
if ( ( ctxt -> pedantic ) && ( xmlStrEqual ( name , BAD_CAST "lang" ) ) ) location: 9287 cross_layer: 4 file: parser.c
int
xmlStrEqual(const xmlChar *str1, const xmlChar *str2) location: 157 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == str2 )  location: 158 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == NULL )  location: 159 cross_layer: 5 file: testCode/xmlstring.c
if ( str2 == NULL )  location: 160 cross_layer: 5 file: testCode/xmlstring.c
if ( * str1 ++ != * str2 )  location: 162 cross_layer: 5 file: testCode/xmlstring.c
while ( * str2 ++ )  location: 163 cross_layer: 5 file: testCode/xmlstring.c
if ( xmlStrEqual ( name , BAD_CAST "space" ) ) location: 9299 cross_layer: 4 file: parser.c
int
xmlStrEqual(const xmlChar *str1, const xmlChar *str2) location: 157 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == str2 )  location: 158 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == NULL )  location: 159 cross_layer: 5 file: testCode/xmlstring.c
if ( str2 == NULL )  location: 160 cross_layer: 5 file: testCode/xmlstring.c
if ( * str1 ++ != * str2 )  location: 162 cross_layer: 5 file: testCode/xmlstring.c
while ( * str2 ++ )  location: 163 cross_layer: 5 file: testCode/xmlstring.c
return ( name ) ; location: 9317 cross_layer: 4 file: parser.c
------------------------------
4 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3475 @@ ['*end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8868 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8869 cross_layer: 3 file: parser.c
if ( l != NULL )  location: 8872 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s'\n" , l , NULL , NULL ); location: 8873 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
return ( l ) ; location: 8876 cross_layer: 3 file: parser.c
p = l; location: 8883 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:'\n" , p , NULL , NULL ); location: 8888 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , p , NULL , 0 ) location: 8892 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , l , NULL , 0 ) location: 8916 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8917 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8918 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8918 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
return ( l ) ; location: 8920 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
ret = xmlParseQName ( ctxt , & prefix2 ); location: 8975 cross_layer: 4 file: parser.c
if ( ( ret == name ) && ( prefix == prefix2 ) )  location: 8976 cross_layer: 4 file: parser.c
return ret ; location: 8978 cross_layer: 4 file: parser.c
------------------------------
5 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3475 @@ ['*end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8868 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8869 cross_layer: 3 file: parser.c
if ( l != NULL )  location: 8872 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s'\n" , l , NULL , NULL ); location: 8873 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
return ( l ) ; location: 8876 cross_layer: 3 file: parser.c
p = l; location: 8883 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:'\n" , p , NULL , NULL ); location: 8888 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , p , NULL , 0 ) location: 8892 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , l , NULL , 0 ) location: 8916 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8917 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8918 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8918 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
return ( l ) ; location: 8920 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
localname = xmlParseQName ( ctxt , & prefix ); location: 9390 cross_layer: 4 file: parser.c
if ( localname == NULL )  location: 9391 cross_layer: 4 file: parser.c
attname = xmlParseAttribute2 ( ctxt , prefix , localname , & aprefix , & attvalue , & len , & alloc ); location: 9415 cross_layer: 4 file: parser.c
static const xmlChar *
xmlParseAttribute2(xmlParserCtxtPtr ctxt,
const xmlChar * pref, const xmlChar * elem,
const xmlChar ** prefix, xmlChar ** value,
int *len, int *alloc) location: 9221 cross_layer: 5 file: parser.c
* value = NULL; location: 9227 cross_layer: 5 file: parser.c
name = xmlParseQName ( ctxt , prefix ); location: 9229 cross_layer: 5 file: parser.c
if ( name == NULL )  location: 9230 cross_layer: 5 file: parser.c
xmlFatalErrMsg ( ctxt , XML_ERR_NAME_REQUIRED , "error parsing attribute name\n" ); location: 9231 cross_layer: 5 file: parser.c
if ( ctxt -> attsSpecial != NULL )  location: 9239 cross_layer: 5 file: parser.c
type = ( int ) ( long ) xmlHashQLookup2 ( ctxt -> attsSpecial , pref , elem , * prefix , name ); location: 9242 cross_layer: 5 file: parser.c
if ( type != 0 )  location: 9244 cross_layer: 5 file: parser.c
val = xmlParseAttValueInternal ( ctxt , len , alloc , normalize ); location: 9255 cross_layer: 5 file: parser.c
if ( * alloc )  location: 9263 cross_layer: 5 file: parser.c
val2 = xmlAttrNormalizeSpace2 ( ctxt , val , len ); location: 9266 cross_layer: 5 file: parser.c
if ( ( val2 != NULL ) && ( val2 != val ) )  location: 9267 cross_layer: 5 file: parser.c
xmlFree ( val ); location: 9268 cross_layer: 5 file: parser.c
val = ( xmlChar * ) val2; location: 9269 cross_layer: 5 file: parser.c
ctxt -> instate = XML_PARSER_CONTENT; location: 9273 cross_layer: 5 file: parser.c
xmlFatalErrMsgStr ( ctxt , XML_ERR_ATTRIBUTE_WITHOUT_VALUE , "Specification mandate value for attribute %s\n" , name ); location: 9275 cross_layer: 5 file: parser.c
if ( * prefix == ctxt -> str_xml )  location: 9281 cross_layer: 5 file: parser.c
if ( ( ctxt -> pedantic ) && ( xmlStrEqual ( name , BAD_CAST "lang" ) ) ) location: 9287 cross_layer: 5 file: parser.c
internal_val = xmlStrndup ( val , * len ); location: 9288 cross_layer: 5 file: parser.c
if ( ! xmlCheckLanguageID ( internal_val ) )  location: 9289 cross_layer: 5 file: parser.c
xmlWarningMsg ( ctxt , XML_WAR_LANG_VALUE , "Malformed value for xml:lang : %s\n" , internal_val , NULL ); location: 9290 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( name , BAD_CAST "space" ) ) location: 9299 cross_layer: 5 file: parser.c
internal_val = xmlStrndup ( val , * len ); location: 9300 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( internal_val , BAD_CAST "default" ) ) location: 9301 cross_layer: 5 file: parser.c
* ( ctxt -> space ) = 0; location: 9302 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( internal_val , BAD_CAST "preserve" ) ) location: 9303 cross_layer: 5 file: parser.c
* ( ctxt -> space ) = 1; location: 9304 cross_layer: 5 file: parser.c
xmlWarningMsg ( ctxt , XML_WAR_SPACE_VALUE , "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n" , internal_val , NULL ); location: 9306 cross_layer: 5 file: parser.c
if ( internal_val )  location: 9311 cross_layer: 5 file: parser.c
xmlFree ( internal_val ); location: 9312 cross_layer: 5 file: parser.c
* value = val; location: 9316 cross_layer: 5 file: parser.c
return ( name ) ; location: 9317 cross_layer: 5 file: parser.c
if ( ( attname != NULL ) && ( attvalue != NULL ) )  location: 9423 cross_layer: 4 file: parser.c
if ( ( attname == ctxt -> str_xmlns ) && ( aprefix == NULL ) )  location: 9425 cross_layer: 4 file: parser.c
if ( attname != ctxt -> str_xml )  location: 9450 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , NULL , attname ); location: 9473 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( attname == ctxt -> str_xml )  location: 9492 cross_layer: 4 file: parser.c
if ( attname != ctxt -> str_xml )  location: 9504 cross_layer: 4 file: parser.c
if ( attname == ctxt -> str_xmlns )  location: 9511 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_XML_NAMESPACE , "xmlns:%s: Empty XML namespace is not allowed\n" , attname , NULL , NULL ); location: 9526 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
xmlNsErr ( ctxt , XML_WAR_NS_URI , "xmlns:%s: '%s' is not a valid URI\n" , attname , URL , NULL ); location: 9533 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
xmlNsWarn ( ctxt , XML_WAR_NS_URI_RELATIVE , "xmlns:%s: URI %s is not absolute\n" , attname , URL , NULL ); location: 9538 cross_layer: 4 file: parser.c
static void
xmlNsWarn(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 813 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 815 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_WARNING , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 818 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ ctxt -> nsNr - 2 * j ] == attname )  location: 9550 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , aprefix , attname ); location: 9553 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( nsPush ( ctxt , attname , URL ) > 0 )  location: 9555 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
for (i = ctxt->nsNr - 2;i >= 0;i -= 2) location: 1589 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = attname; location: 9584 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = aprefix; location: 9585 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = NULL; location: 9586 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = attvalue; location: 9587 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = attvalue; location: 9589 cross_layer: 4 file: parser.c
if ( ( cons == ctxt -> input -> consumed ) && ( q == CUR_PTR ) && ( attname == NULL ) && ( attvalue == NULL ) )  location: 9614 cross_layer: 4 file: parser.c
defaults = xmlHashLookup2 ( ctxt -> attsDefault , localname , prefix ); location: 9631 cross_layer: 4 file: parser.c
if ( defaults != NULL )  location: 9632 cross_layer: 4 file: parser.c
for (i = 0;i < defaults->nbAttrs;i++) location: 9633 cross_layer: 4 file: parser.c
attname = defaults -> values [ 5 * i ]; location: 9634 cross_layer: 4 file: parser.c
aprefix = defaults -> values [ 5 * i + 1 ]; location: 9635 cross_layer: 4 file: parser.c
if ( ( attname == ctxt -> str_xmlns ) && ( aprefix == NULL ) )  location: 9640 cross_layer: 4 file: parser.c
if ( nsname != defaults -> values [ 5 * i + 2 ] )  location: 9650 cross_layer: 4 file: parser.c
if ( nsPush ( ctxt , NULL , defaults -> values [ 5 * i + 2 ] ) > 0 )  location: 9651 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
if ( aprefix == ctxt -> str_xmlns )  location: 9655 cross_layer: 4 file: parser.c
if ( ctxt -> nsTab [ ctxt -> nsNr - 2 * j ] == attname )  location: 9660 cross_layer: 4 file: parser.c
nsname = xmlGetNamespace ( ctxt , attname ); location: 9664 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
for (i = ctxt->nsNr - 2;i >= 0;i-=2) location: 8839 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
if ( nsname != defaults -> values [ 2 ] )  location: 9665 cross_layer: 4 file: parser.c
if ( nsPush ( ctxt , attname , defaults -> values [ 5 * i + 2 ] ) > 0 )  location: 9666 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
for (j = 0;j < nbatts;j+=5) location: 9674 cross_layer: 4 file: parser.c
if ( ( attname == atts [ j ] ) && ( aprefix == atts [ j + 1 ] ) )  location: 9675 cross_layer: 4 file: parser.c
if ( j < nbatts )  location: 9678 cross_layer: 4 file: parser.c
if ( ( atts == NULL ) || ( nbatts + 5 > maxatts ) )  location: 9680 cross_layer: 4 file: parser.c
if ( xmlCtxtGrowAttrs ( ctxt , nbatts + 5 ) < 0 )  location: 9681 cross_layer: 4 file: parser.c
static int
xmlCtxtGrowAttrs(xmlParserCtxtPtr ctxt, int nr) location: 1656 cross_layer: 5 file: parser.c
if ( ctxt -> atts == NULL )  location: 1661 cross_layer: 5 file: parser.c
ctxt -> atts = atts; location: 1666 cross_layer: 5 file: parser.c
ctxt -> attallocs = attallocs; location: 1669 cross_layer: 5 file: parser.c
ctxt -> maxatts = maxatts; location: 1670 cross_layer: 5 file: parser.c
if ( nr + 5 > ctxt -> maxatts )  location: 1671 cross_layer: 5 file: parser.c
maxatts = ( nr + 5 ) * 2; location: 1672 cross_layer: 5 file: parser.c
atts = ( const xmlChar * * ) xmlRealloc ( ( void * ) ctxt -> atts , maxatts * sizeof ( const xmlChar * ) ); location: 1673 cross_layer: 5 file: parser.c
if ( atts == NULL )  location: 1675 cross_layer: 5 file: parser.c
ctxt -> atts = atts; location: 1676 cross_layer: 5 file: parser.c
attallocs = ( int * ) xmlRealloc ( ( void * ) ctxt -> attallocs , ( maxatts / 5 ) * sizeof ( int ) ); location: 1677 cross_layer: 5 file: parser.c
if ( attallocs == NULL )  location: 1679 cross_layer: 5 file: parser.c
ctxt -> attallocs = attallocs; location: 1680 cross_layer: 5 file: parser.c
ctxt -> maxatts = maxatts; location: 1681 cross_layer: 5 file: parser.c
return ( ctxt -> maxatts ) ; location: 1683 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1685 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = attname; location: 9687 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = aprefix; location: 9688 cross_layer: 4 file: parser.c
if ( aprefix == NULL )  location: 9689 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = NULL; location: 9690 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = xmlGetNamespace ( ctxt , aprefix ); location: 9692 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = defaults -> values [ 5 * i + 2 ]; location: 9693 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = defaults -> values [ 5 * i + 3 ]; location: 9694 cross_layer: 4 file: parser.c
if ( ( ctxt -> standalone == 1 ) && ( defaults -> values [ 5 * i + 4 ] != NULL ) )  location: 9695 cross_layer: 4 file: parser.c
xmlValidityError ( ctxt , XML_DTD_STANDALONE_DEFAULTED , "standalone: attribute %s on %s defaulted from external subset\n" , attname , localname ); location: 9697 cross_layer: 4 file: parser.c
static void
xmlValidityError(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg, const xmlChar *str1, const xmlChar *str2) location: 628 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 632 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 635 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 636 cross_layer: 5 file: parser.c
if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> initialized == XML_SAX2_MAGIC ) )  location: 637 cross_layer: 5 file: parser.c
schannel = ctxt -> sax -> serror; location: 638 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 640 cross_layer: 5 file: parser.c
__xmlRaiseError ( schannel , ctxt -> vctxt . error , ctxt -> vctxt . userData , ctxt , NULL , XML_FROM_DTD , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) str1 , ( const char * ) str2 , NULL , 0 , 0 , msg , ( const char * ) str1 , ( const char * ) str2 ); location: 641 cross_layer: 5 file: parser.c
ctxt -> valid = 0; location: 647 cross_layer: 5 file: parser.c
__xmlRaiseError ( schannel , NULL , NULL , ctxt , NULL , XML_FROM_DTD , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) str1 , ( const char * ) str2 , NULL , 0 , 0 , msg , ( const char * ) str1 , ( const char * ) str2 ); location: 649 cross_layer: 5 file: parser.c
for (i = 0; i < nbatts;i += 5) location: 9710 cross_layer: 4 file: parser.c
if ( atts [ i + 1 ] != NULL )  location: 9714 cross_layer: 4 file: parser.c
nsname = xmlGetNamespace ( ctxt , atts [ i + 1 ] ); location: 9715 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
if ( nsname == NULL )  location: 9716 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_UNDEFINED_NAMESPACE , "Namespace prefix %s for %s on %s is not defined\n" , atts [ i + 1 ] , atts [ i ] , localname ); location: 9717 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
atts [ i + 2 ] = nsname; location: 9721 cross_layer: 4 file: parser.c
for (j = 0; j < i;j += 5) location: 9730 cross_layer: 4 file: parser.c
if ( atts [ i ] == atts [ j ] )  location: 9731 cross_layer: 4 file: parser.c
if ( atts [ i + 1 ] == atts [ j + 1 ] )  location: 9732 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , atts [ i + 1 ] , atts [ i ] ); location: 9733 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( ( nsname != NULL ) && ( atts [ j + 2 ] == nsname ) )  location: 9736 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_ATTRIBUTE_REDEFINED , "Namespaced Attribute %s in '%s' redefined\n" , atts [ i ] , nsname , NULL ); location: 9737 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
if ( ( prefix != NULL ) && ( nsname == NULL ) )  location: 9747 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_UNDEFINED_NAMESPACE , "Namespace prefix %s on %s is not defined\n" , prefix , localname , NULL ); location: 9748 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
* URI = nsname; location: 9753 cross_layer: 4 file: parser.c
ctxt -> sax -> startElementNs ( ctxt -> userData , localname , prefix , nsname , nbNs , & ctxt -> nsTab [ ctxt -> nsNr - 2 * nbNs ] , nbatts / 5 , nbdef , atts ); location: 9761 cross_layer: 4 file: parser.c
ctxt -> sax -> startElementNs ( ctxt -> userData , localname , prefix , nsname , 0 , NULL , nbatts / 5 , nbdef , atts ); location: 9765 cross_layer: 4 file: parser.c
for (i = 3,j = 0; j < nratts;i += 5,j++) location: 9773 cross_layer: 4 file: parser.c
if ( ( ctxt -> attallocs [ j ] != 0 ) && ( atts [ i ] != NULL ) )  location: 9774 cross_layer: 4 file: parser.c
xmlFree ( ( xmlChar * ) atts [ i ] ); location: 9775 cross_layer: 4 file: parser.c
return ( localname ) ; location: 9778 cross_layer: 4 file: parser.c
if ( ( ctxt -> attallocs [ j ] != 0 ) && ( atts [ i ] != NULL ) )  location: 9786 cross_layer: 4 file: parser.c
xmlFree ( ( xmlChar * ) atts [ i ] ); location: 9787 cross_layer: 4 file: parser.c
------------------------------
6 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3475 @@ ['*end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8868 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8869 cross_layer: 3 file: parser.c
if ( l != NULL )  location: 8872 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s'\n" , l , NULL , NULL ); location: 8873 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
return ( l ) ; location: 8876 cross_layer: 3 file: parser.c
p = l; location: 8883 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:'\n" , p , NULL , NULL ); location: 8888 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , p , NULL , 0 ) location: 8892 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , l , NULL , 0 ) location: 8916 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8917 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8918 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8918 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
return ( l ) ; location: 8920 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
name = xmlParseQName ( ctxt , prefix ); location: 9229 cross_layer: 4 file: parser.c
if ( name == NULL )  location: 9230 cross_layer: 4 file: parser.c
type = ( int ) ( long ) xmlHashQLookup2 ( ctxt -> attsSpecial , pref , elem , * prefix , name ); location: 9242 cross_layer: 4 file: parser.c
if ( type != 0 )  location: 9244 cross_layer: 4 file: parser.c
xmlFatalErrMsgStr ( ctxt , XML_ERR_ATTRIBUTE_WITHOUT_VALUE , "Specification mandate value for attribute %s\n" , name ); location: 9275 cross_layer: 4 file: parser.c
static void
xmlFatalErrMsgStr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg, const xmlChar * val) location: 728 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 730 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 733 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 734 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , error , XML_ERR_FATAL , NULL , 0 , ( const char * ) val , NULL , NULL , 0 , 0 , msg , val ); location: 735 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 739 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 740 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 741 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 742 cross_layer: 5 file: parser.c
if ( ( ctxt -> pedantic ) && ( xmlStrEqual ( name , BAD_CAST "lang" ) ) ) location: 9287 cross_layer: 4 file: parser.c
int
xmlStrEqual(const xmlChar *str1, const xmlChar *str2) location: 157 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == str2 )  location: 158 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == NULL )  location: 159 cross_layer: 5 file: testCode/xmlstring.c
if ( str2 == NULL )  location: 160 cross_layer: 5 file: testCode/xmlstring.c
if ( * str1 ++ != * str2 )  location: 162 cross_layer: 5 file: testCode/xmlstring.c
while ( * str2 ++ )  location: 163 cross_layer: 5 file: testCode/xmlstring.c
if ( xmlStrEqual ( name , BAD_CAST "space" ) ) location: 9299 cross_layer: 4 file: parser.c
int
xmlStrEqual(const xmlChar *str1, const xmlChar *str2) location: 157 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == str2 )  location: 158 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == NULL )  location: 159 cross_layer: 5 file: testCode/xmlstring.c
if ( str2 == NULL )  location: 160 cross_layer: 5 file: testCode/xmlstring.c
if ( * str1 ++ != * str2 )  location: 162 cross_layer: 5 file: testCode/xmlstring.c
while ( * str2 ++ )  location: 163 cross_layer: 5 file: testCode/xmlstring.c
return ( name ) ; location: 9317 cross_layer: 4 file: parser.c
------------------------------
7 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3485 @@ ['end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8884 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
ret = xmlParseQName ( ctxt , & prefix2 ); location: 8975 cross_layer: 4 file: parser.c
if ( ( ret == name ) && ( prefix == prefix2 ) )  location: 8976 cross_layer: 4 file: parser.c
return ret ; location: 8978 cross_layer: 4 file: parser.c
------------------------------
8 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3485 @@ ['end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8884 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
localname = xmlParseQName ( ctxt , & prefix ); location: 9390 cross_layer: 4 file: parser.c
if ( localname == NULL )  location: 9391 cross_layer: 4 file: parser.c
attname = xmlParseAttribute2 ( ctxt , prefix , localname , & aprefix , & attvalue , & len , & alloc ); location: 9415 cross_layer: 4 file: parser.c
static const xmlChar *
xmlParseAttribute2(xmlParserCtxtPtr ctxt,
const xmlChar * pref, const xmlChar * elem,
const xmlChar ** prefix, xmlChar ** value,
int *len, int *alloc) location: 9221 cross_layer: 5 file: parser.c
* value = NULL; location: 9227 cross_layer: 5 file: parser.c
name = xmlParseQName ( ctxt , prefix ); location: 9229 cross_layer: 5 file: parser.c
if ( name == NULL )  location: 9230 cross_layer: 5 file: parser.c
xmlFatalErrMsg ( ctxt , XML_ERR_NAME_REQUIRED , "error parsing attribute name\n" ); location: 9231 cross_layer: 5 file: parser.c
if ( ctxt -> attsSpecial != NULL )  location: 9239 cross_layer: 5 file: parser.c
type = ( int ) ( long ) xmlHashQLookup2 ( ctxt -> attsSpecial , pref , elem , * prefix , name ); location: 9242 cross_layer: 5 file: parser.c
if ( type != 0 )  location: 9244 cross_layer: 5 file: parser.c
val = xmlParseAttValueInternal ( ctxt , len , alloc , normalize ); location: 9255 cross_layer: 5 file: parser.c
if ( * alloc )  location: 9263 cross_layer: 5 file: parser.c
val2 = xmlAttrNormalizeSpace2 ( ctxt , val , len ); location: 9266 cross_layer: 5 file: parser.c
if ( ( val2 != NULL ) && ( val2 != val ) )  location: 9267 cross_layer: 5 file: parser.c
xmlFree ( val ); location: 9268 cross_layer: 5 file: parser.c
val = ( xmlChar * ) val2; location: 9269 cross_layer: 5 file: parser.c
ctxt -> instate = XML_PARSER_CONTENT; location: 9273 cross_layer: 5 file: parser.c
xmlFatalErrMsgStr ( ctxt , XML_ERR_ATTRIBUTE_WITHOUT_VALUE , "Specification mandate value for attribute %s\n" , name ); location: 9275 cross_layer: 5 file: parser.c
if ( * prefix == ctxt -> str_xml )  location: 9281 cross_layer: 5 file: parser.c
if ( ( ctxt -> pedantic ) && ( xmlStrEqual ( name , BAD_CAST "lang" ) ) ) location: 9287 cross_layer: 5 file: parser.c
internal_val = xmlStrndup ( val , * len ); location: 9288 cross_layer: 5 file: parser.c
if ( ! xmlCheckLanguageID ( internal_val ) )  location: 9289 cross_layer: 5 file: parser.c
xmlWarningMsg ( ctxt , XML_WAR_LANG_VALUE , "Malformed value for xml:lang : %s\n" , internal_val , NULL ); location: 9290 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( name , BAD_CAST "space" ) ) location: 9299 cross_layer: 5 file: parser.c
internal_val = xmlStrndup ( val , * len ); location: 9300 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( internal_val , BAD_CAST "default" ) ) location: 9301 cross_layer: 5 file: parser.c
* ( ctxt -> space ) = 0; location: 9302 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( internal_val , BAD_CAST "preserve" ) ) location: 9303 cross_layer: 5 file: parser.c
* ( ctxt -> space ) = 1; location: 9304 cross_layer: 5 file: parser.c
xmlWarningMsg ( ctxt , XML_WAR_SPACE_VALUE , "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n" , internal_val , NULL ); location: 9306 cross_layer: 5 file: parser.c
if ( internal_val )  location: 9311 cross_layer: 5 file: parser.c
xmlFree ( internal_val ); location: 9312 cross_layer: 5 file: parser.c
* value = val; location: 9316 cross_layer: 5 file: parser.c
return ( name ) ; location: 9317 cross_layer: 5 file: parser.c
if ( ( attname != NULL ) && ( attvalue != NULL ) )  location: 9423 cross_layer: 4 file: parser.c
if ( ( attname == ctxt -> str_xmlns ) && ( aprefix == NULL ) )  location: 9425 cross_layer: 4 file: parser.c
if ( attname != ctxt -> str_xml )  location: 9450 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , NULL , attname ); location: 9473 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( attname == ctxt -> str_xml )  location: 9492 cross_layer: 4 file: parser.c
if ( attname != ctxt -> str_xml )  location: 9504 cross_layer: 4 file: parser.c
if ( attname == ctxt -> str_xmlns )  location: 9511 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_XML_NAMESPACE , "xmlns:%s: Empty XML namespace is not allowed\n" , attname , NULL , NULL ); location: 9526 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
xmlNsErr ( ctxt , XML_WAR_NS_URI , "xmlns:%s: '%s' is not a valid URI\n" , attname , URL , NULL ); location: 9533 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
xmlNsWarn ( ctxt , XML_WAR_NS_URI_RELATIVE , "xmlns:%s: URI %s is not absolute\n" , attname , URL , NULL ); location: 9538 cross_layer: 4 file: parser.c
static void
xmlNsWarn(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 813 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 815 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_WARNING , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 818 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ ctxt -> nsNr - 2 * j ] == attname )  location: 9550 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , aprefix , attname ); location: 9553 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( nsPush ( ctxt , attname , URL ) > 0 )  location: 9555 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
for (i = ctxt->nsNr - 2;i >= 0;i -= 2) location: 1589 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = attname; location: 9584 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = aprefix; location: 9585 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = NULL; location: 9586 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = attvalue; location: 9587 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = attvalue; location: 9589 cross_layer: 4 file: parser.c
if ( ( cons == ctxt -> input -> consumed ) && ( q == CUR_PTR ) && ( attname == NULL ) && ( attvalue == NULL ) )  location: 9614 cross_layer: 4 file: parser.c
defaults = xmlHashLookup2 ( ctxt -> attsDefault , localname , prefix ); location: 9631 cross_layer: 4 file: parser.c
if ( defaults != NULL )  location: 9632 cross_layer: 4 file: parser.c
for (i = 0;i < defaults->nbAttrs;i++) location: 9633 cross_layer: 4 file: parser.c
attname = defaults -> values [ 5 * i ]; location: 9634 cross_layer: 4 file: parser.c
aprefix = defaults -> values [ 5 * i + 1 ]; location: 9635 cross_layer: 4 file: parser.c
if ( ( attname == ctxt -> str_xmlns ) && ( aprefix == NULL ) )  location: 9640 cross_layer: 4 file: parser.c
if ( nsname != defaults -> values [ 5 * i + 2 ] )  location: 9650 cross_layer: 4 file: parser.c
if ( nsPush ( ctxt , NULL , defaults -> values [ 5 * i + 2 ] ) > 0 )  location: 9651 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
if ( aprefix == ctxt -> str_xmlns )  location: 9655 cross_layer: 4 file: parser.c
if ( ctxt -> nsTab [ ctxt -> nsNr - 2 * j ] == attname )  location: 9660 cross_layer: 4 file: parser.c
nsname = xmlGetNamespace ( ctxt , attname ); location: 9664 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
for (i = ctxt->nsNr - 2;i >= 0;i-=2) location: 8839 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
if ( nsname != defaults -> values [ 2 ] )  location: 9665 cross_layer: 4 file: parser.c
if ( nsPush ( ctxt , attname , defaults -> values [ 5 * i + 2 ] ) > 0 )  location: 9666 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
for (j = 0;j < nbatts;j+=5) location: 9674 cross_layer: 4 file: parser.c
if ( ( attname == atts [ j ] ) && ( aprefix == atts [ j + 1 ] ) )  location: 9675 cross_layer: 4 file: parser.c
if ( j < nbatts )  location: 9678 cross_layer: 4 file: parser.c
if ( ( atts == NULL ) || ( nbatts + 5 > maxatts ) )  location: 9680 cross_layer: 4 file: parser.c
if ( xmlCtxtGrowAttrs ( ctxt , nbatts + 5 ) < 0 )  location: 9681 cross_layer: 4 file: parser.c
static int
xmlCtxtGrowAttrs(xmlParserCtxtPtr ctxt, int nr) location: 1656 cross_layer: 5 file: parser.c
if ( ctxt -> atts == NULL )  location: 1661 cross_layer: 5 file: parser.c
ctxt -> atts = atts; location: 1666 cross_layer: 5 file: parser.c
ctxt -> attallocs = attallocs; location: 1669 cross_layer: 5 file: parser.c
ctxt -> maxatts = maxatts; location: 1670 cross_layer: 5 file: parser.c
if ( nr + 5 > ctxt -> maxatts )  location: 1671 cross_layer: 5 file: parser.c
maxatts = ( nr + 5 ) * 2; location: 1672 cross_layer: 5 file: parser.c
atts = ( const xmlChar * * ) xmlRealloc ( ( void * ) ctxt -> atts , maxatts * sizeof ( const xmlChar * ) ); location: 1673 cross_layer: 5 file: parser.c
if ( atts == NULL )  location: 1675 cross_layer: 5 file: parser.c
ctxt -> atts = atts; location: 1676 cross_layer: 5 file: parser.c
attallocs = ( int * ) xmlRealloc ( ( void * ) ctxt -> attallocs , ( maxatts / 5 ) * sizeof ( int ) ); location: 1677 cross_layer: 5 file: parser.c
if ( attallocs == NULL )  location: 1679 cross_layer: 5 file: parser.c
ctxt -> attallocs = attallocs; location: 1680 cross_layer: 5 file: parser.c
ctxt -> maxatts = maxatts; location: 1681 cross_layer: 5 file: parser.c
return ( ctxt -> maxatts ) ; location: 1683 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1685 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = attname; location: 9687 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = aprefix; location: 9688 cross_layer: 4 file: parser.c
if ( aprefix == NULL )  location: 9689 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = NULL; location: 9690 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = xmlGetNamespace ( ctxt , aprefix ); location: 9692 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = defaults -> values [ 5 * i + 2 ]; location: 9693 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = defaults -> values [ 5 * i + 3 ]; location: 9694 cross_layer: 4 file: parser.c
if ( ( ctxt -> standalone == 1 ) && ( defaults -> values [ 5 * i + 4 ] != NULL ) )  location: 9695 cross_layer: 4 file: parser.c
xmlValidityError ( ctxt , XML_DTD_STANDALONE_DEFAULTED , "standalone: attribute %s on %s defaulted from external subset\n" , attname , localname ); location: 9697 cross_layer: 4 file: parser.c
static void
xmlValidityError(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg, const xmlChar *str1, const xmlChar *str2) location: 628 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 632 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 635 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 636 cross_layer: 5 file: parser.c
if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> initialized == XML_SAX2_MAGIC ) )  location: 637 cross_layer: 5 file: parser.c
schannel = ctxt -> sax -> serror; location: 638 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 640 cross_layer: 5 file: parser.c
__xmlRaiseError ( schannel , ctxt -> vctxt . error , ctxt -> vctxt . userData , ctxt , NULL , XML_FROM_DTD , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) str1 , ( const char * ) str2 , NULL , 0 , 0 , msg , ( const char * ) str1 , ( const char * ) str2 ); location: 641 cross_layer: 5 file: parser.c
ctxt -> valid = 0; location: 647 cross_layer: 5 file: parser.c
__xmlRaiseError ( schannel , NULL , NULL , ctxt , NULL , XML_FROM_DTD , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) str1 , ( const char * ) str2 , NULL , 0 , 0 , msg , ( const char * ) str1 , ( const char * ) str2 ); location: 649 cross_layer: 5 file: parser.c
for (i = 0; i < nbatts;i += 5) location: 9710 cross_layer: 4 file: parser.c
if ( atts [ i + 1 ] != NULL )  location: 9714 cross_layer: 4 file: parser.c
nsname = xmlGetNamespace ( ctxt , atts [ i + 1 ] ); location: 9715 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
if ( nsname == NULL )  location: 9716 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_UNDEFINED_NAMESPACE , "Namespace prefix %s for %s on %s is not defined\n" , atts [ i + 1 ] , atts [ i ] , localname ); location: 9717 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
atts [ i + 2 ] = nsname; location: 9721 cross_layer: 4 file: parser.c
for (j = 0; j < i;j += 5) location: 9730 cross_layer: 4 file: parser.c
if ( atts [ i ] == atts [ j ] )  location: 9731 cross_layer: 4 file: parser.c
if ( atts [ i + 1 ] == atts [ j + 1 ] )  location: 9732 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , atts [ i + 1 ] , atts [ i ] ); location: 9733 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( ( nsname != NULL ) && ( atts [ j + 2 ] == nsname ) )  location: 9736 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_ATTRIBUTE_REDEFINED , "Namespaced Attribute %s in '%s' redefined\n" , atts [ i ] , nsname , NULL ); location: 9737 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
if ( ( prefix != NULL ) && ( nsname == NULL ) )  location: 9747 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_UNDEFINED_NAMESPACE , "Namespace prefix %s on %s is not defined\n" , prefix , localname , NULL ); location: 9748 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
* URI = nsname; location: 9753 cross_layer: 4 file: parser.c
ctxt -> sax -> startElementNs ( ctxt -> userData , localname , prefix , nsname , nbNs , & ctxt -> nsTab [ ctxt -> nsNr - 2 * nbNs ] , nbatts / 5 , nbdef , atts ); location: 9761 cross_layer: 4 file: parser.c
ctxt -> sax -> startElementNs ( ctxt -> userData , localname , prefix , nsname , 0 , NULL , nbatts / 5 , nbdef , atts ); location: 9765 cross_layer: 4 file: parser.c
for (i = 3,j = 0; j < nratts;i += 5,j++) location: 9773 cross_layer: 4 file: parser.c
if ( ( ctxt -> attallocs [ j ] != 0 ) && ( atts [ i ] != NULL ) )  location: 9774 cross_layer: 4 file: parser.c
xmlFree ( ( xmlChar * ) atts [ i ] ); location: 9775 cross_layer: 4 file: parser.c
return ( localname ) ; location: 9778 cross_layer: 4 file: parser.c
if ( ( ctxt -> attallocs [ j ] != 0 ) && ( atts [ i ] != NULL ) )  location: 9786 cross_layer: 4 file: parser.c
xmlFree ( ( xmlChar * ) atts [ i ] ); location: 9787 cross_layer: 4 file: parser.c
------------------------------
9 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3485 @@ ['end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8884 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
name = xmlParseQName ( ctxt , prefix ); location: 9229 cross_layer: 4 file: parser.c
if ( name == NULL )  location: 9230 cross_layer: 4 file: parser.c
type = ( int ) ( long ) xmlHashQLookup2 ( ctxt -> attsSpecial , pref , elem , * prefix , name ); location: 9242 cross_layer: 4 file: parser.c
if ( type != 0 )  location: 9244 cross_layer: 4 file: parser.c
xmlFatalErrMsgStr ( ctxt , XML_ERR_ATTRIBUTE_WITHOUT_VALUE , "Specification mandate value for attribute %s\n" , name ); location: 9275 cross_layer: 4 file: parser.c
static void
xmlFatalErrMsgStr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg, const xmlChar * val) location: 728 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 730 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 733 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 734 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , error , XML_ERR_FATAL , NULL , 0 , ( const char * ) val , NULL , NULL , 0 , 0 , msg , val ); location: 735 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 739 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 740 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 741 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 742 cross_layer: 5 file: parser.c
if ( ( ctxt -> pedantic ) && ( xmlStrEqual ( name , BAD_CAST "lang" ) ) ) location: 9287 cross_layer: 4 file: parser.c
int
xmlStrEqual(const xmlChar *str1, const xmlChar *str2) location: 157 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == str2 )  location: 158 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == NULL )  location: 159 cross_layer: 5 file: testCode/xmlstring.c
if ( str2 == NULL )  location: 160 cross_layer: 5 file: testCode/xmlstring.c
if ( * str1 ++ != * str2 )  location: 162 cross_layer: 5 file: testCode/xmlstring.c
while ( * str2 ++ )  location: 163 cross_layer: 5 file: testCode/xmlstring.c
if ( xmlStrEqual ( name , BAD_CAST "space" ) ) location: 9299 cross_layer: 4 file: parser.c
int
xmlStrEqual(const xmlChar *str1, const xmlChar *str2) location: 157 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == str2 )  location: 158 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == NULL )  location: 159 cross_layer: 5 file: testCode/xmlstring.c
if ( str2 == NULL )  location: 160 cross_layer: 5 file: testCode/xmlstring.c
if ( * str1 ++ != * str2 )  location: 162 cross_layer: 5 file: testCode/xmlstring.c
while ( * str2 ++ )  location: 163 cross_layer: 5 file: testCode/xmlstring.c
return ( name ) ; location: 9317 cross_layer: 4 file: parser.c
------------------------------
10 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3485 @@ ['end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8868 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8869 cross_layer: 3 file: parser.c
if ( l != NULL )  location: 8872 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s'\n" , l , NULL , NULL ); location: 8873 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
return ( l ) ; location: 8876 cross_layer: 3 file: parser.c
p = l; location: 8883 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:'\n" , p , NULL , NULL ); location: 8888 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , p , NULL , 0 ) location: 8892 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , l , NULL , 0 ) location: 8916 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8917 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8918 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8918 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
return ( l ) ; location: 8920 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
ret = xmlParseQName ( ctxt , & prefix2 ); location: 8975 cross_layer: 4 file: parser.c
if ( ( ret == name ) && ( prefix == prefix2 ) )  location: 8976 cross_layer: 4 file: parser.c
return ret ; location: 8978 cross_layer: 4 file: parser.c
------------------------------
11 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3485 @@ ['end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8868 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8869 cross_layer: 3 file: parser.c
if ( l != NULL )  location: 8872 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s'\n" , l , NULL , NULL ); location: 8873 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
return ( l ) ; location: 8876 cross_layer: 3 file: parser.c
p = l; location: 8883 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:'\n" , p , NULL , NULL ); location: 8888 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , p , NULL , 0 ) location: 8892 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , l , NULL , 0 ) location: 8916 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8917 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8918 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8918 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
return ( l ) ; location: 8920 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
localname = xmlParseQName ( ctxt , & prefix ); location: 9390 cross_layer: 4 file: parser.c
if ( localname == NULL )  location: 9391 cross_layer: 4 file: parser.c
attname = xmlParseAttribute2 ( ctxt , prefix , localname , & aprefix , & attvalue , & len , & alloc ); location: 9415 cross_layer: 4 file: parser.c
static const xmlChar *
xmlParseAttribute2(xmlParserCtxtPtr ctxt,
const xmlChar * pref, const xmlChar * elem,
const xmlChar ** prefix, xmlChar ** value,
int *len, int *alloc) location: 9221 cross_layer: 5 file: parser.c
* value = NULL; location: 9227 cross_layer: 5 file: parser.c
name = xmlParseQName ( ctxt , prefix ); location: 9229 cross_layer: 5 file: parser.c
if ( name == NULL )  location: 9230 cross_layer: 5 file: parser.c
xmlFatalErrMsg ( ctxt , XML_ERR_NAME_REQUIRED , "error parsing attribute name\n" ); location: 9231 cross_layer: 5 file: parser.c
if ( ctxt -> attsSpecial != NULL )  location: 9239 cross_layer: 5 file: parser.c
type = ( int ) ( long ) xmlHashQLookup2 ( ctxt -> attsSpecial , pref , elem , * prefix , name ); location: 9242 cross_layer: 5 file: parser.c
if ( type != 0 )  location: 9244 cross_layer: 5 file: parser.c
val = xmlParseAttValueInternal ( ctxt , len , alloc , normalize ); location: 9255 cross_layer: 5 file: parser.c
if ( * alloc )  location: 9263 cross_layer: 5 file: parser.c
val2 = xmlAttrNormalizeSpace2 ( ctxt , val , len ); location: 9266 cross_layer: 5 file: parser.c
if ( ( val2 != NULL ) && ( val2 != val ) )  location: 9267 cross_layer: 5 file: parser.c
xmlFree ( val ); location: 9268 cross_layer: 5 file: parser.c
val = ( xmlChar * ) val2; location: 9269 cross_layer: 5 file: parser.c
ctxt -> instate = XML_PARSER_CONTENT; location: 9273 cross_layer: 5 file: parser.c
xmlFatalErrMsgStr ( ctxt , XML_ERR_ATTRIBUTE_WITHOUT_VALUE , "Specification mandate value for attribute %s\n" , name ); location: 9275 cross_layer: 5 file: parser.c
if ( * prefix == ctxt -> str_xml )  location: 9281 cross_layer: 5 file: parser.c
if ( ( ctxt -> pedantic ) && ( xmlStrEqual ( name , BAD_CAST "lang" ) ) ) location: 9287 cross_layer: 5 file: parser.c
internal_val = xmlStrndup ( val , * len ); location: 9288 cross_layer: 5 file: parser.c
if ( ! xmlCheckLanguageID ( internal_val ) )  location: 9289 cross_layer: 5 file: parser.c
xmlWarningMsg ( ctxt , XML_WAR_LANG_VALUE , "Malformed value for xml:lang : %s\n" , internal_val , NULL ); location: 9290 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( name , BAD_CAST "space" ) ) location: 9299 cross_layer: 5 file: parser.c
internal_val = xmlStrndup ( val , * len ); location: 9300 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( internal_val , BAD_CAST "default" ) ) location: 9301 cross_layer: 5 file: parser.c
* ( ctxt -> space ) = 0; location: 9302 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( internal_val , BAD_CAST "preserve" ) ) location: 9303 cross_layer: 5 file: parser.c
* ( ctxt -> space ) = 1; location: 9304 cross_layer: 5 file: parser.c
xmlWarningMsg ( ctxt , XML_WAR_SPACE_VALUE , "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n" , internal_val , NULL ); location: 9306 cross_layer: 5 file: parser.c
if ( internal_val )  location: 9311 cross_layer: 5 file: parser.c
xmlFree ( internal_val ); location: 9312 cross_layer: 5 file: parser.c
* value = val; location: 9316 cross_layer: 5 file: parser.c
return ( name ) ; location: 9317 cross_layer: 5 file: parser.c
if ( ( attname != NULL ) && ( attvalue != NULL ) )  location: 9423 cross_layer: 4 file: parser.c
if ( ( attname == ctxt -> str_xmlns ) && ( aprefix == NULL ) )  location: 9425 cross_layer: 4 file: parser.c
if ( attname != ctxt -> str_xml )  location: 9450 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , NULL , attname ); location: 9473 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( attname == ctxt -> str_xml )  location: 9492 cross_layer: 4 file: parser.c
if ( attname != ctxt -> str_xml )  location: 9504 cross_layer: 4 file: parser.c
if ( attname == ctxt -> str_xmlns )  location: 9511 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_XML_NAMESPACE , "xmlns:%s: Empty XML namespace is not allowed\n" , attname , NULL , NULL ); location: 9526 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
xmlNsErr ( ctxt , XML_WAR_NS_URI , "xmlns:%s: '%s' is not a valid URI\n" , attname , URL , NULL ); location: 9533 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
xmlNsWarn ( ctxt , XML_WAR_NS_URI_RELATIVE , "xmlns:%s: URI %s is not absolute\n" , attname , URL , NULL ); location: 9538 cross_layer: 4 file: parser.c
static void
xmlNsWarn(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 813 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 815 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_WARNING , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 818 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ ctxt -> nsNr - 2 * j ] == attname )  location: 9550 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , aprefix , attname ); location: 9553 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( nsPush ( ctxt , attname , URL ) > 0 )  location: 9555 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
for (i = ctxt->nsNr - 2;i >= 0;i -= 2) location: 1589 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = attname; location: 9584 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = aprefix; location: 9585 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = NULL; location: 9586 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = attvalue; location: 9587 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = attvalue; location: 9589 cross_layer: 4 file: parser.c
if ( ( cons == ctxt -> input -> consumed ) && ( q == CUR_PTR ) && ( attname == NULL ) && ( attvalue == NULL ) )  location: 9614 cross_layer: 4 file: parser.c
defaults = xmlHashLookup2 ( ctxt -> attsDefault , localname , prefix ); location: 9631 cross_layer: 4 file: parser.c
if ( defaults != NULL )  location: 9632 cross_layer: 4 file: parser.c
for (i = 0;i < defaults->nbAttrs;i++) location: 9633 cross_layer: 4 file: parser.c
attname = defaults -> values [ 5 * i ]; location: 9634 cross_layer: 4 file: parser.c
aprefix = defaults -> values [ 5 * i + 1 ]; location: 9635 cross_layer: 4 file: parser.c
if ( ( attname == ctxt -> str_xmlns ) && ( aprefix == NULL ) )  location: 9640 cross_layer: 4 file: parser.c
if ( nsname != defaults -> values [ 5 * i + 2 ] )  location: 9650 cross_layer: 4 file: parser.c
if ( nsPush ( ctxt , NULL , defaults -> values [ 5 * i + 2 ] ) > 0 )  location: 9651 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
if ( aprefix == ctxt -> str_xmlns )  location: 9655 cross_layer: 4 file: parser.c
if ( ctxt -> nsTab [ ctxt -> nsNr - 2 * j ] == attname )  location: 9660 cross_layer: 4 file: parser.c
nsname = xmlGetNamespace ( ctxt , attname ); location: 9664 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
for (i = ctxt->nsNr - 2;i >= 0;i-=2) location: 8839 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
if ( nsname != defaults -> values [ 2 ] )  location: 9665 cross_layer: 4 file: parser.c
if ( nsPush ( ctxt , attname , defaults -> values [ 5 * i + 2 ] ) > 0 )  location: 9666 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
for (j = 0;j < nbatts;j+=5) location: 9674 cross_layer: 4 file: parser.c
if ( ( attname == atts [ j ] ) && ( aprefix == atts [ j + 1 ] ) )  location: 9675 cross_layer: 4 file: parser.c
if ( j < nbatts )  location: 9678 cross_layer: 4 file: parser.c
if ( ( atts == NULL ) || ( nbatts + 5 > maxatts ) )  location: 9680 cross_layer: 4 file: parser.c
if ( xmlCtxtGrowAttrs ( ctxt , nbatts + 5 ) < 0 )  location: 9681 cross_layer: 4 file: parser.c
static int
xmlCtxtGrowAttrs(xmlParserCtxtPtr ctxt, int nr) location: 1656 cross_layer: 5 file: parser.c
if ( ctxt -> atts == NULL )  location: 1661 cross_layer: 5 file: parser.c
ctxt -> atts = atts; location: 1666 cross_layer: 5 file: parser.c
ctxt -> attallocs = attallocs; location: 1669 cross_layer: 5 file: parser.c
ctxt -> maxatts = maxatts; location: 1670 cross_layer: 5 file: parser.c
if ( nr + 5 > ctxt -> maxatts )  location: 1671 cross_layer: 5 file: parser.c
maxatts = ( nr + 5 ) * 2; location: 1672 cross_layer: 5 file: parser.c
atts = ( const xmlChar * * ) xmlRealloc ( ( void * ) ctxt -> atts , maxatts * sizeof ( const xmlChar * ) ); location: 1673 cross_layer: 5 file: parser.c
if ( atts == NULL )  location: 1675 cross_layer: 5 file: parser.c
ctxt -> atts = atts; location: 1676 cross_layer: 5 file: parser.c
attallocs = ( int * ) xmlRealloc ( ( void * ) ctxt -> attallocs , ( maxatts / 5 ) * sizeof ( int ) ); location: 1677 cross_layer: 5 file: parser.c
if ( attallocs == NULL )  location: 1679 cross_layer: 5 file: parser.c
ctxt -> attallocs = attallocs; location: 1680 cross_layer: 5 file: parser.c
ctxt -> maxatts = maxatts; location: 1681 cross_layer: 5 file: parser.c
return ( ctxt -> maxatts ) ; location: 1683 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1685 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = attname; location: 9687 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = aprefix; location: 9688 cross_layer: 4 file: parser.c
if ( aprefix == NULL )  location: 9689 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = NULL; location: 9690 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = xmlGetNamespace ( ctxt , aprefix ); location: 9692 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = defaults -> values [ 5 * i + 2 ]; location: 9693 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = defaults -> values [ 5 * i + 3 ]; location: 9694 cross_layer: 4 file: parser.c
if ( ( ctxt -> standalone == 1 ) && ( defaults -> values [ 5 * i + 4 ] != NULL ) )  location: 9695 cross_layer: 4 file: parser.c
xmlValidityError ( ctxt , XML_DTD_STANDALONE_DEFAULTED , "standalone: attribute %s on %s defaulted from external subset\n" , attname , localname ); location: 9697 cross_layer: 4 file: parser.c
static void
xmlValidityError(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg, const xmlChar *str1, const xmlChar *str2) location: 628 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 632 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 635 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 636 cross_layer: 5 file: parser.c
if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> initialized == XML_SAX2_MAGIC ) )  location: 637 cross_layer: 5 file: parser.c
schannel = ctxt -> sax -> serror; location: 638 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 640 cross_layer: 5 file: parser.c
__xmlRaiseError ( schannel , ctxt -> vctxt . error , ctxt -> vctxt . userData , ctxt , NULL , XML_FROM_DTD , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) str1 , ( const char * ) str2 , NULL , 0 , 0 , msg , ( const char * ) str1 , ( const char * ) str2 ); location: 641 cross_layer: 5 file: parser.c
ctxt -> valid = 0; location: 647 cross_layer: 5 file: parser.c
__xmlRaiseError ( schannel , NULL , NULL , ctxt , NULL , XML_FROM_DTD , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) str1 , ( const char * ) str2 , NULL , 0 , 0 , msg , ( const char * ) str1 , ( const char * ) str2 ); location: 649 cross_layer: 5 file: parser.c
for (i = 0; i < nbatts;i += 5) location: 9710 cross_layer: 4 file: parser.c
if ( atts [ i + 1 ] != NULL )  location: 9714 cross_layer: 4 file: parser.c
nsname = xmlGetNamespace ( ctxt , atts [ i + 1 ] ); location: 9715 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
if ( nsname == NULL )  location: 9716 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_UNDEFINED_NAMESPACE , "Namespace prefix %s for %s on %s is not defined\n" , atts [ i + 1 ] , atts [ i ] , localname ); location: 9717 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
atts [ i + 2 ] = nsname; location: 9721 cross_layer: 4 file: parser.c
for (j = 0; j < i;j += 5) location: 9730 cross_layer: 4 file: parser.c
if ( atts [ i ] == atts [ j ] )  location: 9731 cross_layer: 4 file: parser.c
if ( atts [ i + 1 ] == atts [ j + 1 ] )  location: 9732 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , atts [ i + 1 ] , atts [ i ] ); location: 9733 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( ( nsname != NULL ) && ( atts [ j + 2 ] == nsname ) )  location: 9736 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_ATTRIBUTE_REDEFINED , "Namespaced Attribute %s in '%s' redefined\n" , atts [ i ] , nsname , NULL ); location: 9737 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
if ( ( prefix != NULL ) && ( nsname == NULL ) )  location: 9747 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_UNDEFINED_NAMESPACE , "Namespace prefix %s on %s is not defined\n" , prefix , localname , NULL ); location: 9748 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
* URI = nsname; location: 9753 cross_layer: 4 file: parser.c
ctxt -> sax -> startElementNs ( ctxt -> userData , localname , prefix , nsname , nbNs , & ctxt -> nsTab [ ctxt -> nsNr - 2 * nbNs ] , nbatts / 5 , nbdef , atts ); location: 9761 cross_layer: 4 file: parser.c
ctxt -> sax -> startElementNs ( ctxt -> userData , localname , prefix , nsname , 0 , NULL , nbatts / 5 , nbdef , atts ); location: 9765 cross_layer: 4 file: parser.c
for (i = 3,j = 0; j < nratts;i += 5,j++) location: 9773 cross_layer: 4 file: parser.c
if ( ( ctxt -> attallocs [ j ] != 0 ) && ( atts [ i ] != NULL ) )  location: 9774 cross_layer: 4 file: parser.c
xmlFree ( ( xmlChar * ) atts [ i ] ); location: 9775 cross_layer: 4 file: parser.c
return ( localname ) ; location: 9778 cross_layer: 4 file: parser.c
if ( ( ctxt -> attallocs [ j ] != 0 ) && ( atts [ i ] != NULL ) )  location: 9786 cross_layer: 4 file: parser.c
xmlFree ( ( xmlChar * ) atts [ i ] ); location: 9787 cross_layer: 4 file: parser.c
------------------------------
12 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3485 @@ ['end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8868 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8869 cross_layer: 3 file: parser.c
if ( l != NULL )  location: 8872 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s'\n" , l , NULL , NULL ); location: 8873 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
return ( l ) ; location: 8876 cross_layer: 3 file: parser.c
p = l; location: 8883 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:'\n" , p , NULL , NULL ); location: 8888 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , p , NULL , 0 ) location: 8892 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , l , NULL , 0 ) location: 8916 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8917 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8918 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8918 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
return ( l ) ; location: 8920 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
name = xmlParseQName ( ctxt , prefix ); location: 9229 cross_layer: 4 file: parser.c
if ( name == NULL )  location: 9230 cross_layer: 4 file: parser.c
type = ( int ) ( long ) xmlHashQLookup2 ( ctxt -> attsSpecial , pref , elem , * prefix , name ); location: 9242 cross_layer: 4 file: parser.c
if ( type != 0 )  location: 9244 cross_layer: 4 file: parser.c
xmlFatalErrMsgStr ( ctxt , XML_ERR_ATTRIBUTE_WITHOUT_VALUE , "Specification mandate value for attribute %s\n" , name ); location: 9275 cross_layer: 4 file: parser.c
static void
xmlFatalErrMsgStr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg, const xmlChar * val) location: 728 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 730 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 733 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 734 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , error , XML_ERR_FATAL , NULL , 0 , ( const char * ) val , NULL , NULL , 0 , 0 , msg , val ); location: 735 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 739 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 740 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 741 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 742 cross_layer: 5 file: parser.c
if ( ( ctxt -> pedantic ) && ( xmlStrEqual ( name , BAD_CAST "lang" ) ) ) location: 9287 cross_layer: 4 file: parser.c
int
xmlStrEqual(const xmlChar *str1, const xmlChar *str2) location: 157 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == str2 )  location: 158 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == NULL )  location: 159 cross_layer: 5 file: testCode/xmlstring.c
if ( str2 == NULL )  location: 160 cross_layer: 5 file: testCode/xmlstring.c
if ( * str1 ++ != * str2 )  location: 162 cross_layer: 5 file: testCode/xmlstring.c
while ( * str2 ++ )  location: 163 cross_layer: 5 file: testCode/xmlstring.c
if ( xmlStrEqual ( name , BAD_CAST "space" ) ) location: 9299 cross_layer: 4 file: parser.c
int
xmlStrEqual(const xmlChar *str1, const xmlChar *str2) location: 157 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == str2 )  location: 158 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == NULL )  location: 159 cross_layer: 5 file: testCode/xmlstring.c
if ( str2 == NULL )  location: 160 cross_layer: 5 file: testCode/xmlstring.c
if ( * str1 ++ != * str2 )  location: 162 cross_layer: 5 file: testCode/xmlstring.c
while ( * str2 ++ )  location: 163 cross_layer: 5 file: testCode/xmlstring.c
return ( name ) ; location: 9317 cross_layer: 4 file: parser.c
------------------------------
13 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3507 @@ ['end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
int len = 0 , l ; location: 3472 cross_layer: 1 file: parser.c
int c ; location: 3473 cross_layer: 1 file: parser.c
int count = 0 ; location: 3474 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
c = CUR_CHAR ( l ); location: 3486 cross_layer: 1 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 1 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 1 file: parser.c
if ( count ++ > XML_PARSER_CHUNK_SIZE )  location: 3494 cross_layer: 1 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 1 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8884 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
ret = xmlParseQName ( ctxt , & prefix2 ); location: 8975 cross_layer: 4 file: parser.c
if ( ( ret == name ) && ( prefix == prefix2 ) )  location: 8976 cross_layer: 4 file: parser.c
return ret ; location: 8978 cross_layer: 4 file: parser.c
------------------------------
14 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3507 @@ ['end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
int len = 0 , l ; location: 3472 cross_layer: 1 file: parser.c
int c ; location: 3473 cross_layer: 1 file: parser.c
int count = 0 ; location: 3474 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
c = CUR_CHAR ( l ); location: 3486 cross_layer: 1 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 1 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 1 file: parser.c
if ( count ++ > XML_PARSER_CHUNK_SIZE )  location: 3494 cross_layer: 1 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 1 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8884 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
localname = xmlParseQName ( ctxt , & prefix ); location: 9390 cross_layer: 4 file: parser.c
if ( localname == NULL )  location: 9391 cross_layer: 4 file: parser.c
attname = xmlParseAttribute2 ( ctxt , prefix , localname , & aprefix , & attvalue , & len , & alloc ); location: 9415 cross_layer: 4 file: parser.c
static const xmlChar *
xmlParseAttribute2(xmlParserCtxtPtr ctxt,
const xmlChar * pref, const xmlChar * elem,
const xmlChar ** prefix, xmlChar ** value,
int *len, int *alloc) location: 9221 cross_layer: 5 file: parser.c
* value = NULL; location: 9227 cross_layer: 5 file: parser.c
name = xmlParseQName ( ctxt , prefix ); location: 9229 cross_layer: 5 file: parser.c
if ( name == NULL )  location: 9230 cross_layer: 5 file: parser.c
xmlFatalErrMsg ( ctxt , XML_ERR_NAME_REQUIRED , "error parsing attribute name\n" ); location: 9231 cross_layer: 5 file: parser.c
if ( ctxt -> attsSpecial != NULL )  location: 9239 cross_layer: 5 file: parser.c
type = ( int ) ( long ) xmlHashQLookup2 ( ctxt -> attsSpecial , pref , elem , * prefix , name ); location: 9242 cross_layer: 5 file: parser.c
if ( type != 0 )  location: 9244 cross_layer: 5 file: parser.c
val = xmlParseAttValueInternal ( ctxt , len , alloc , normalize ); location: 9255 cross_layer: 5 file: parser.c
if ( * alloc )  location: 9263 cross_layer: 5 file: parser.c
val2 = xmlAttrNormalizeSpace2 ( ctxt , val , len ); location: 9266 cross_layer: 5 file: parser.c
if ( ( val2 != NULL ) && ( val2 != val ) )  location: 9267 cross_layer: 5 file: parser.c
xmlFree ( val ); location: 9268 cross_layer: 5 file: parser.c
val = ( xmlChar * ) val2; location: 9269 cross_layer: 5 file: parser.c
ctxt -> instate = XML_PARSER_CONTENT; location: 9273 cross_layer: 5 file: parser.c
xmlFatalErrMsgStr ( ctxt , XML_ERR_ATTRIBUTE_WITHOUT_VALUE , "Specification mandate value for attribute %s\n" , name ); location: 9275 cross_layer: 5 file: parser.c
if ( * prefix == ctxt -> str_xml )  location: 9281 cross_layer: 5 file: parser.c
if ( ( ctxt -> pedantic ) && ( xmlStrEqual ( name , BAD_CAST "lang" ) ) ) location: 9287 cross_layer: 5 file: parser.c
internal_val = xmlStrndup ( val , * len ); location: 9288 cross_layer: 5 file: parser.c
if ( ! xmlCheckLanguageID ( internal_val ) )  location: 9289 cross_layer: 5 file: parser.c
xmlWarningMsg ( ctxt , XML_WAR_LANG_VALUE , "Malformed value for xml:lang : %s\n" , internal_val , NULL ); location: 9290 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( name , BAD_CAST "space" ) ) location: 9299 cross_layer: 5 file: parser.c
internal_val = xmlStrndup ( val , * len ); location: 9300 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( internal_val , BAD_CAST "default" ) ) location: 9301 cross_layer: 5 file: parser.c
* ( ctxt -> space ) = 0; location: 9302 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( internal_val , BAD_CAST "preserve" ) ) location: 9303 cross_layer: 5 file: parser.c
* ( ctxt -> space ) = 1; location: 9304 cross_layer: 5 file: parser.c
xmlWarningMsg ( ctxt , XML_WAR_SPACE_VALUE , "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n" , internal_val , NULL ); location: 9306 cross_layer: 5 file: parser.c
if ( internal_val )  location: 9311 cross_layer: 5 file: parser.c
xmlFree ( internal_val ); location: 9312 cross_layer: 5 file: parser.c
* value = val; location: 9316 cross_layer: 5 file: parser.c
return ( name ) ; location: 9317 cross_layer: 5 file: parser.c
if ( ( attname != NULL ) && ( attvalue != NULL ) )  location: 9423 cross_layer: 4 file: parser.c
if ( ( attname == ctxt -> str_xmlns ) && ( aprefix == NULL ) )  location: 9425 cross_layer: 4 file: parser.c
if ( attname != ctxt -> str_xml )  location: 9450 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , NULL , attname ); location: 9473 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( attname == ctxt -> str_xml )  location: 9492 cross_layer: 4 file: parser.c
if ( attname != ctxt -> str_xml )  location: 9504 cross_layer: 4 file: parser.c
if ( attname == ctxt -> str_xmlns )  location: 9511 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_XML_NAMESPACE , "xmlns:%s: Empty XML namespace is not allowed\n" , attname , NULL , NULL ); location: 9526 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
xmlNsErr ( ctxt , XML_WAR_NS_URI , "xmlns:%s: '%s' is not a valid URI\n" , attname , URL , NULL ); location: 9533 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
xmlNsWarn ( ctxt , XML_WAR_NS_URI_RELATIVE , "xmlns:%s: URI %s is not absolute\n" , attname , URL , NULL ); location: 9538 cross_layer: 4 file: parser.c
static void
xmlNsWarn(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 813 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 815 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_WARNING , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 818 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ ctxt -> nsNr - 2 * j ] == attname )  location: 9550 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , aprefix , attname ); location: 9553 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( nsPush ( ctxt , attname , URL ) > 0 )  location: 9555 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
for (i = ctxt->nsNr - 2;i >= 0;i -= 2) location: 1589 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = attname; location: 9584 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = aprefix; location: 9585 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = NULL; location: 9586 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = attvalue; location: 9587 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = attvalue; location: 9589 cross_layer: 4 file: parser.c
if ( ( cons == ctxt -> input -> consumed ) && ( q == CUR_PTR ) && ( attname == NULL ) && ( attvalue == NULL ) )  location: 9614 cross_layer: 4 file: parser.c
defaults = xmlHashLookup2 ( ctxt -> attsDefault , localname , prefix ); location: 9631 cross_layer: 4 file: parser.c
if ( defaults != NULL )  location: 9632 cross_layer: 4 file: parser.c
for (i = 0;i < defaults->nbAttrs;i++) location: 9633 cross_layer: 4 file: parser.c
attname = defaults -> values [ 5 * i ]; location: 9634 cross_layer: 4 file: parser.c
aprefix = defaults -> values [ 5 * i + 1 ]; location: 9635 cross_layer: 4 file: parser.c
if ( ( attname == ctxt -> str_xmlns ) && ( aprefix == NULL ) )  location: 9640 cross_layer: 4 file: parser.c
if ( nsname != defaults -> values [ 5 * i + 2 ] )  location: 9650 cross_layer: 4 file: parser.c
if ( nsPush ( ctxt , NULL , defaults -> values [ 5 * i + 2 ] ) > 0 )  location: 9651 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
if ( aprefix == ctxt -> str_xmlns )  location: 9655 cross_layer: 4 file: parser.c
if ( ctxt -> nsTab [ ctxt -> nsNr - 2 * j ] == attname )  location: 9660 cross_layer: 4 file: parser.c
nsname = xmlGetNamespace ( ctxt , attname ); location: 9664 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
for (i = ctxt->nsNr - 2;i >= 0;i-=2) location: 8839 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
if ( nsname != defaults -> values [ 2 ] )  location: 9665 cross_layer: 4 file: parser.c
if ( nsPush ( ctxt , attname , defaults -> values [ 5 * i + 2 ] ) > 0 )  location: 9666 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
for (j = 0;j < nbatts;j+=5) location: 9674 cross_layer: 4 file: parser.c
if ( ( attname == atts [ j ] ) && ( aprefix == atts [ j + 1 ] ) )  location: 9675 cross_layer: 4 file: parser.c
if ( j < nbatts )  location: 9678 cross_layer: 4 file: parser.c
if ( ( atts == NULL ) || ( nbatts + 5 > maxatts ) )  location: 9680 cross_layer: 4 file: parser.c
if ( xmlCtxtGrowAttrs ( ctxt , nbatts + 5 ) < 0 )  location: 9681 cross_layer: 4 file: parser.c
static int
xmlCtxtGrowAttrs(xmlParserCtxtPtr ctxt, int nr) location: 1656 cross_layer: 5 file: parser.c
if ( ctxt -> atts == NULL )  location: 1661 cross_layer: 5 file: parser.c
ctxt -> atts = atts; location: 1666 cross_layer: 5 file: parser.c
ctxt -> attallocs = attallocs; location: 1669 cross_layer: 5 file: parser.c
ctxt -> maxatts = maxatts; location: 1670 cross_layer: 5 file: parser.c
if ( nr + 5 > ctxt -> maxatts )  location: 1671 cross_layer: 5 file: parser.c
maxatts = ( nr + 5 ) * 2; location: 1672 cross_layer: 5 file: parser.c
atts = ( const xmlChar * * ) xmlRealloc ( ( void * ) ctxt -> atts , maxatts * sizeof ( const xmlChar * ) ); location: 1673 cross_layer: 5 file: parser.c
if ( atts == NULL )  location: 1675 cross_layer: 5 file: parser.c
ctxt -> atts = atts; location: 1676 cross_layer: 5 file: parser.c
attallocs = ( int * ) xmlRealloc ( ( void * ) ctxt -> attallocs , ( maxatts / 5 ) * sizeof ( int ) ); location: 1677 cross_layer: 5 file: parser.c
if ( attallocs == NULL )  location: 1679 cross_layer: 5 file: parser.c
ctxt -> attallocs = attallocs; location: 1680 cross_layer: 5 file: parser.c
ctxt -> maxatts = maxatts; location: 1681 cross_layer: 5 file: parser.c
return ( ctxt -> maxatts ) ; location: 1683 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1685 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = attname; location: 9687 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = aprefix; location: 9688 cross_layer: 4 file: parser.c
if ( aprefix == NULL )  location: 9689 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = NULL; location: 9690 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = xmlGetNamespace ( ctxt , aprefix ); location: 9692 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = defaults -> values [ 5 * i + 2 ]; location: 9693 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = defaults -> values [ 5 * i + 3 ]; location: 9694 cross_layer: 4 file: parser.c
if ( ( ctxt -> standalone == 1 ) && ( defaults -> values [ 5 * i + 4 ] != NULL ) )  location: 9695 cross_layer: 4 file: parser.c
xmlValidityError ( ctxt , XML_DTD_STANDALONE_DEFAULTED , "standalone: attribute %s on %s defaulted from external subset\n" , attname , localname ); location: 9697 cross_layer: 4 file: parser.c
static void
xmlValidityError(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg, const xmlChar *str1, const xmlChar *str2) location: 628 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 632 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 635 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 636 cross_layer: 5 file: parser.c
if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> initialized == XML_SAX2_MAGIC ) )  location: 637 cross_layer: 5 file: parser.c
schannel = ctxt -> sax -> serror; location: 638 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 640 cross_layer: 5 file: parser.c
__xmlRaiseError ( schannel , ctxt -> vctxt . error , ctxt -> vctxt . userData , ctxt , NULL , XML_FROM_DTD , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) str1 , ( const char * ) str2 , NULL , 0 , 0 , msg , ( const char * ) str1 , ( const char * ) str2 ); location: 641 cross_layer: 5 file: parser.c
ctxt -> valid = 0; location: 647 cross_layer: 5 file: parser.c
__xmlRaiseError ( schannel , NULL , NULL , ctxt , NULL , XML_FROM_DTD , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) str1 , ( const char * ) str2 , NULL , 0 , 0 , msg , ( const char * ) str1 , ( const char * ) str2 ); location: 649 cross_layer: 5 file: parser.c
for (i = 0; i < nbatts;i += 5) location: 9710 cross_layer: 4 file: parser.c
if ( atts [ i + 1 ] != NULL )  location: 9714 cross_layer: 4 file: parser.c
nsname = xmlGetNamespace ( ctxt , atts [ i + 1 ] ); location: 9715 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
if ( nsname == NULL )  location: 9716 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_UNDEFINED_NAMESPACE , "Namespace prefix %s for %s on %s is not defined\n" , atts [ i + 1 ] , atts [ i ] , localname ); location: 9717 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
atts [ i + 2 ] = nsname; location: 9721 cross_layer: 4 file: parser.c
for (j = 0; j < i;j += 5) location: 9730 cross_layer: 4 file: parser.c
if ( atts [ i ] == atts [ j ] )  location: 9731 cross_layer: 4 file: parser.c
if ( atts [ i + 1 ] == atts [ j + 1 ] )  location: 9732 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , atts [ i + 1 ] , atts [ i ] ); location: 9733 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( ( nsname != NULL ) && ( atts [ j + 2 ] == nsname ) )  location: 9736 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_ATTRIBUTE_REDEFINED , "Namespaced Attribute %s in '%s' redefined\n" , atts [ i ] , nsname , NULL ); location: 9737 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
if ( ( prefix != NULL ) && ( nsname == NULL ) )  location: 9747 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_UNDEFINED_NAMESPACE , "Namespace prefix %s on %s is not defined\n" , prefix , localname , NULL ); location: 9748 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
* URI = nsname; location: 9753 cross_layer: 4 file: parser.c
ctxt -> sax -> startElementNs ( ctxt -> userData , localname , prefix , nsname , nbNs , & ctxt -> nsTab [ ctxt -> nsNr - 2 * nbNs ] , nbatts / 5 , nbdef , atts ); location: 9761 cross_layer: 4 file: parser.c
ctxt -> sax -> startElementNs ( ctxt -> userData , localname , prefix , nsname , 0 , NULL , nbatts / 5 , nbdef , atts ); location: 9765 cross_layer: 4 file: parser.c
for (i = 3,j = 0; j < nratts;i += 5,j++) location: 9773 cross_layer: 4 file: parser.c
if ( ( ctxt -> attallocs [ j ] != 0 ) && ( atts [ i ] != NULL ) )  location: 9774 cross_layer: 4 file: parser.c
xmlFree ( ( xmlChar * ) atts [ i ] ); location: 9775 cross_layer: 4 file: parser.c
return ( localname ) ; location: 9778 cross_layer: 4 file: parser.c
if ( ( ctxt -> attallocs [ j ] != 0 ) && ( atts [ i ] != NULL ) )  location: 9786 cross_layer: 4 file: parser.c
xmlFree ( ( xmlChar * ) atts [ i ] ); location: 9787 cross_layer: 4 file: parser.c
------------------------------
15 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3507 @@ ['end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
int len = 0 , l ; location: 3472 cross_layer: 1 file: parser.c
int c ; location: 3473 cross_layer: 1 file: parser.c
int count = 0 ; location: 3474 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
c = CUR_CHAR ( l ); location: 3486 cross_layer: 1 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 1 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 1 file: parser.c
if ( count ++ > XML_PARSER_CHUNK_SIZE )  location: 3494 cross_layer: 1 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 1 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8884 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
name = xmlParseQName ( ctxt , prefix ); location: 9229 cross_layer: 4 file: parser.c
if ( name == NULL )  location: 9230 cross_layer: 4 file: parser.c
type = ( int ) ( long ) xmlHashQLookup2 ( ctxt -> attsSpecial , pref , elem , * prefix , name ); location: 9242 cross_layer: 4 file: parser.c
if ( type != 0 )  location: 9244 cross_layer: 4 file: parser.c
xmlFatalErrMsgStr ( ctxt , XML_ERR_ATTRIBUTE_WITHOUT_VALUE , "Specification mandate value for attribute %s\n" , name ); location: 9275 cross_layer: 4 file: parser.c
static void
xmlFatalErrMsgStr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg, const xmlChar * val) location: 728 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 730 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 733 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 734 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , error , XML_ERR_FATAL , NULL , 0 , ( const char * ) val , NULL , NULL , 0 , 0 , msg , val ); location: 735 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 739 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 740 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 741 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 742 cross_layer: 5 file: parser.c
if ( ( ctxt -> pedantic ) && ( xmlStrEqual ( name , BAD_CAST "lang" ) ) ) location: 9287 cross_layer: 4 file: parser.c
int
xmlStrEqual(const xmlChar *str1, const xmlChar *str2) location: 157 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == str2 )  location: 158 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == NULL )  location: 159 cross_layer: 5 file: testCode/xmlstring.c
if ( str2 == NULL )  location: 160 cross_layer: 5 file: testCode/xmlstring.c
if ( * str1 ++ != * str2 )  location: 162 cross_layer: 5 file: testCode/xmlstring.c
while ( * str2 ++ )  location: 163 cross_layer: 5 file: testCode/xmlstring.c
if ( xmlStrEqual ( name , BAD_CAST "space" ) ) location: 9299 cross_layer: 4 file: parser.c
int
xmlStrEqual(const xmlChar *str1, const xmlChar *str2) location: 157 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == str2 )  location: 158 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == NULL )  location: 159 cross_layer: 5 file: testCode/xmlstring.c
if ( str2 == NULL )  location: 160 cross_layer: 5 file: testCode/xmlstring.c
if ( * str1 ++ != * str2 )  location: 162 cross_layer: 5 file: testCode/xmlstring.c
while ( * str2 ++ )  location: 163 cross_layer: 5 file: testCode/xmlstring.c
return ( name ) ; location: 9317 cross_layer: 4 file: parser.c
------------------------------
16 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3507 @@ ['end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
int len = 0 , l ; location: 3472 cross_layer: 1 file: parser.c
int c ; location: 3473 cross_layer: 1 file: parser.c
int count = 0 ; location: 3474 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
c = CUR_CHAR ( l ); location: 3486 cross_layer: 1 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 1 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 1 file: parser.c
if ( count ++ > XML_PARSER_CHUNK_SIZE )  location: 3494 cross_layer: 1 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 1 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8868 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8869 cross_layer: 3 file: parser.c
if ( l != NULL )  location: 8872 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s'\n" , l , NULL , NULL ); location: 8873 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
return ( l ) ; location: 8876 cross_layer: 3 file: parser.c
p = l; location: 8883 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:'\n" , p , NULL , NULL ); location: 8888 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , p , NULL , 0 ) location: 8892 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , l , NULL , 0 ) location: 8916 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8917 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8918 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8918 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
return ( l ) ; location: 8920 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
ret = xmlParseQName ( ctxt , & prefix2 ); location: 8975 cross_layer: 4 file: parser.c
if ( ( ret == name ) && ( prefix == prefix2 ) )  location: 8976 cross_layer: 4 file: parser.c
return ret ; location: 8978 cross_layer: 4 file: parser.c
------------------------------
17 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3507 @@ ['end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
int len = 0 , l ; location: 3472 cross_layer: 1 file: parser.c
int c ; location: 3473 cross_layer: 1 file: parser.c
int count = 0 ; location: 3474 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
c = CUR_CHAR ( l ); location: 3486 cross_layer: 1 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 1 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 1 file: parser.c
if ( count ++ > XML_PARSER_CHUNK_SIZE )  location: 3494 cross_layer: 1 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 1 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8868 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8869 cross_layer: 3 file: parser.c
if ( l != NULL )  location: 8872 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s'\n" , l , NULL , NULL ); location: 8873 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
return ( l ) ; location: 8876 cross_layer: 3 file: parser.c
p = l; location: 8883 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:'\n" , p , NULL , NULL ); location: 8888 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , p , NULL , 0 ) location: 8892 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , l , NULL , 0 ) location: 8916 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8917 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8918 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8918 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
return ( l ) ; location: 8920 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
localname = xmlParseQName ( ctxt , & prefix ); location: 9390 cross_layer: 4 file: parser.c
if ( localname == NULL )  location: 9391 cross_layer: 4 file: parser.c
attname = xmlParseAttribute2 ( ctxt , prefix , localname , & aprefix , & attvalue , & len , & alloc ); location: 9415 cross_layer: 4 file: parser.c
static const xmlChar *
xmlParseAttribute2(xmlParserCtxtPtr ctxt,
const xmlChar * pref, const xmlChar * elem,
const xmlChar ** prefix, xmlChar ** value,
int *len, int *alloc) location: 9221 cross_layer: 5 file: parser.c
* value = NULL; location: 9227 cross_layer: 5 file: parser.c
name = xmlParseQName ( ctxt , prefix ); location: 9229 cross_layer: 5 file: parser.c
if ( name == NULL )  location: 9230 cross_layer: 5 file: parser.c
xmlFatalErrMsg ( ctxt , XML_ERR_NAME_REQUIRED , "error parsing attribute name\n" ); location: 9231 cross_layer: 5 file: parser.c
if ( ctxt -> attsSpecial != NULL )  location: 9239 cross_layer: 5 file: parser.c
type = ( int ) ( long ) xmlHashQLookup2 ( ctxt -> attsSpecial , pref , elem , * prefix , name ); location: 9242 cross_layer: 5 file: parser.c
if ( type != 0 )  location: 9244 cross_layer: 5 file: parser.c
val = xmlParseAttValueInternal ( ctxt , len , alloc , normalize ); location: 9255 cross_layer: 5 file: parser.c
if ( * alloc )  location: 9263 cross_layer: 5 file: parser.c
val2 = xmlAttrNormalizeSpace2 ( ctxt , val , len ); location: 9266 cross_layer: 5 file: parser.c
if ( ( val2 != NULL ) && ( val2 != val ) )  location: 9267 cross_layer: 5 file: parser.c
xmlFree ( val ); location: 9268 cross_layer: 5 file: parser.c
val = ( xmlChar * ) val2; location: 9269 cross_layer: 5 file: parser.c
ctxt -> instate = XML_PARSER_CONTENT; location: 9273 cross_layer: 5 file: parser.c
xmlFatalErrMsgStr ( ctxt , XML_ERR_ATTRIBUTE_WITHOUT_VALUE , "Specification mandate value for attribute %s\n" , name ); location: 9275 cross_layer: 5 file: parser.c
if ( * prefix == ctxt -> str_xml )  location: 9281 cross_layer: 5 file: parser.c
if ( ( ctxt -> pedantic ) && ( xmlStrEqual ( name , BAD_CAST "lang" ) ) ) location: 9287 cross_layer: 5 file: parser.c
internal_val = xmlStrndup ( val , * len ); location: 9288 cross_layer: 5 file: parser.c
if ( ! xmlCheckLanguageID ( internal_val ) )  location: 9289 cross_layer: 5 file: parser.c
xmlWarningMsg ( ctxt , XML_WAR_LANG_VALUE , "Malformed value for xml:lang : %s\n" , internal_val , NULL ); location: 9290 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( name , BAD_CAST "space" ) ) location: 9299 cross_layer: 5 file: parser.c
internal_val = xmlStrndup ( val , * len ); location: 9300 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( internal_val , BAD_CAST "default" ) ) location: 9301 cross_layer: 5 file: parser.c
* ( ctxt -> space ) = 0; location: 9302 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( internal_val , BAD_CAST "preserve" ) ) location: 9303 cross_layer: 5 file: parser.c
* ( ctxt -> space ) = 1; location: 9304 cross_layer: 5 file: parser.c
xmlWarningMsg ( ctxt , XML_WAR_SPACE_VALUE , "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n" , internal_val , NULL ); location: 9306 cross_layer: 5 file: parser.c
if ( internal_val )  location: 9311 cross_layer: 5 file: parser.c
xmlFree ( internal_val ); location: 9312 cross_layer: 5 file: parser.c
* value = val; location: 9316 cross_layer: 5 file: parser.c
return ( name ) ; location: 9317 cross_layer: 5 file: parser.c
if ( ( attname != NULL ) && ( attvalue != NULL ) )  location: 9423 cross_layer: 4 file: parser.c
if ( ( attname == ctxt -> str_xmlns ) && ( aprefix == NULL ) )  location: 9425 cross_layer: 4 file: parser.c
if ( attname != ctxt -> str_xml )  location: 9450 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , NULL , attname ); location: 9473 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( attname == ctxt -> str_xml )  location: 9492 cross_layer: 4 file: parser.c
if ( attname != ctxt -> str_xml )  location: 9504 cross_layer: 4 file: parser.c
if ( attname == ctxt -> str_xmlns )  location: 9511 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_XML_NAMESPACE , "xmlns:%s: Empty XML namespace is not allowed\n" , attname , NULL , NULL ); location: 9526 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
xmlNsErr ( ctxt , XML_WAR_NS_URI , "xmlns:%s: '%s' is not a valid URI\n" , attname , URL , NULL ); location: 9533 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
xmlNsWarn ( ctxt , XML_WAR_NS_URI_RELATIVE , "xmlns:%s: URI %s is not absolute\n" , attname , URL , NULL ); location: 9538 cross_layer: 4 file: parser.c
static void
xmlNsWarn(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 813 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 815 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_WARNING , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 818 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ ctxt -> nsNr - 2 * j ] == attname )  location: 9550 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , aprefix , attname ); location: 9553 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( nsPush ( ctxt , attname , URL ) > 0 )  location: 9555 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
for (i = ctxt->nsNr - 2;i >= 0;i -= 2) location: 1589 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = attname; location: 9584 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = aprefix; location: 9585 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = NULL; location: 9586 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = attvalue; location: 9587 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = attvalue; location: 9589 cross_layer: 4 file: parser.c
if ( ( cons == ctxt -> input -> consumed ) && ( q == CUR_PTR ) && ( attname == NULL ) && ( attvalue == NULL ) )  location: 9614 cross_layer: 4 file: parser.c
defaults = xmlHashLookup2 ( ctxt -> attsDefault , localname , prefix ); location: 9631 cross_layer: 4 file: parser.c
if ( defaults != NULL )  location: 9632 cross_layer: 4 file: parser.c
for (i = 0;i < defaults->nbAttrs;i++) location: 9633 cross_layer: 4 file: parser.c
attname = defaults -> values [ 5 * i ]; location: 9634 cross_layer: 4 file: parser.c
aprefix = defaults -> values [ 5 * i + 1 ]; location: 9635 cross_layer: 4 file: parser.c
if ( ( attname == ctxt -> str_xmlns ) && ( aprefix == NULL ) )  location: 9640 cross_layer: 4 file: parser.c
if ( nsname != defaults -> values [ 5 * i + 2 ] )  location: 9650 cross_layer: 4 file: parser.c
if ( nsPush ( ctxt , NULL , defaults -> values [ 5 * i + 2 ] ) > 0 )  location: 9651 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
if ( aprefix == ctxt -> str_xmlns )  location: 9655 cross_layer: 4 file: parser.c
if ( ctxt -> nsTab [ ctxt -> nsNr - 2 * j ] == attname )  location: 9660 cross_layer: 4 file: parser.c
nsname = xmlGetNamespace ( ctxt , attname ); location: 9664 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
for (i = ctxt->nsNr - 2;i >= 0;i-=2) location: 8839 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
if ( nsname != defaults -> values [ 2 ] )  location: 9665 cross_layer: 4 file: parser.c
if ( nsPush ( ctxt , attname , defaults -> values [ 5 * i + 2 ] ) > 0 )  location: 9666 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
for (j = 0;j < nbatts;j+=5) location: 9674 cross_layer: 4 file: parser.c
if ( ( attname == atts [ j ] ) && ( aprefix == atts [ j + 1 ] ) )  location: 9675 cross_layer: 4 file: parser.c
if ( j < nbatts )  location: 9678 cross_layer: 4 file: parser.c
if ( ( atts == NULL ) || ( nbatts + 5 > maxatts ) )  location: 9680 cross_layer: 4 file: parser.c
if ( xmlCtxtGrowAttrs ( ctxt , nbatts + 5 ) < 0 )  location: 9681 cross_layer: 4 file: parser.c
static int
xmlCtxtGrowAttrs(xmlParserCtxtPtr ctxt, int nr) location: 1656 cross_layer: 5 file: parser.c
if ( ctxt -> atts == NULL )  location: 1661 cross_layer: 5 file: parser.c
ctxt -> atts = atts; location: 1666 cross_layer: 5 file: parser.c
ctxt -> attallocs = attallocs; location: 1669 cross_layer: 5 file: parser.c
ctxt -> maxatts = maxatts; location: 1670 cross_layer: 5 file: parser.c
if ( nr + 5 > ctxt -> maxatts )  location: 1671 cross_layer: 5 file: parser.c
maxatts = ( nr + 5 ) * 2; location: 1672 cross_layer: 5 file: parser.c
atts = ( const xmlChar * * ) xmlRealloc ( ( void * ) ctxt -> atts , maxatts * sizeof ( const xmlChar * ) ); location: 1673 cross_layer: 5 file: parser.c
if ( atts == NULL )  location: 1675 cross_layer: 5 file: parser.c
ctxt -> atts = atts; location: 1676 cross_layer: 5 file: parser.c
attallocs = ( int * ) xmlRealloc ( ( void * ) ctxt -> attallocs , ( maxatts / 5 ) * sizeof ( int ) ); location: 1677 cross_layer: 5 file: parser.c
if ( attallocs == NULL )  location: 1679 cross_layer: 5 file: parser.c
ctxt -> attallocs = attallocs; location: 1680 cross_layer: 5 file: parser.c
ctxt -> maxatts = maxatts; location: 1681 cross_layer: 5 file: parser.c
return ( ctxt -> maxatts ) ; location: 1683 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1685 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = attname; location: 9687 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = aprefix; location: 9688 cross_layer: 4 file: parser.c
if ( aprefix == NULL )  location: 9689 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = NULL; location: 9690 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = xmlGetNamespace ( ctxt , aprefix ); location: 9692 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = defaults -> values [ 5 * i + 2 ]; location: 9693 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = defaults -> values [ 5 * i + 3 ]; location: 9694 cross_layer: 4 file: parser.c
if ( ( ctxt -> standalone == 1 ) && ( defaults -> values [ 5 * i + 4 ] != NULL ) )  location: 9695 cross_layer: 4 file: parser.c
xmlValidityError ( ctxt , XML_DTD_STANDALONE_DEFAULTED , "standalone: attribute %s on %s defaulted from external subset\n" , attname , localname ); location: 9697 cross_layer: 4 file: parser.c
static void
xmlValidityError(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg, const xmlChar *str1, const xmlChar *str2) location: 628 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 632 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 635 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 636 cross_layer: 5 file: parser.c
if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> initialized == XML_SAX2_MAGIC ) )  location: 637 cross_layer: 5 file: parser.c
schannel = ctxt -> sax -> serror; location: 638 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 640 cross_layer: 5 file: parser.c
__xmlRaiseError ( schannel , ctxt -> vctxt . error , ctxt -> vctxt . userData , ctxt , NULL , XML_FROM_DTD , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) str1 , ( const char * ) str2 , NULL , 0 , 0 , msg , ( const char * ) str1 , ( const char * ) str2 ); location: 641 cross_layer: 5 file: parser.c
ctxt -> valid = 0; location: 647 cross_layer: 5 file: parser.c
__xmlRaiseError ( schannel , NULL , NULL , ctxt , NULL , XML_FROM_DTD , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) str1 , ( const char * ) str2 , NULL , 0 , 0 , msg , ( const char * ) str1 , ( const char * ) str2 ); location: 649 cross_layer: 5 file: parser.c
for (i = 0; i < nbatts;i += 5) location: 9710 cross_layer: 4 file: parser.c
if ( atts [ i + 1 ] != NULL )  location: 9714 cross_layer: 4 file: parser.c
nsname = xmlGetNamespace ( ctxt , atts [ i + 1 ] ); location: 9715 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
if ( nsname == NULL )  location: 9716 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_UNDEFINED_NAMESPACE , "Namespace prefix %s for %s on %s is not defined\n" , atts [ i + 1 ] , atts [ i ] , localname ); location: 9717 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
atts [ i + 2 ] = nsname; location: 9721 cross_layer: 4 file: parser.c
for (j = 0; j < i;j += 5) location: 9730 cross_layer: 4 file: parser.c
if ( atts [ i ] == atts [ j ] )  location: 9731 cross_layer: 4 file: parser.c
if ( atts [ i + 1 ] == atts [ j + 1 ] )  location: 9732 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , atts [ i + 1 ] , atts [ i ] ); location: 9733 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( ( nsname != NULL ) && ( atts [ j + 2 ] == nsname ) )  location: 9736 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_ATTRIBUTE_REDEFINED , "Namespaced Attribute %s in '%s' redefined\n" , atts [ i ] , nsname , NULL ); location: 9737 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
if ( ( prefix != NULL ) && ( nsname == NULL ) )  location: 9747 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_UNDEFINED_NAMESPACE , "Namespace prefix %s on %s is not defined\n" , prefix , localname , NULL ); location: 9748 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
* URI = nsname; location: 9753 cross_layer: 4 file: parser.c
ctxt -> sax -> startElementNs ( ctxt -> userData , localname , prefix , nsname , nbNs , & ctxt -> nsTab [ ctxt -> nsNr - 2 * nbNs ] , nbatts / 5 , nbdef , atts ); location: 9761 cross_layer: 4 file: parser.c
ctxt -> sax -> startElementNs ( ctxt -> userData , localname , prefix , nsname , 0 , NULL , nbatts / 5 , nbdef , atts ); location: 9765 cross_layer: 4 file: parser.c
for (i = 3,j = 0; j < nratts;i += 5,j++) location: 9773 cross_layer: 4 file: parser.c
if ( ( ctxt -> attallocs [ j ] != 0 ) && ( atts [ i ] != NULL ) )  location: 9774 cross_layer: 4 file: parser.c
xmlFree ( ( xmlChar * ) atts [ i ] ); location: 9775 cross_layer: 4 file: parser.c
return ( localname ) ; location: 9778 cross_layer: 4 file: parser.c
if ( ( ctxt -> attallocs [ j ] != 0 ) && ( atts [ i ] != NULL ) )  location: 9786 cross_layer: 4 file: parser.c
xmlFree ( ( xmlChar * ) atts [ i ] ); location: 9787 cross_layer: 4 file: parser.c
------------------------------
18 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3507 @@ ['end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
int len = 0 , l ; location: 3472 cross_layer: 1 file: parser.c
int c ; location: 3473 cross_layer: 1 file: parser.c
int count = 0 ; location: 3474 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
c = CUR_CHAR ( l ); location: 3486 cross_layer: 1 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 1 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 1 file: parser.c
if ( count ++ > XML_PARSER_CHUNK_SIZE )  location: 3494 cross_layer: 1 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 1 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8868 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8869 cross_layer: 3 file: parser.c
if ( l != NULL )  location: 8872 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s'\n" , l , NULL , NULL ); location: 8873 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
return ( l ) ; location: 8876 cross_layer: 3 file: parser.c
p = l; location: 8883 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:'\n" , p , NULL , NULL ); location: 8888 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , p , NULL , 0 ) location: 8892 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , l , NULL , 0 ) location: 8916 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8917 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8918 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8918 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
return ( l ) ; location: 8920 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
name = xmlParseQName ( ctxt , prefix ); location: 9229 cross_layer: 4 file: parser.c
if ( name == NULL )  location: 9230 cross_layer: 4 file: parser.c
type = ( int ) ( long ) xmlHashQLookup2 ( ctxt -> attsSpecial , pref , elem , * prefix , name ); location: 9242 cross_layer: 4 file: parser.c
if ( type != 0 )  location: 9244 cross_layer: 4 file: parser.c
xmlFatalErrMsgStr ( ctxt , XML_ERR_ATTRIBUTE_WITHOUT_VALUE , "Specification mandate value for attribute %s\n" , name ); location: 9275 cross_layer: 4 file: parser.c
static void
xmlFatalErrMsgStr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg, const xmlChar * val) location: 728 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 730 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 733 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 734 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , error , XML_ERR_FATAL , NULL , 0 , ( const char * ) val , NULL , NULL , 0 , 0 , msg , val ); location: 735 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 739 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 740 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 741 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 742 cross_layer: 5 file: parser.c
if ( ( ctxt -> pedantic ) && ( xmlStrEqual ( name , BAD_CAST "lang" ) ) ) location: 9287 cross_layer: 4 file: parser.c
int
xmlStrEqual(const xmlChar *str1, const xmlChar *str2) location: 157 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == str2 )  location: 158 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == NULL )  location: 159 cross_layer: 5 file: testCode/xmlstring.c
if ( str2 == NULL )  location: 160 cross_layer: 5 file: testCode/xmlstring.c
if ( * str1 ++ != * str2 )  location: 162 cross_layer: 5 file: testCode/xmlstring.c
while ( * str2 ++ )  location: 163 cross_layer: 5 file: testCode/xmlstring.c
if ( xmlStrEqual ( name , BAD_CAST "space" ) ) location: 9299 cross_layer: 4 file: parser.c
int
xmlStrEqual(const xmlChar *str1, const xmlChar *str2) location: 157 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == str2 )  location: 158 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == NULL )  location: 159 cross_layer: 5 file: testCode/xmlstring.c
if ( str2 == NULL )  location: 160 cross_layer: 5 file: testCode/xmlstring.c
if ( * str1 ++ != * str2 )  location: 162 cross_layer: 5 file: testCode/xmlstring.c
while ( * str2 ++ )  location: 163 cross_layer: 5 file: testCode/xmlstring.c
return ( name ) ; location: 9317 cross_layer: 4 file: parser.c
------------------------------
19 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3521 @@ ['end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
int len = 0 , l ; location: 3472 cross_layer: 1 file: parser.c
int c ; location: 3473 cross_layer: 1 file: parser.c
int count = 0 ; location: 3474 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
c = CUR_CHAR ( l ); location: 3486 cross_layer: 1 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 1 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 1 file: parser.c
if ( count ++ > XML_PARSER_CHUNK_SIZE )  location: 3494 cross_layer: 1 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 1 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 1 file: parser.c
c = CUR_CHAR ( l ); location: 3508 cross_layer: 1 file: parser.c
if ( c == 0 )  location: 3509 cross_layer: 1 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 1 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 1 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8884 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
ret = xmlParseQName ( ctxt , & prefix2 ); location: 8975 cross_layer: 4 file: parser.c
if ( ( ret == name ) && ( prefix == prefix2 ) )  location: 8976 cross_layer: 4 file: parser.c
return ret ; location: 8978 cross_layer: 4 file: parser.c
------------------------------
20 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3521 @@ ['end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
int len = 0 , l ; location: 3472 cross_layer: 1 file: parser.c
int c ; location: 3473 cross_layer: 1 file: parser.c
int count = 0 ; location: 3474 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
c = CUR_CHAR ( l ); location: 3486 cross_layer: 1 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 1 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 1 file: parser.c
if ( count ++ > XML_PARSER_CHUNK_SIZE )  location: 3494 cross_layer: 1 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 1 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 1 file: parser.c
c = CUR_CHAR ( l ); location: 3508 cross_layer: 1 file: parser.c
if ( c == 0 )  location: 3509 cross_layer: 1 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 1 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 1 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8884 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
localname = xmlParseQName ( ctxt , & prefix ); location: 9390 cross_layer: 4 file: parser.c
if ( localname == NULL )  location: 9391 cross_layer: 4 file: parser.c
attname = xmlParseAttribute2 ( ctxt , prefix , localname , & aprefix , & attvalue , & len , & alloc ); location: 9415 cross_layer: 4 file: parser.c
static const xmlChar *
xmlParseAttribute2(xmlParserCtxtPtr ctxt,
const xmlChar * pref, const xmlChar * elem,
const xmlChar ** prefix, xmlChar ** value,
int *len, int *alloc) location: 9221 cross_layer: 5 file: parser.c
* value = NULL; location: 9227 cross_layer: 5 file: parser.c
name = xmlParseQName ( ctxt , prefix ); location: 9229 cross_layer: 5 file: parser.c
if ( name == NULL )  location: 9230 cross_layer: 5 file: parser.c
xmlFatalErrMsg ( ctxt , XML_ERR_NAME_REQUIRED , "error parsing attribute name\n" ); location: 9231 cross_layer: 5 file: parser.c
if ( ctxt -> attsSpecial != NULL )  location: 9239 cross_layer: 5 file: parser.c
type = ( int ) ( long ) xmlHashQLookup2 ( ctxt -> attsSpecial , pref , elem , * prefix , name ); location: 9242 cross_layer: 5 file: parser.c
if ( type != 0 )  location: 9244 cross_layer: 5 file: parser.c
val = xmlParseAttValueInternal ( ctxt , len , alloc , normalize ); location: 9255 cross_layer: 5 file: parser.c
if ( * alloc )  location: 9263 cross_layer: 5 file: parser.c
val2 = xmlAttrNormalizeSpace2 ( ctxt , val , len ); location: 9266 cross_layer: 5 file: parser.c
if ( ( val2 != NULL ) && ( val2 != val ) )  location: 9267 cross_layer: 5 file: parser.c
xmlFree ( val ); location: 9268 cross_layer: 5 file: parser.c
val = ( xmlChar * ) val2; location: 9269 cross_layer: 5 file: parser.c
ctxt -> instate = XML_PARSER_CONTENT; location: 9273 cross_layer: 5 file: parser.c
xmlFatalErrMsgStr ( ctxt , XML_ERR_ATTRIBUTE_WITHOUT_VALUE , "Specification mandate value for attribute %s\n" , name ); location: 9275 cross_layer: 5 file: parser.c
if ( * prefix == ctxt -> str_xml )  location: 9281 cross_layer: 5 file: parser.c
if ( ( ctxt -> pedantic ) && ( xmlStrEqual ( name , BAD_CAST "lang" ) ) ) location: 9287 cross_layer: 5 file: parser.c
internal_val = xmlStrndup ( val , * len ); location: 9288 cross_layer: 5 file: parser.c
if ( ! xmlCheckLanguageID ( internal_val ) )  location: 9289 cross_layer: 5 file: parser.c
xmlWarningMsg ( ctxt , XML_WAR_LANG_VALUE , "Malformed value for xml:lang : %s\n" , internal_val , NULL ); location: 9290 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( name , BAD_CAST "space" ) ) location: 9299 cross_layer: 5 file: parser.c
internal_val = xmlStrndup ( val , * len ); location: 9300 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( internal_val , BAD_CAST "default" ) ) location: 9301 cross_layer: 5 file: parser.c
* ( ctxt -> space ) = 0; location: 9302 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( internal_val , BAD_CAST "preserve" ) ) location: 9303 cross_layer: 5 file: parser.c
* ( ctxt -> space ) = 1; location: 9304 cross_layer: 5 file: parser.c
xmlWarningMsg ( ctxt , XML_WAR_SPACE_VALUE , "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n" , internal_val , NULL ); location: 9306 cross_layer: 5 file: parser.c
if ( internal_val )  location: 9311 cross_layer: 5 file: parser.c
xmlFree ( internal_val ); location: 9312 cross_layer: 5 file: parser.c
* value = val; location: 9316 cross_layer: 5 file: parser.c
return ( name ) ; location: 9317 cross_layer: 5 file: parser.c
if ( ( attname != NULL ) && ( attvalue != NULL ) )  location: 9423 cross_layer: 4 file: parser.c
if ( ( attname == ctxt -> str_xmlns ) && ( aprefix == NULL ) )  location: 9425 cross_layer: 4 file: parser.c
if ( attname != ctxt -> str_xml )  location: 9450 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , NULL , attname ); location: 9473 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( attname == ctxt -> str_xml )  location: 9492 cross_layer: 4 file: parser.c
if ( attname != ctxt -> str_xml )  location: 9504 cross_layer: 4 file: parser.c
if ( attname == ctxt -> str_xmlns )  location: 9511 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_XML_NAMESPACE , "xmlns:%s: Empty XML namespace is not allowed\n" , attname , NULL , NULL ); location: 9526 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
xmlNsErr ( ctxt , XML_WAR_NS_URI , "xmlns:%s: '%s' is not a valid URI\n" , attname , URL , NULL ); location: 9533 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
xmlNsWarn ( ctxt , XML_WAR_NS_URI_RELATIVE , "xmlns:%s: URI %s is not absolute\n" , attname , URL , NULL ); location: 9538 cross_layer: 4 file: parser.c
static void
xmlNsWarn(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 813 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 815 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_WARNING , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 818 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ ctxt -> nsNr - 2 * j ] == attname )  location: 9550 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , aprefix , attname ); location: 9553 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( nsPush ( ctxt , attname , URL ) > 0 )  location: 9555 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
for (i = ctxt->nsNr - 2;i >= 0;i -= 2) location: 1589 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = attname; location: 9584 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = aprefix; location: 9585 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = NULL; location: 9586 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = attvalue; location: 9587 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = attvalue; location: 9589 cross_layer: 4 file: parser.c
if ( ( cons == ctxt -> input -> consumed ) && ( q == CUR_PTR ) && ( attname == NULL ) && ( attvalue == NULL ) )  location: 9614 cross_layer: 4 file: parser.c
defaults = xmlHashLookup2 ( ctxt -> attsDefault , localname , prefix ); location: 9631 cross_layer: 4 file: parser.c
if ( defaults != NULL )  location: 9632 cross_layer: 4 file: parser.c
for (i = 0;i < defaults->nbAttrs;i++) location: 9633 cross_layer: 4 file: parser.c
attname = defaults -> values [ 5 * i ]; location: 9634 cross_layer: 4 file: parser.c
aprefix = defaults -> values [ 5 * i + 1 ]; location: 9635 cross_layer: 4 file: parser.c
if ( ( attname == ctxt -> str_xmlns ) && ( aprefix == NULL ) )  location: 9640 cross_layer: 4 file: parser.c
if ( nsname != defaults -> values [ 5 * i + 2 ] )  location: 9650 cross_layer: 4 file: parser.c
if ( nsPush ( ctxt , NULL , defaults -> values [ 5 * i + 2 ] ) > 0 )  location: 9651 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
if ( aprefix == ctxt -> str_xmlns )  location: 9655 cross_layer: 4 file: parser.c
if ( ctxt -> nsTab [ ctxt -> nsNr - 2 * j ] == attname )  location: 9660 cross_layer: 4 file: parser.c
nsname = xmlGetNamespace ( ctxt , attname ); location: 9664 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
for (i = ctxt->nsNr - 2;i >= 0;i-=2) location: 8839 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
if ( nsname != defaults -> values [ 2 ] )  location: 9665 cross_layer: 4 file: parser.c
if ( nsPush ( ctxt , attname , defaults -> values [ 5 * i + 2 ] ) > 0 )  location: 9666 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
for (j = 0;j < nbatts;j+=5) location: 9674 cross_layer: 4 file: parser.c
if ( ( attname == atts [ j ] ) && ( aprefix == atts [ j + 1 ] ) )  location: 9675 cross_layer: 4 file: parser.c
if ( j < nbatts )  location: 9678 cross_layer: 4 file: parser.c
if ( ( atts == NULL ) || ( nbatts + 5 > maxatts ) )  location: 9680 cross_layer: 4 file: parser.c
if ( xmlCtxtGrowAttrs ( ctxt , nbatts + 5 ) < 0 )  location: 9681 cross_layer: 4 file: parser.c
static int
xmlCtxtGrowAttrs(xmlParserCtxtPtr ctxt, int nr) location: 1656 cross_layer: 5 file: parser.c
if ( ctxt -> atts == NULL )  location: 1661 cross_layer: 5 file: parser.c
ctxt -> atts = atts; location: 1666 cross_layer: 5 file: parser.c
ctxt -> attallocs = attallocs; location: 1669 cross_layer: 5 file: parser.c
ctxt -> maxatts = maxatts; location: 1670 cross_layer: 5 file: parser.c
if ( nr + 5 > ctxt -> maxatts )  location: 1671 cross_layer: 5 file: parser.c
maxatts = ( nr + 5 ) * 2; location: 1672 cross_layer: 5 file: parser.c
atts = ( const xmlChar * * ) xmlRealloc ( ( void * ) ctxt -> atts , maxatts * sizeof ( const xmlChar * ) ); location: 1673 cross_layer: 5 file: parser.c
if ( atts == NULL )  location: 1675 cross_layer: 5 file: parser.c
ctxt -> atts = atts; location: 1676 cross_layer: 5 file: parser.c
attallocs = ( int * ) xmlRealloc ( ( void * ) ctxt -> attallocs , ( maxatts / 5 ) * sizeof ( int ) ); location: 1677 cross_layer: 5 file: parser.c
if ( attallocs == NULL )  location: 1679 cross_layer: 5 file: parser.c
ctxt -> attallocs = attallocs; location: 1680 cross_layer: 5 file: parser.c
ctxt -> maxatts = maxatts; location: 1681 cross_layer: 5 file: parser.c
return ( ctxt -> maxatts ) ; location: 1683 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1685 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = attname; location: 9687 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = aprefix; location: 9688 cross_layer: 4 file: parser.c
if ( aprefix == NULL )  location: 9689 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = NULL; location: 9690 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = xmlGetNamespace ( ctxt , aprefix ); location: 9692 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = defaults -> values [ 5 * i + 2 ]; location: 9693 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = defaults -> values [ 5 * i + 3 ]; location: 9694 cross_layer: 4 file: parser.c
if ( ( ctxt -> standalone == 1 ) && ( defaults -> values [ 5 * i + 4 ] != NULL ) )  location: 9695 cross_layer: 4 file: parser.c
xmlValidityError ( ctxt , XML_DTD_STANDALONE_DEFAULTED , "standalone: attribute %s on %s defaulted from external subset\n" , attname , localname ); location: 9697 cross_layer: 4 file: parser.c
static void
xmlValidityError(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg, const xmlChar *str1, const xmlChar *str2) location: 628 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 632 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 635 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 636 cross_layer: 5 file: parser.c
if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> initialized == XML_SAX2_MAGIC ) )  location: 637 cross_layer: 5 file: parser.c
schannel = ctxt -> sax -> serror; location: 638 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 640 cross_layer: 5 file: parser.c
__xmlRaiseError ( schannel , ctxt -> vctxt . error , ctxt -> vctxt . userData , ctxt , NULL , XML_FROM_DTD , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) str1 , ( const char * ) str2 , NULL , 0 , 0 , msg , ( const char * ) str1 , ( const char * ) str2 ); location: 641 cross_layer: 5 file: parser.c
ctxt -> valid = 0; location: 647 cross_layer: 5 file: parser.c
__xmlRaiseError ( schannel , NULL , NULL , ctxt , NULL , XML_FROM_DTD , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) str1 , ( const char * ) str2 , NULL , 0 , 0 , msg , ( const char * ) str1 , ( const char * ) str2 ); location: 649 cross_layer: 5 file: parser.c
for (i = 0; i < nbatts;i += 5) location: 9710 cross_layer: 4 file: parser.c
if ( atts [ i + 1 ] != NULL )  location: 9714 cross_layer: 4 file: parser.c
nsname = xmlGetNamespace ( ctxt , atts [ i + 1 ] ); location: 9715 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
if ( nsname == NULL )  location: 9716 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_UNDEFINED_NAMESPACE , "Namespace prefix %s for %s on %s is not defined\n" , atts [ i + 1 ] , atts [ i ] , localname ); location: 9717 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
atts [ i + 2 ] = nsname; location: 9721 cross_layer: 4 file: parser.c
for (j = 0; j < i;j += 5) location: 9730 cross_layer: 4 file: parser.c
if ( atts [ i ] == atts [ j ] )  location: 9731 cross_layer: 4 file: parser.c
if ( atts [ i + 1 ] == atts [ j + 1 ] )  location: 9732 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , atts [ i + 1 ] , atts [ i ] ); location: 9733 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( ( nsname != NULL ) && ( atts [ j + 2 ] == nsname ) )  location: 9736 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_ATTRIBUTE_REDEFINED , "Namespaced Attribute %s in '%s' redefined\n" , atts [ i ] , nsname , NULL ); location: 9737 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
if ( ( prefix != NULL ) && ( nsname == NULL ) )  location: 9747 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_UNDEFINED_NAMESPACE , "Namespace prefix %s on %s is not defined\n" , prefix , localname , NULL ); location: 9748 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
* URI = nsname; location: 9753 cross_layer: 4 file: parser.c
ctxt -> sax -> startElementNs ( ctxt -> userData , localname , prefix , nsname , nbNs , & ctxt -> nsTab [ ctxt -> nsNr - 2 * nbNs ] , nbatts / 5 , nbdef , atts ); location: 9761 cross_layer: 4 file: parser.c
ctxt -> sax -> startElementNs ( ctxt -> userData , localname , prefix , nsname , 0 , NULL , nbatts / 5 , nbdef , atts ); location: 9765 cross_layer: 4 file: parser.c
for (i = 3,j = 0; j < nratts;i += 5,j++) location: 9773 cross_layer: 4 file: parser.c
if ( ( ctxt -> attallocs [ j ] != 0 ) && ( atts [ i ] != NULL ) )  location: 9774 cross_layer: 4 file: parser.c
xmlFree ( ( xmlChar * ) atts [ i ] ); location: 9775 cross_layer: 4 file: parser.c
return ( localname ) ; location: 9778 cross_layer: 4 file: parser.c
if ( ( ctxt -> attallocs [ j ] != 0 ) && ( atts [ i ] != NULL ) )  location: 9786 cross_layer: 4 file: parser.c
xmlFree ( ( xmlChar * ) atts [ i ] ); location: 9787 cross_layer: 4 file: parser.c
------------------------------
21 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3521 @@ ['end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
int len = 0 , l ; location: 3472 cross_layer: 1 file: parser.c
int c ; location: 3473 cross_layer: 1 file: parser.c
int count = 0 ; location: 3474 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
c = CUR_CHAR ( l ); location: 3486 cross_layer: 1 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 1 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 1 file: parser.c
if ( count ++ > XML_PARSER_CHUNK_SIZE )  location: 3494 cross_layer: 1 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 1 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 1 file: parser.c
c = CUR_CHAR ( l ); location: 3508 cross_layer: 1 file: parser.c
if ( c == 0 )  location: 3509 cross_layer: 1 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 1 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 1 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8884 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
name = xmlParseQName ( ctxt , prefix ); location: 9229 cross_layer: 4 file: parser.c
if ( name == NULL )  location: 9230 cross_layer: 4 file: parser.c
type = ( int ) ( long ) xmlHashQLookup2 ( ctxt -> attsSpecial , pref , elem , * prefix , name ); location: 9242 cross_layer: 4 file: parser.c
if ( type != 0 )  location: 9244 cross_layer: 4 file: parser.c
xmlFatalErrMsgStr ( ctxt , XML_ERR_ATTRIBUTE_WITHOUT_VALUE , "Specification mandate value for attribute %s\n" , name ); location: 9275 cross_layer: 4 file: parser.c
static void
xmlFatalErrMsgStr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg, const xmlChar * val) location: 728 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 730 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 733 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 734 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , error , XML_ERR_FATAL , NULL , 0 , ( const char * ) val , NULL , NULL , 0 , 0 , msg , val ); location: 735 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 739 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 740 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 741 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 742 cross_layer: 5 file: parser.c
if ( ( ctxt -> pedantic ) && ( xmlStrEqual ( name , BAD_CAST "lang" ) ) ) location: 9287 cross_layer: 4 file: parser.c
int
xmlStrEqual(const xmlChar *str1, const xmlChar *str2) location: 157 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == str2 )  location: 158 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == NULL )  location: 159 cross_layer: 5 file: testCode/xmlstring.c
if ( str2 == NULL )  location: 160 cross_layer: 5 file: testCode/xmlstring.c
if ( * str1 ++ != * str2 )  location: 162 cross_layer: 5 file: testCode/xmlstring.c
while ( * str2 ++ )  location: 163 cross_layer: 5 file: testCode/xmlstring.c
if ( xmlStrEqual ( name , BAD_CAST "space" ) ) location: 9299 cross_layer: 4 file: parser.c
int
xmlStrEqual(const xmlChar *str1, const xmlChar *str2) location: 157 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == str2 )  location: 158 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == NULL )  location: 159 cross_layer: 5 file: testCode/xmlstring.c
if ( str2 == NULL )  location: 160 cross_layer: 5 file: testCode/xmlstring.c
if ( * str1 ++ != * str2 )  location: 162 cross_layer: 5 file: testCode/xmlstring.c
while ( * str2 ++ )  location: 163 cross_layer: 5 file: testCode/xmlstring.c
return ( name ) ; location: 9317 cross_layer: 4 file: parser.c
------------------------------
22 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3521 @@ ['end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
int len = 0 , l ; location: 3472 cross_layer: 1 file: parser.c
int c ; location: 3473 cross_layer: 1 file: parser.c
int count = 0 ; location: 3474 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
c = CUR_CHAR ( l ); location: 3486 cross_layer: 1 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 1 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 1 file: parser.c
if ( count ++ > XML_PARSER_CHUNK_SIZE )  location: 3494 cross_layer: 1 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 1 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 1 file: parser.c
c = CUR_CHAR ( l ); location: 3508 cross_layer: 1 file: parser.c
if ( c == 0 )  location: 3509 cross_layer: 1 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 1 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 1 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8868 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8869 cross_layer: 3 file: parser.c
if ( l != NULL )  location: 8872 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s'\n" , l , NULL , NULL ); location: 8873 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
return ( l ) ; location: 8876 cross_layer: 3 file: parser.c
p = l; location: 8883 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:'\n" , p , NULL , NULL ); location: 8888 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , p , NULL , 0 ) location: 8892 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , l , NULL , 0 ) location: 8916 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8917 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8918 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8918 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
return ( l ) ; location: 8920 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
ret = xmlParseQName ( ctxt , & prefix2 ); location: 8975 cross_layer: 4 file: parser.c
if ( ( ret == name ) && ( prefix == prefix2 ) )  location: 8976 cross_layer: 4 file: parser.c
return ret ; location: 8978 cross_layer: 4 file: parser.c
------------------------------
23 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3521 @@ ['end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
int len = 0 , l ; location: 3472 cross_layer: 1 file: parser.c
int c ; location: 3473 cross_layer: 1 file: parser.c
int count = 0 ; location: 3474 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
c = CUR_CHAR ( l ); location: 3486 cross_layer: 1 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 1 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 1 file: parser.c
if ( count ++ > XML_PARSER_CHUNK_SIZE )  location: 3494 cross_layer: 1 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 1 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 1 file: parser.c
c = CUR_CHAR ( l ); location: 3508 cross_layer: 1 file: parser.c
if ( c == 0 )  location: 3509 cross_layer: 1 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 1 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 1 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8868 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8869 cross_layer: 3 file: parser.c
if ( l != NULL )  location: 8872 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s'\n" , l , NULL , NULL ); location: 8873 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
return ( l ) ; location: 8876 cross_layer: 3 file: parser.c
p = l; location: 8883 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:'\n" , p , NULL , NULL ); location: 8888 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , p , NULL , 0 ) location: 8892 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , l , NULL , 0 ) location: 8916 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8917 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8918 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8918 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
return ( l ) ; location: 8920 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
localname = xmlParseQName ( ctxt , & prefix ); location: 9390 cross_layer: 4 file: parser.c
if ( localname == NULL )  location: 9391 cross_layer: 4 file: parser.c
attname = xmlParseAttribute2 ( ctxt , prefix , localname , & aprefix , & attvalue , & len , & alloc ); location: 9415 cross_layer: 4 file: parser.c
static const xmlChar *
xmlParseAttribute2(xmlParserCtxtPtr ctxt,
const xmlChar * pref, const xmlChar * elem,
const xmlChar ** prefix, xmlChar ** value,
int *len, int *alloc) location: 9221 cross_layer: 5 file: parser.c
* value = NULL; location: 9227 cross_layer: 5 file: parser.c
name = xmlParseQName ( ctxt , prefix ); location: 9229 cross_layer: 5 file: parser.c
if ( name == NULL )  location: 9230 cross_layer: 5 file: parser.c
xmlFatalErrMsg ( ctxt , XML_ERR_NAME_REQUIRED , "error parsing attribute name\n" ); location: 9231 cross_layer: 5 file: parser.c
if ( ctxt -> attsSpecial != NULL )  location: 9239 cross_layer: 5 file: parser.c
type = ( int ) ( long ) xmlHashQLookup2 ( ctxt -> attsSpecial , pref , elem , * prefix , name ); location: 9242 cross_layer: 5 file: parser.c
if ( type != 0 )  location: 9244 cross_layer: 5 file: parser.c
val = xmlParseAttValueInternal ( ctxt , len , alloc , normalize ); location: 9255 cross_layer: 5 file: parser.c
if ( * alloc )  location: 9263 cross_layer: 5 file: parser.c
val2 = xmlAttrNormalizeSpace2 ( ctxt , val , len ); location: 9266 cross_layer: 5 file: parser.c
if ( ( val2 != NULL ) && ( val2 != val ) )  location: 9267 cross_layer: 5 file: parser.c
xmlFree ( val ); location: 9268 cross_layer: 5 file: parser.c
val = ( xmlChar * ) val2; location: 9269 cross_layer: 5 file: parser.c
ctxt -> instate = XML_PARSER_CONTENT; location: 9273 cross_layer: 5 file: parser.c
xmlFatalErrMsgStr ( ctxt , XML_ERR_ATTRIBUTE_WITHOUT_VALUE , "Specification mandate value for attribute %s\n" , name ); location: 9275 cross_layer: 5 file: parser.c
if ( * prefix == ctxt -> str_xml )  location: 9281 cross_layer: 5 file: parser.c
if ( ( ctxt -> pedantic ) && ( xmlStrEqual ( name , BAD_CAST "lang" ) ) ) location: 9287 cross_layer: 5 file: parser.c
internal_val = xmlStrndup ( val , * len ); location: 9288 cross_layer: 5 file: parser.c
if ( ! xmlCheckLanguageID ( internal_val ) )  location: 9289 cross_layer: 5 file: parser.c
xmlWarningMsg ( ctxt , XML_WAR_LANG_VALUE , "Malformed value for xml:lang : %s\n" , internal_val , NULL ); location: 9290 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( name , BAD_CAST "space" ) ) location: 9299 cross_layer: 5 file: parser.c
internal_val = xmlStrndup ( val , * len ); location: 9300 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( internal_val , BAD_CAST "default" ) ) location: 9301 cross_layer: 5 file: parser.c
* ( ctxt -> space ) = 0; location: 9302 cross_layer: 5 file: parser.c
if ( xmlStrEqual ( internal_val , BAD_CAST "preserve" ) ) location: 9303 cross_layer: 5 file: parser.c
* ( ctxt -> space ) = 1; location: 9304 cross_layer: 5 file: parser.c
xmlWarningMsg ( ctxt , XML_WAR_SPACE_VALUE , "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n" , internal_val , NULL ); location: 9306 cross_layer: 5 file: parser.c
if ( internal_val )  location: 9311 cross_layer: 5 file: parser.c
xmlFree ( internal_val ); location: 9312 cross_layer: 5 file: parser.c
* value = val; location: 9316 cross_layer: 5 file: parser.c
return ( name ) ; location: 9317 cross_layer: 5 file: parser.c
if ( ( attname != NULL ) && ( attvalue != NULL ) )  location: 9423 cross_layer: 4 file: parser.c
if ( ( attname == ctxt -> str_xmlns ) && ( aprefix == NULL ) )  location: 9425 cross_layer: 4 file: parser.c
if ( attname != ctxt -> str_xml )  location: 9450 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , NULL , attname ); location: 9473 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( attname == ctxt -> str_xml )  location: 9492 cross_layer: 4 file: parser.c
if ( attname != ctxt -> str_xml )  location: 9504 cross_layer: 4 file: parser.c
if ( attname == ctxt -> str_xmlns )  location: 9511 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_XML_NAMESPACE , "xmlns:%s: Empty XML namespace is not allowed\n" , attname , NULL , NULL ); location: 9526 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
xmlNsErr ( ctxt , XML_WAR_NS_URI , "xmlns:%s: '%s' is not a valid URI\n" , attname , URL , NULL ); location: 9533 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
xmlNsWarn ( ctxt , XML_WAR_NS_URI_RELATIVE , "xmlns:%s: URI %s is not absolute\n" , attname , URL , NULL ); location: 9538 cross_layer: 4 file: parser.c
static void
xmlNsWarn(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 813 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 815 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_WARNING , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 818 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ ctxt -> nsNr - 2 * j ] == attname )  location: 9550 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , aprefix , attname ); location: 9553 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( nsPush ( ctxt , attname , URL ) > 0 )  location: 9555 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
for (i = ctxt->nsNr - 2;i >= 0;i -= 2) location: 1589 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = attname; location: 9584 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = aprefix; location: 9585 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = NULL; location: 9586 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = attvalue; location: 9587 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = attvalue; location: 9589 cross_layer: 4 file: parser.c
if ( ( cons == ctxt -> input -> consumed ) && ( q == CUR_PTR ) && ( attname == NULL ) && ( attvalue == NULL ) )  location: 9614 cross_layer: 4 file: parser.c
defaults = xmlHashLookup2 ( ctxt -> attsDefault , localname , prefix ); location: 9631 cross_layer: 4 file: parser.c
if ( defaults != NULL )  location: 9632 cross_layer: 4 file: parser.c
for (i = 0;i < defaults->nbAttrs;i++) location: 9633 cross_layer: 4 file: parser.c
attname = defaults -> values [ 5 * i ]; location: 9634 cross_layer: 4 file: parser.c
aprefix = defaults -> values [ 5 * i + 1 ]; location: 9635 cross_layer: 4 file: parser.c
if ( ( attname == ctxt -> str_xmlns ) && ( aprefix == NULL ) )  location: 9640 cross_layer: 4 file: parser.c
if ( nsname != defaults -> values [ 5 * i + 2 ] )  location: 9650 cross_layer: 4 file: parser.c
if ( nsPush ( ctxt , NULL , defaults -> values [ 5 * i + 2 ] ) > 0 )  location: 9651 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
if ( aprefix == ctxt -> str_xmlns )  location: 9655 cross_layer: 4 file: parser.c
if ( ctxt -> nsTab [ ctxt -> nsNr - 2 * j ] == attname )  location: 9660 cross_layer: 4 file: parser.c
nsname = xmlGetNamespace ( ctxt , attname ); location: 9664 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
for (i = ctxt->nsNr - 2;i >= 0;i-=2) location: 8839 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
if ( nsname != defaults -> values [ 2 ] )  location: 9665 cross_layer: 4 file: parser.c
if ( nsPush ( ctxt , attname , defaults -> values [ 5 * i + 2 ] ) > 0 )  location: 9666 cross_layer: 4 file: parser.c
static int
nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL) location: 1585 cross_layer: 5 file: parser.c
if ( ctxt -> options & XML_PARSE_NSCLEAN )  location: 1587 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 1590 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i + 1 ] == URL )  location: 1592 cross_layer: 5 file: parser.c
if ( ( ctxt -> nsMax == 0 ) || ( ctxt -> nsTab == NULL ) )  location: 1599 cross_layer: 5 file: parser.c
ctxt -> nsMax = 10; location: 1600 cross_layer: 5 file: parser.c
ctxt -> nsNr = 0; location: 1601 cross_layer: 5 file: parser.c
ctxt -> nsTab = ( const xmlChar * * ) xmlMalloc ( ctxt -> nsMax * sizeof ( xmlChar * ) ); location: 1602 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab == NULL )  location: 1604 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1605 cross_layer: 5 file: parser.c
ctxt -> nsMax = 0; location: 1606 cross_layer: 5 file: parser.c
if ( ctxt -> nsNr >= ctxt -> nsMax )  location: 1609 cross_layer: 5 file: parser.c
ctxt -> nsMax *= 2; location: 1611 cross_layer: 5 file: parser.c
tmp = ( const xmlChar * * ) xmlRealloc ( ( char * ) ctxt -> nsTab , ctxt -> nsMax * sizeof ( ctxt -> nsTab [ 0 ] ) ); location: 1612 cross_layer: 5 file: parser.c
if ( tmp == NULL )  location: 1614 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1615 cross_layer: 5 file: parser.c
ctxt -> nsMax /= 2; location: 1616 cross_layer: 5 file: parser.c
ctxt -> nsTab = tmp; location: 1619 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = prefix; location: 1621 cross_layer: 5 file: parser.c
ctxt -> nsTab [ ctxt -> nsNr ++ ] = URL; location: 1622 cross_layer: 5 file: parser.c
return ( ctxt -> nsNr ) ; location: 1623 cross_layer: 5 file: parser.c
for (j = 0;j < nbatts;j+=5) location: 9674 cross_layer: 4 file: parser.c
if ( ( attname == atts [ j ] ) && ( aprefix == atts [ j + 1 ] ) )  location: 9675 cross_layer: 4 file: parser.c
if ( j < nbatts )  location: 9678 cross_layer: 4 file: parser.c
if ( ( atts == NULL ) || ( nbatts + 5 > maxatts ) )  location: 9680 cross_layer: 4 file: parser.c
if ( xmlCtxtGrowAttrs ( ctxt , nbatts + 5 ) < 0 )  location: 9681 cross_layer: 4 file: parser.c
static int
xmlCtxtGrowAttrs(xmlParserCtxtPtr ctxt, int nr) location: 1656 cross_layer: 5 file: parser.c
if ( ctxt -> atts == NULL )  location: 1661 cross_layer: 5 file: parser.c
ctxt -> atts = atts; location: 1666 cross_layer: 5 file: parser.c
ctxt -> attallocs = attallocs; location: 1669 cross_layer: 5 file: parser.c
ctxt -> maxatts = maxatts; location: 1670 cross_layer: 5 file: parser.c
if ( nr + 5 > ctxt -> maxatts )  location: 1671 cross_layer: 5 file: parser.c
maxatts = ( nr + 5 ) * 2; location: 1672 cross_layer: 5 file: parser.c
atts = ( const xmlChar * * ) xmlRealloc ( ( void * ) ctxt -> atts , maxatts * sizeof ( const xmlChar * ) ); location: 1673 cross_layer: 5 file: parser.c
if ( atts == NULL )  location: 1675 cross_layer: 5 file: parser.c
ctxt -> atts = atts; location: 1676 cross_layer: 5 file: parser.c
attallocs = ( int * ) xmlRealloc ( ( void * ) ctxt -> attallocs , ( maxatts / 5 ) * sizeof ( int ) ); location: 1677 cross_layer: 5 file: parser.c
if ( attallocs == NULL )  location: 1679 cross_layer: 5 file: parser.c
ctxt -> attallocs = attallocs; location: 1680 cross_layer: 5 file: parser.c
ctxt -> maxatts = maxatts; location: 1681 cross_layer: 5 file: parser.c
return ( ctxt -> maxatts ) ; location: 1683 cross_layer: 5 file: parser.c
xmlErrMemory ( ctxt , NULL ); location: 1685 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = attname; location: 9687 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = aprefix; location: 9688 cross_layer: 4 file: parser.c
if ( aprefix == NULL )  location: 9689 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = NULL; location: 9690 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = xmlGetNamespace ( ctxt , aprefix ); location: 9692 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
atts [ nbatts ++ ] = defaults -> values [ 5 * i + 2 ]; location: 9693 cross_layer: 4 file: parser.c
atts [ nbatts ++ ] = defaults -> values [ 5 * i + 3 ]; location: 9694 cross_layer: 4 file: parser.c
if ( ( ctxt -> standalone == 1 ) && ( defaults -> values [ 5 * i + 4 ] != NULL ) )  location: 9695 cross_layer: 4 file: parser.c
xmlValidityError ( ctxt , XML_DTD_STANDALONE_DEFAULTED , "standalone: attribute %s on %s defaulted from external subset\n" , attname , localname ); location: 9697 cross_layer: 4 file: parser.c
static void
xmlValidityError(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg, const xmlChar *str1, const xmlChar *str2) location: 628 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 632 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 635 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 636 cross_layer: 5 file: parser.c
if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> initialized == XML_SAX2_MAGIC ) )  location: 637 cross_layer: 5 file: parser.c
schannel = ctxt -> sax -> serror; location: 638 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 640 cross_layer: 5 file: parser.c
__xmlRaiseError ( schannel , ctxt -> vctxt . error , ctxt -> vctxt . userData , ctxt , NULL , XML_FROM_DTD , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) str1 , ( const char * ) str2 , NULL , 0 , 0 , msg , ( const char * ) str1 , ( const char * ) str2 ); location: 641 cross_layer: 5 file: parser.c
ctxt -> valid = 0; location: 647 cross_layer: 5 file: parser.c
__xmlRaiseError ( schannel , NULL , NULL , ctxt , NULL , XML_FROM_DTD , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) str1 , ( const char * ) str2 , NULL , 0 , 0 , msg , ( const char * ) str1 , ( const char * ) str2 ); location: 649 cross_layer: 5 file: parser.c
for (i = 0; i < nbatts;i += 5) location: 9710 cross_layer: 4 file: parser.c
if ( atts [ i + 1 ] != NULL )  location: 9714 cross_layer: 4 file: parser.c
nsname = xmlGetNamespace ( ctxt , atts [ i + 1 ] ); location: 9715 cross_layer: 4 file: parser.c
static const xmlChar *
xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) location: 8835 cross_layer: 5 file: parser.c
if ( prefix == ctxt -> str_xml )  location: 8838 cross_layer: 5 file: parser.c
return ( ctxt -> str_xml_ns ) ; location: 8838 cross_layer: 5 file: parser.c
if ( ctxt -> nsTab [ i ] == prefix )  location: 8840 cross_layer: 5 file: parser.c
if ( ( prefix == NULL ) && ( * ctxt -> nsTab [ i + 1 ] == 0 ) )  location: 8841 cross_layer: 5 file: parser.c
return ( ctxt -> nsTab [ i + 1 ] ) ; location: 8843 cross_layer: 5 file: parser.c
if ( nsname == NULL )  location: 9716 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_UNDEFINED_NAMESPACE , "Namespace prefix %s for %s on %s is not defined\n" , atts [ i + 1 ] , atts [ i ] , localname ); location: 9717 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
atts [ i + 2 ] = nsname; location: 9721 cross_layer: 4 file: parser.c
for (j = 0; j < i;j += 5) location: 9730 cross_layer: 4 file: parser.c
if ( atts [ i ] == atts [ j ] )  location: 9731 cross_layer: 4 file: parser.c
if ( atts [ i + 1 ] == atts [ j + 1 ] )  location: 9732 cross_layer: 4 file: parser.c
xmlErrAttributeDup ( ctxt , atts [ i + 1 ] , atts [ i ] ); location: 9733 cross_layer: 4 file: parser.c
static void
xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
const xmlChar * localname) location: 311 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 313 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 316 cross_layer: 5 file: parser.c
ctxt -> errNo = XML_ERR_ATTRIBUTE_REDEFINED; location: 317 cross_layer: 5 file: parser.c
if ( prefix == NULL )  location: 319 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) localname , NULL , NULL , 0 , 0 , "Attribute %s redefined\n" , localname ); location: 320 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , XML_ERR_ATTRIBUTE_REDEFINED , XML_ERR_FATAL , NULL , 0 , ( const char * ) prefix , ( const char * ) localname , NULL , 0 , 0 , "Attribute %s:%s redefined\n" , prefix , localname ); location: 325 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 330 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 331 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 332 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 333 cross_layer: 5 file: parser.c
if ( ( nsname != NULL ) && ( atts [ j + 2 ] == nsname ) )  location: 9736 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_ATTRIBUTE_REDEFINED , "Namespaced Attribute %s in '%s' redefined\n" , atts [ i ] , nsname , NULL ); location: 9737 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
if ( ( prefix != NULL ) && ( nsname == NULL ) )  location: 9747 cross_layer: 4 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_UNDEFINED_NAMESPACE , "Namespace prefix %s on %s is not defined\n" , prefix , localname , NULL ); location: 9748 cross_layer: 4 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 5 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 5 file: parser.c
* URI = nsname; location: 9753 cross_layer: 4 file: parser.c
ctxt -> sax -> startElementNs ( ctxt -> userData , localname , prefix , nsname , nbNs , & ctxt -> nsTab [ ctxt -> nsNr - 2 * nbNs ] , nbatts / 5 , nbdef , atts ); location: 9761 cross_layer: 4 file: parser.c
ctxt -> sax -> startElementNs ( ctxt -> userData , localname , prefix , nsname , 0 , NULL , nbatts / 5 , nbdef , atts ); location: 9765 cross_layer: 4 file: parser.c
for (i = 3,j = 0; j < nratts;i += 5,j++) location: 9773 cross_layer: 4 file: parser.c
if ( ( ctxt -> attallocs [ j ] != 0 ) && ( atts [ i ] != NULL ) )  location: 9774 cross_layer: 4 file: parser.c
xmlFree ( ( xmlChar * ) atts [ i ] ); location: 9775 cross_layer: 4 file: parser.c
return ( localname ) ; location: 9778 cross_layer: 4 file: parser.c
if ( ( ctxt -> attallocs [ j ] != 0 ) && ( atts [ i ] != NULL ) )  location: 9786 cross_layer: 4 file: parser.c
xmlFree ( ( xmlChar * ) atts [ i ] ); location: 9787 cross_layer: 4 file: parser.c
------------------------------
24 @@ testCode/CVE-2016-1836_CWE-416_45752d2c334b50016666d8f0ec3691e2d680f0a0_parser.c_OLD.c @@ xmlParseNCNameComplex @@ 3521 @@ ['end'] @@ {end}
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 1 file: parser.c
int len = 0 , l ; location: 3472 cross_layer: 1 file: parser.c
int c ; location: 3473 cross_layer: 1 file: parser.c
int count = 0 ; location: 3474 cross_layer: 1 file: parser.c
const xmlChar * end ; location: 3475 cross_layer: 1 file: parser.c
c = CUR_CHAR ( l ); location: 3486 cross_layer: 1 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 1 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 1 file: parser.c
if ( count ++ > XML_PARSER_CHUNK_SIZE )  location: 3494 cross_layer: 1 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 1 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 1 file: parser.c
c = CUR_CHAR ( l ); location: 3508 cross_layer: 1 file: parser.c
if ( c == 0 )  location: 3509 cross_layer: 1 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 1 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 1 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 1 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 1 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 1 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 2 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 2 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 2 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 2 file: testCode/dict.c
l = len; location: 842 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 2 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 2 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 2 file: testCode/dict.c
for (insert = &(dict->dict[key]); insert->next != NULL;
insert = insert->next) location: 857 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 2 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 2 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 2 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 2 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 2 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 2 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 2 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 2 file: testCode/dict.c
for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;
tmp = tmp->next) location: 899 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 2 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 2 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 2 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 2 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 2 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 2 file: testCode/dict.c
static const xmlChar *
xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) location: 241 cross_layer: 3 file: testCode/dict.c
pool = dict -> strings; location: 250 cross_layer: 3 file: testCode/dict.c
while ( pool != NULL )  location: 251 cross_layer: 3 file: testCode/dict.c
if ( pool -> end - pool -> free > namelen )  location: 252 cross_layer: 3 file: testCode/dict.c
if ( pool -> size > size )  location: 254 cross_layer: 3 file: testCode/dict.c
size = pool -> size; location: 254 cross_layer: 3 file: testCode/dict.c
limit += pool -> size; location: 255 cross_layer: 3 file: testCode/dict.c
pool = pool -> next; location: 256 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 261 cross_layer: 3 file: testCode/dict.c
if ( ( dict -> limit > 0 ) && ( limit > dict -> limit ) )  location: 262 cross_layer: 3 file: testCode/dict.c
if ( size == 0 )  location: 266 cross_layer: 3 file: testCode/dict.c
size *= 4; location: 267 cross_layer: 3 file: testCode/dict.c
if ( size < 4 * namelen )  location: 268 cross_layer: 3 file: testCode/dict.c
size = 4 * namelen; location: 269 cross_layer: 3 file: testCode/dict.c
pool = ( xmlDictStringsPtr ) xmlMalloc ( sizeof ( xmlDictStrings ) + size ); location: 270 cross_layer: 3 file: testCode/dict.c
if ( pool == NULL )  location: 271 cross_layer: 3 file: testCode/dict.c
pool -> size = size; location: 273 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings = 0; location: 274 cross_layer: 3 file: testCode/dict.c
pool -> free = & pool -> array [ 0 ]; location: 275 cross_layer: 3 file: testCode/dict.c
pool -> end = & pool -> array [ size ]; location: 276 cross_layer: 3 file: testCode/dict.c
pool -> next = dict -> strings; location: 277 cross_layer: 3 file: testCode/dict.c
dict -> strings = pool; location: 278 cross_layer: 3 file: testCode/dict.c
ret = pool -> free; location: 284 cross_layer: 3 file: testCode/dict.c
memcpy ( pool -> free , name , namelen ); location: 285 cross_layer: 3 file: testCode/dict.c
pool -> free += namelen; location: 286 cross_layer: 3 file: testCode/dict.c
* ( pool -> free ++ ) = 0; location: 287 cross_layer: 3 file: testCode/dict.c
pool -> nbStrings ++; location: 288 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 289 cross_layer: 3 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 2 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 2 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 2 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 2 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 2 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 2 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 2 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 2 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 2 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 2 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 2 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 2 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 2 file: testCode/dict.c
static int
xmlDictGrow(xmlDictPtr dict, size_t size) location: 631 cross_layer: 3 file: testCode/dict.c
if ( dict == NULL )  location: 642 cross_layer: 3 file: testCode/dict.c
if ( size < 8 )  location: 644 cross_layer: 3 file: testCode/dict.c
if ( size > 8 * 2048 )  location: 646 cross_layer: 3 file: testCode/dict.c
oldsize = dict -> size; location: 653 cross_layer: 3 file: testCode/dict.c
olddict = dict -> dict; location: 654 cross_layer: 3 file: testCode/dict.c
if ( olddict == NULL )  location: 655 cross_layer: 3 file: testCode/dict.c
if ( oldsize == MIN_DICT_SIZE )  location: 657 cross_layer: 3 file: testCode/dict.c
dict -> dict = xmlMalloc ( size * sizeof ( xmlDictEntry ) ); location: 660 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict == NULL )  location: 661 cross_layer: 3 file: testCode/dict.c
dict -> dict = olddict; location: 662 cross_layer: 3 file: testCode/dict.c
memset ( dict -> dict , 0 , size * sizeof ( xmlDictEntry ) ); location: 665 cross_layer: 3 file: testCode/dict.c
dict -> size = size; location: 666 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 674 cross_layer: 3 file: testCode/dict.c
if ( olddict [ i ] . valid == 0 )  location: 675 cross_layer: 3 file: testCode/dict.c
okey = olddict [ i ] . okey; location: 679 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , olddict [ i ] . name , olddict [ i ] . len ); location: 681 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 682 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 684 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , & ( olddict [ i ] ) , sizeof ( xmlDictEntry ) ); location: 685 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 686 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 687 cross_layer: 3 file: testCode/dict.c
entry -> name = olddict [ i ] . name; location: 693 cross_layer: 3 file: testCode/dict.c
entry -> len = olddict [ i ] . len; location: 694 cross_layer: 3 file: testCode/dict.c
entry -> okey = okey; location: 695 cross_layer: 3 file: testCode/dict.c
entry -> next = dict -> dict [ key ] . next; location: 696 cross_layer: 3 file: testCode/dict.c
entry -> valid = 1; location: 697 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = entry; location: 698 cross_layer: 3 file: testCode/dict.c
for (i = 0; i < oldsize; i++) location: 712 cross_layer: 3 file: testCode/dict.c
iter = olddict [ i ] . next; location: 713 cross_layer: 3 file: testCode/dict.c
while ( iter )  location: 714 cross_layer: 3 file: testCode/dict.c
next = iter -> next; location: 715 cross_layer: 3 file: testCode/dict.c
okey = iter -> okey; location: 722 cross_layer: 3 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , iter -> name , iter -> len ); location: 724 cross_layer: 3 file: testCode/dict.c
key = okey % dict -> size; location: 725 cross_layer: 3 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 726 cross_layer: 3 file: testCode/dict.c
memcpy ( & ( dict -> dict [ key ] ) , iter , sizeof ( xmlDictEntry ) ); location: 727 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = NULL; location: 728 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . valid = 1; location: 729 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . okey = okey; location: 730 cross_layer: 3 file: testCode/dict.c
xmlFree ( iter ); location: 731 cross_layer: 3 file: testCode/dict.c
iter -> next = dict -> dict [ key ] . next; location: 733 cross_layer: 3 file: testCode/dict.c
iter -> okey = okey; location: 734 cross_layer: 3 file: testCode/dict.c
dict -> dict [ key ] . next = iter; location: 735 cross_layer: 3 file: testCode/dict.c
iter = next; location: 742 cross_layer: 3 file: testCode/dict.c
xmlFree ( olddict ); location: 746 cross_layer: 3 file: testCode/dict.c
xmlGenericError ( xmlGenericErrorContext , "xmlDictGrow : from %lu to %lu, %u elems\n" , oldsize , size , nbElem ); location: 749 cross_layer: 3 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 2 file: testCode/dict.c
return ( xmlParseNCNameComplex ( ctxt ) ) ; location: 3593 cross_layer: 2 file: parser.c
static const xmlChar *
xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) location: 3471 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3485 cross_layer: 3 file: parser.c
if ( ( c == ' ' ) || ( c == '>' ) || ( c == '/' ) || ( ! xmlIsNameStartChar ( ctxt , c ) || ( c == ':' ) ) )  location: 3487 cross_layer: 3 file: parser.c
while ( ( c != ' ' ) && ( c != '>' ) && ( c != '/' ) && ( xmlIsNameChar ( ctxt , c ) && ( c != ':' ) ) )  location: 3492 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3495 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3497 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3502 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3507 cross_layer: 3 file: parser.c
ctxt -> input -> cur -= l; location: 3516 cross_layer: 3 file: parser.c
ctxt -> input -> cur += l; location: 3518 cross_layer: 3 file: parser.c
if ( ctxt -> instate == XML_PARSER_EOF )  location: 3519 cross_layer: 3 file: parser.c
end = ctxt -> input -> cur; location: 3521 cross_layer: 3 file: parser.c
if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) )  location: 3525 cross_layer: 3 file: parser.c
xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "NCName" ); location: 3527 cross_layer: 3 file: parser.c
return ( xmlDictLookup ( ctxt -> dict , end - len , len ) ) ; location: 3530 cross_layer: 3 file: parser.c
l = xmlParseNCName ( ctxt ); location: 8868 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8869 cross_layer: 3 file: parser.c
if ( l != NULL )  location: 8872 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s'\n" , l , NULL , NULL ); location: 8873 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
return ( l ) ; location: 8876 cross_layer: 3 file: parser.c
p = l; location: 8883 cross_layer: 3 file: parser.c
if ( l == NULL )  location: 8885 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:'\n" , p , NULL , NULL ); location: 8888 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( l == NULL )  location: 8891 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , p , NULL , 0 ) location: 8892 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
tmp = xmlBuildQName ( l , p , NULL , 0 ); location: 8894 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
xmlFree ( ( char * ) l ); location: 8895 cross_layer: 3 file: parser.c
p = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8897 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8898 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8898 cross_layer: 3 file: parser.c
return ( p ) ; location: 8900 cross_layer: 3 file: parser.c
xmlNsErr ( ctxt , XML_NS_ERR_QNAME , "Failed to parse QName '%s:%s:'\n" , p , l , NULL ); location: 8905 cross_layer: 3 file: parser.c
static void
xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg,
const xmlChar * info1, const xmlChar * info2,
const xmlChar * info3) location: 784 cross_layer: 4 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 786 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 789 cross_layer: 4 file: parser.c
ctxt -> errNo = error; location: 790 cross_layer: 4 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_NAMESPACE , error , XML_ERR_ERROR , NULL , 0 , ( const char * ) info1 , ( const char * ) info2 , ( const char * ) info3 , 0 , 0 , msg , info1 , info2 , info3 ); location: 791 cross_layer: 4 file: parser.c
if ( ctxt != NULL )  location: 795 cross_layer: 4 file: parser.c
ctxt -> nsWellFormed = 0; location: 796 cross_layer: 4 file: parser.c
if ( tmp != NULL )  location: 8909 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( tmp , l , NULL , 0 ); location: 8910 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8911 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8912 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8912 cross_layer: 3 file: parser.c
* prefix = p; location: 8913 cross_layer: 3 file: parser.c
return ( l ) ; location: 8914 cross_layer: 3 file: parser.c
tmp = xmlBuildQName ( BAD_CAST "" , l , NULL , 0 ) location: 8916 cross_layer: 3 file: parser.c
xmlChar *
xmlBuildQName(const xmlChar *ncname, const xmlChar *prefix,
xmlChar *memory, int len) location: 218 cross_layer: 4 file: testCode/tree.c
if ( ncname == NULL )  location: 222 cross_layer: 4 file: testCode/tree.c
if ( prefix == NULL )  location: 223 cross_layer: 4 file: testCode/tree.c
return ( ( xmlChar * ) ncname ) ; location: 223 cross_layer: 4 file: testCode/tree.c
lenn = strlen ( ( char * ) ncname ); location: 225 cross_layer: 4 file: testCode/tree.c
lenp = strlen ( ( char * ) prefix ); location: 226 cross_layer: 4 file: testCode/tree.c
if ( ( memory == NULL ) || ( len < lenn + lenp + 2 ) )  location: 228 cross_layer: 4 file: testCode/tree.c
ret = ( xmlChar * ) xmlMallocAtomic ( lenn + lenp + 2 ); location: 229 cross_layer: 4 file: testCode/tree.c
if ( ret == NULL )  location: 230 cross_layer: 4 file: testCode/tree.c
ret = memory; location: 235 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ 0 ] , prefix , lenp ); location: 237 cross_layer: 4 file: testCode/tree.c
ret [ lenp ] = ':'; location: 238 cross_layer: 4 file: testCode/tree.c
memcpy ( & ret [ lenp + 1 ] , ncname , lenn ); location: 239 cross_layer: 4 file: testCode/tree.c
ret [ lenn + lenp + 1 ] = 0; location: 240 cross_layer: 4 file: testCode/tree.c
return ( ret ) ; location: 241 cross_layer: 4 file: testCode/tree.c
l = xmlDictLookup ( ctxt -> dict , tmp , - 1 ); location: 8917 cross_layer: 3 file: parser.c
const xmlChar *
xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) location: 829 cross_layer: 4 file: testCode/dict.c
if ( ( dict == NULL ) || ( name == NULL ) )  location: 836 cross_layer: 4 file: testCode/dict.c
if ( len < 0 )  location: 839 cross_layer: 4 file: testCode/dict.c
l = strlen ( ( const char * ) name ); location: 840 cross_layer: 4 file: testCode/dict.c
l = len; location: 842 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> limit > 0 ) && ( l >= dict -> limit ) ) || ( l > INT_MAX / 2 ) )  location: 844 cross_layer: 4 file: testCode/dict.c
okey = xmlDictComputeKey ( dict , name , l ); location: 851 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 852 cross_layer: 4 file: testCode/dict.c
if ( dict -> dict [ key ] . valid == 0 )  location: 853 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 859 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 860 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 861 cross_layer: 4 file: testCode/dict.c
if ( ( insert -> okey == okey ) && ( insert -> len == l ) )  location: 871 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( insert -> name , name , l ) )  location: 872 cross_layer: 4 file: testCode/dict.c
return ( insert -> name ) ; location: 873 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict )  location: 882 cross_layer: 4 file: testCode/dict.c
if ( ( ( dict -> size == MIN_DICT_SIZE ) && ( dict -> subdict -> size != MIN_DICT_SIZE ) ) || ( ( dict -> size != MIN_DICT_SIZE ) && ( dict -> subdict -> size == MIN_DICT_SIZE ) ) )  location: 886 cross_layer: 4 file: testCode/dict.c
skey = xmlDictComputeKey ( dict -> subdict , name , l ); location: 890 cross_layer: 4 file: testCode/dict.c
skey = okey; location: 892 cross_layer: 4 file: testCode/dict.c
key = skey % dict -> subdict -> size; location: 894 cross_layer: 4 file: testCode/dict.c
if ( dict -> subdict -> dict [ key ] . valid != 0 )  location: 895 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 901 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 902 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 903 cross_layer: 4 file: testCode/dict.c
if ( ( tmp -> okey == skey ) && ( tmp -> len == l ) )  location: 913 cross_layer: 4 file: testCode/dict.c
if ( ! memcmp ( tmp -> name , name , l ) )  location: 914 cross_layer: 4 file: testCode/dict.c
return ( tmp -> name ) ; location: 915 cross_layer: 4 file: testCode/dict.c
key = okey % dict -> size; location: 923 cross_layer: 4 file: testCode/dict.c
ret = xmlDictAddString ( dict , name , l ); location: 926 cross_layer: 4 file: testCode/dict.c
if ( ret == NULL )  location: 927 cross_layer: 4 file: testCode/dict.c
if ( insert == NULL )  location: 929 cross_layer: 4 file: testCode/dict.c
entry = & ( dict -> dict [ key ] ); location: 930 cross_layer: 4 file: testCode/dict.c
entry -> name = ret; location: 936 cross_layer: 4 file: testCode/dict.c
entry -> len = l; location: 937 cross_layer: 4 file: testCode/dict.c
entry -> next = NULL; location: 938 cross_layer: 4 file: testCode/dict.c
entry -> valid = 1; location: 939 cross_layer: 4 file: testCode/dict.c
entry -> okey = okey; location: 940 cross_layer: 4 file: testCode/dict.c
if ( insert != NULL )  location: 943 cross_layer: 4 file: testCode/dict.c
insert -> next = entry; location: 944 cross_layer: 4 file: testCode/dict.c
dict -> nbElems ++; location: 946 cross_layer: 4 file: testCode/dict.c
if ( ( nbi > MAX_HASH_LEN ) && ( dict -> size <= ( ( MAX_DICT_HASH / 2 ) / MAX_HASH_LEN ) ) )  location: 948 cross_layer: 4 file: testCode/dict.c
if ( xmlDictGrow ( dict , MAX_HASH_LEN * 2 * dict -> size ) != 0 )  location: 950 cross_layer: 4 file: testCode/dict.c
return ( ret ) ; location: 955 cross_layer: 4 file: testCode/dict.c
if ( tmp != NULL )  location: 8918 cross_layer: 3 file: parser.c
xmlFree ( tmp ); location: 8918 cross_layer: 3 file: parser.c
* prefix = p; location: 8919 cross_layer: 3 file: parser.c
return ( l ) ; location: 8920 cross_layer: 3 file: parser.c
* prefix = p; location: 8922 cross_layer: 3 file: parser.c
return ( l ) ; location: 8925 cross_layer: 3 file: parser.c
name = xmlParseQName ( ctxt , prefix ); location: 9229 cross_layer: 4 file: parser.c
if ( name == NULL )  location: 9230 cross_layer: 4 file: parser.c
type = ( int ) ( long ) xmlHashQLookup2 ( ctxt -> attsSpecial , pref , elem , * prefix , name ); location: 9242 cross_layer: 4 file: parser.c
if ( type != 0 )  location: 9244 cross_layer: 4 file: parser.c
xmlFatalErrMsgStr ( ctxt , XML_ERR_ATTRIBUTE_WITHOUT_VALUE , "Specification mandate value for attribute %s\n" , name ); location: 9275 cross_layer: 4 file: parser.c
static void
xmlFatalErrMsgStr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
const char *msg, const xmlChar * val) location: 728 cross_layer: 5 file: parser.c
if ( ( ctxt != NULL ) && ( ctxt -> disableSAX != 0 ) && ( ctxt -> instate == XML_PARSER_EOF ) )  location: 730 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 733 cross_layer: 5 file: parser.c
ctxt -> errNo = error; location: 734 cross_layer: 5 file: parser.c
__xmlRaiseError ( NULL , NULL , NULL , ctxt , NULL , XML_FROM_PARSER , error , XML_ERR_FATAL , NULL , 0 , ( const char * ) val , NULL , NULL , 0 , 0 , msg , val ); location: 735 cross_layer: 5 file: parser.c
if ( ctxt != NULL )  location: 739 cross_layer: 5 file: parser.c
ctxt -> wellFormed = 0; location: 740 cross_layer: 5 file: parser.c
if ( ctxt -> recovery == 0 )  location: 741 cross_layer: 5 file: parser.c
ctxt -> disableSAX = 1; location: 742 cross_layer: 5 file: parser.c
if ( ( ctxt -> pedantic ) && ( xmlStrEqual ( name , BAD_CAST "lang" ) ) ) location: 9287 cross_layer: 4 file: parser.c
int
xmlStrEqual(const xmlChar *str1, const xmlChar *str2) location: 157 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == str2 )  location: 158 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == NULL )  location: 159 cross_layer: 5 file: testCode/xmlstring.c
if ( str2 == NULL )  location: 160 cross_layer: 5 file: testCode/xmlstring.c
if ( * str1 ++ != * str2 )  location: 162 cross_layer: 5 file: testCode/xmlstring.c
while ( * str2 ++ )  location: 163 cross_layer: 5 file: testCode/xmlstring.c
if ( xmlStrEqual ( name , BAD_CAST "space" ) ) location: 9299 cross_layer: 4 file: parser.c
int
xmlStrEqual(const xmlChar *str1, const xmlChar *str2) location: 157 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == str2 )  location: 158 cross_layer: 5 file: testCode/xmlstring.c
if ( str1 == NULL )  location: 159 cross_layer: 5 file: testCode/xmlstring.c
if ( str2 == NULL )  location: 160 cross_layer: 5 file: testCode/xmlstring.c
if ( * str1 ++ != * str2 )  location: 162 cross_layer: 5 file: testCode/xmlstring.c
while ( * str2 ++ )  location: 163 cross_layer: 5 file: testCode/xmlstring.c
return ( name ) ; location: 9317 cross_layer: 4 file: parser.c
------------------------------
